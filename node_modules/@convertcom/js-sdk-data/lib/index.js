'use strict';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * Validates variable is array and not empty
 * @param array
 */
function arrayNotEmpty(array) {
    return Array.isArray(array) && array.length > 0;
}

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * Returns the value at path of object
 * TODO: get this utility to work with the optional mapper() helper from config
 * @param {Record<string, any>} object
 * @param {string} path
 * @param {any=} defaultValue
 * @param {boolean=} truthy Should Number 0 number and Boolean false be considered as normal value
 * @return {any}
 */
function objectDeepValue(object, path, defaultValue, truthy = false) {
    try {
        if (typeof object === 'object') {
            const v = path.split('.').reduce((a, v) => a[v], object);
            if (v || (truthy && (v === false || v === 0))) {
                return v;
            }
        }
        // eslint-disable-next-line no-empty
    }
    catch (e) { }
    {
        return null;
    }
}
/**
 * Deep merge objects and their keys and nested objects
 * Accepts arrays
 *
 * @param {...Record<any, any>} objects Objects to merge
 * @return {Record<any, any>}
 */
function objectDeepMerge(...objects) {
    const isObject = (obj) => obj && typeof obj === 'object';
    return objects.reduce((prev, obj) => {
        Object.keys(obj).forEach((key) => {
            const pVal = prev[key];
            const oVal = obj[key];
            if (Array.isArray(pVal) && Array.isArray(oVal)) {
                prev[key] = [...new Set([...oVal, ...pVal])];
            }
            else if (isObject(pVal) && isObject(oVal)) {
                prev[key] = objectDeepMerge(pVal, oVal);
            }
            else {
                prev[key] = oVal;
            }
        });
        return prev;
    }, {});
}
/**
 * Validates variable is object and not empty
 * @param object
 */
function objectNotEmpty(object) {
    return (typeof object === 'object' &&
        object !== null &&
        Object.keys(object).length > 0);
}
/**
 * Compare two objects
 * @param a
 * @param b
 */
const objectDeepEqual = (a, b) => {
    if (a === b)
        return true;
    if (typeof a != 'object' || typeof b != 'object' || a == null || b == null)
        return false;
    const keysA = Object.keys(a), keysB = Object.keys(b);
    if (keysA.length != keysB.length)
        return false;
    for (const key of keysA) {
        if (!keysB.includes(key))
            return false;
        if (typeof a[key] === 'function' || typeof b[key] === 'function') {
            if (a[key].toString() != b[key].toString())
                return false;
        }
        else {
            if (!objectDeepEqual(a[key], b[key]))
                return false;
        }
    }
    return true;
};

var murmurhash = {exports: {}};

(function (module) {
	(function(){

	  const createBuffer = (val) => new TextEncoder().encode(val);

	  /**
	   * JS Implementation of MurmurHash2
	   *
	   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
	   * @see http://github.com/garycourt/murmurhash-js
	   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
	   * @see http://sites.google.com/site/murmurhash/
	   *
	   * @param {Uint8Array | string} str ASCII only
	   * @param {number} seed Positive integer only
	   * @return {number} 32-bit positive integer hash
	   */
	  function MurmurHashV2(str, seed) {
	    if (typeof str === 'string') str = createBuffer(str);
	    let
	      l = str.length,
	      h = seed ^ l,
	      i = 0,
	      k;

	    while (l >= 4) {
	      k =
	        ((str[i] & 0xff)) |
	        ((str[++i] & 0xff) << 8) |
	        ((str[++i] & 0xff) << 16) |
	        ((str[++i] & 0xff) << 24);

	      k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));
	      k ^= k >>> 24;
	      k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));

	    h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)) ^ k;

	      l -= 4;
	      ++i;
	    }

	    switch (l) {
	    case 3: h ^= (str[i + 2] & 0xff) << 16;
	    case 2: h ^= (str[i + 1] & 0xff) << 8;
	    case 1: h ^= (str[i] & 0xff);
	            h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));
	    }

	    h ^= h >>> 13;
	    h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));
	    h ^= h >>> 15;

	    return h >>> 0;
	  }
	  /*
	   * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)
	   *
	   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
	   * @see http://github.com/garycourt/murmurhash-js
	   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
	   * @see http://sites.google.com/site/murmurhash/
	   *
	   * @param {Uint8Array | string} key ASCII only
	   * @param {number} seed Positive integer only
	   * @return {number} 32-bit positive integer hash
	   */
	  function MurmurHashV3(key, seed) {
	    if (typeof key === 'string') key = createBuffer(key);

	    let remainder, bytes, h1, h1b, c1, c2, k1, i;

	    remainder = key.length & 3; // key.length % 4
	    bytes = key.length - remainder;
	    h1 = seed;
	    c1 = 0xcc9e2d51;
	    c2 = 0x1b873593;
	    i = 0;

	    while (i < bytes) {
	        k1 =
	          ((key[i] & 0xff)) |
	          ((key[++i] & 0xff) << 8) |
	          ((key[++i] & 0xff) << 16) |
	          ((key[++i] & 0xff) << 24);
	      ++i;

	      k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
	      k1 = (k1 << 15) | (k1 >>> 17);
	      k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

	      h1 ^= k1;
	          h1 = (h1 << 13) | (h1 >>> 19);
	      h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
	      h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
	    }

	    k1 = 0;

	    switch (remainder) {
	      case 3: k1 ^= (key[i + 2] & 0xff) << 16;
	      case 2: k1 ^= (key[i + 1] & 0xff) << 8;
	      case 1: k1 ^= (key[i] & 0xff);

	      k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
	      k1 = (k1 << 15) | (k1 >>> 17);
	      k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
	      h1 ^= k1;
	    }

	    h1 ^= key.length;

	    h1 ^= h1 >>> 16;
	    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
	    h1 ^= h1 >>> 13;
	    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
	    h1 ^= h1 >>> 16;

	    return h1 >>> 0;
	  }

	  const murmur = MurmurHashV3;
	  murmur.v2 = MurmurHashV2;
	  murmur.v3 = MurmurHashV3;

	  {
	    module.exports = murmur;
	  }
	}()); 
} (murmurhash));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * String formatter tool. Transforms a space-separated string into camelCase
 * @param {string} input
 * @return {string}
 */
function camelCase(input) {
    return input
        .replace(/(?:^\w|[A-Z]|\b\w)/g, function (word, index) {
        return index === 0 ? word.toLowerCase() : word.toUpperCase();
    })
        .replace(/\s+/g, '');
}
/**
 * Check if a value is numeric
 * @param {string | number} value
 * @returns {boolean}
 */
function isNumeric(value) {
    if (typeof value === 'number') {
        return true;
    }
    const number = parseFloat(String(value));
    return Number.isFinite(number) && !isNaN(number);
}
/**
 * Convert a string to a number
 * @param {string | number} value
 * @returns {number}
 */
function toNumber(value) {
    if (typeof value === 'number') {
        return value;
    }
    const parts = String(value).split(',');
    return parseFloat(parts[0] == '0'
        ? String(value).replace(/,/g, '.')
        : String(value).replace(/,/g, ''));
}

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var _a;
/**
 * Comparison Processor. Provides comparison methods for rules validation
 */
class Comparisons {
    static equals(value, testAgainst, negation) {
        if (Array.isArray(value))
            return this._returnNegationCheck(value.indexOf(testAgainst) !== -1, negation);
        if (objectNotEmpty(value))
            return this._returnNegationCheck(Object.keys(value).indexOf(String(testAgainst)) !== -1, negation);
        value = String(value);
        testAgainst = String(testAgainst);
        value = value.valueOf().toLowerCase();
        testAgainst = testAgainst.valueOf().toLowerCase();
        return this._returnNegationCheck(value === testAgainst, negation);
    }
    static less(value, testAgainst, negation) {
        value = isNumeric(value) ? toNumber(value) : value;
        testAgainst = isNumeric(testAgainst) ? toNumber(testAgainst) : testAgainst;
        if (typeof value !== typeof testAgainst) {
            return false;
        }
        return this._returnNegationCheck(value < testAgainst, negation);
    }
    static lessEqual(value, testAgainst, negation) {
        value = isNumeric(value) ? toNumber(value) : value;
        testAgainst = isNumeric(testAgainst) ? toNumber(testAgainst) : testAgainst;
        if (typeof value !== typeof testAgainst) {
            return false;
        }
        return this._returnNegationCheck(value <= testAgainst, negation);
    }
    static contains(value, testAgainst, negation) {
        value = String(value);
        testAgainst = String(testAgainst);
        value = value.valueOf().toLowerCase();
        testAgainst = testAgainst.valueOf().toLowerCase();
        if (testAgainst.replace(/^([\s]*)|([\s]*)$/g, '').length === 0) {
            return this._returnNegationCheck(true, negation);
        }
        return this._returnNegationCheck(value.indexOf(testAgainst) !== -1, negation);
    }
    static isIn(values, testAgainst, negation = false, splitter = '|') {
        const matchedValuesArray = String(values)
            .split(splitter)
            .map((item) => {
            return String(item);
        });
        if (typeof testAgainst === 'string') {
            testAgainst = testAgainst.split(splitter);
        }
        if (!Array.isArray(testAgainst)) {
            testAgainst = [];
        }
        testAgainst = testAgainst.map((item) => {
            return String(item).valueOf().toLowerCase();
        });
        for (let i = 0; i < matchedValuesArray.length; i++) {
            if (testAgainst.indexOf(matchedValuesArray[i]) !== -1) {
                return this._returnNegationCheck(true, negation);
            }
        }
        return this._returnNegationCheck(false, negation);
    }
    static startsWith(value, testAgainst, negation) {
        value = String(value).valueOf().toLowerCase();
        testAgainst = String(testAgainst).valueOf().toLowerCase();
        return this._returnNegationCheck(value.indexOf(testAgainst) === 0, negation);
    }
    static endsWith(value, testAgainst, negation) {
        value = String(value).valueOf().toLowerCase();
        testAgainst = String(testAgainst).valueOf().toLowerCase();
        return this._returnNegationCheck(value.indexOf(testAgainst, value.length - testAgainst.length) !== -1, negation);
    }
    static regexMatches(value, testAgainst, negation) {
        value = String(value).valueOf().toLowerCase();
        testAgainst = String(testAgainst).valueOf();
        const regExp = new RegExp(testAgainst, 'i');
        return this._returnNegationCheck(regExp.test(value), negation);
    }
    static _returnNegationCheck(value, negation = false) {
        if (negation) {
            return !value;
        }
        else {
            return value;
        }
    }
}
_a = Comparisons;
Comparisons.equalsNumber = _a.equals;
Comparisons.matches = _a.equals;

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var BucketingError;
(function (BucketingError) {
    BucketingError["VARIAION_NOT_DECIDED"] = "convert.com_variation_not_decided";
})(BucketingError || (BucketingError = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var ConversionSettingKey;
(function (ConversionSettingKey) {
    ConversionSettingKey["FORCE_MULTIPLE_TRANSACTIONS"] = "forceMultipleTransactions";
})(ConversionSettingKey || (ConversionSettingKey = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
const DATA_ENTITIES = [
    'events',
    'goals',
    'audiences',
    'locations',
    'segments',
    'experiences',
    'archived_experiences',
    'experiences.variations',
    'features',
    'features.variables'
];
const DATA_ENTITIES_MAP = {
    goal: 'goals',
    audience: 'audiences',
    location: 'locations',
    segment: 'segments',
    experience: 'experiences',
    variation: 'experiences.variations',
    feature: 'features'
};

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
const ERROR_MESSAGES = {
    SDK_KEY_MISSING: 'SDK key is missing',
    DATA_OBJECT_MISSING: 'Data object is missing',
    CONFIG_DATA_NOT_VALID: 'Config Data is not valid',
    SDK_OR_DATA_OBJECT_REQUIRED: 'SDK key or Data object should be provided',
    RULE_NOT_VALID: 'Provided rule is not valid',
    RULE_DATA_NOT_VALID: 'Provided rule data is not valid',
    RULE_MATCH_TYPE_NOT_SUPPORTED: 'Provided rule matching type "#" is not supported',
    RULE_ERROR: 'Rule error',
    DATA_STORE_NOT_VALID: 'DataStore object is not valid. It should contain get and set methods',
    VISITOR_ID_REQUIRED: 'Visitor string string is not present',
    GOAL_DATA_NOT_VALID: 'GoalData object is not valid',
    UNABLE_TO_SELECT_BUCKET_FOR_VISITOR: 'Unable to bucket visitor',
    UNABLE_TO_PERFORM_NETWORK_REQUEST: 'Unable to perform network request',
    UNSUPPORTED_RESPONSE_TYPE: 'Unsupported response type'
};
const MESSAGES = {
    CONFIG_DATA_UPDATED: 'Config Data updated',
    CORE_CONSTRUCTOR: 'Core Manager constructor has been called',
    CORE_INITIALIZED: 'Core Manager has been initialized',
    EXPERIENCE_CONSTRUCTOR: 'Experience Manager constructor has been called',
    EXPERIENCE_NOT_FOUND: 'Experience not found',
    EXPERIENCE_ARCHIVED: 'Experience archived',
    EXPERIENCE_ENVIRONMENT_NOT_MATCH: 'Experience environment does not match',
    EXPERIENCE_RULES_MATCHED: 'Experience rules matched',
    VARIATIONS_NOT_FOUND: 'Variations not found',
    VARIATION_CHANGE_NOT_SUPPORTED: 'Variation change not supported',
    FEATURE_CONSTRUCTOR: 'Feature Manager constructor has been called',
    FEATURE_NOT_FOUND: 'Fullstack Feature not found',
    FEATURE_VARIABLES_NOT_FOUND: 'Fullstack Feature Variables not found',
    FEATURE_VARIABLES_TYPE_NOT_FOUND: 'Fullstack Feature Variables Type not found',
    BUCKETING_CONSTRUCTOR: 'Bucketing Manager constructor has been called',
    DATA_CONSTRUCTOR: 'Data Manager constructor has been called',
    RULE_CONSTRUCTOR: 'Rule Manager constructor has been called',
    PROCESSING_ENTITY: 'Processing #',
    LOCATION_MATCH: 'Location # rule matched',
    LOCATION_NOT_MATCH: 'Location does not match',
    LOCATION_NOT_RESTRICTED: 'Location not restricted',
    AUDIENCE_MATCH: 'Audience # rule matched',
    AUDIENCE_NOT_MATCH: 'Audience does not match',
    NON_PERMANENT_AUDIENCE_NOT_RESTRICTED: 'Non-Permanent Audience not restricted',
    AUDIENCE_NOT_RESTRICTED: 'Audience not restricted',
    SEGMENTATION_MATCH: 'Segmentation # rule matched',
    SEGMENTATION_NOT_RESTRICTED: 'Segmentation not restricted',
    RULE_NOT_MATCH: 'Rule does not match',
    RULE_MATCH: 'Found matched rule at OR block #',
    RULE_MATCH_AND: 'AND block rule macthed',
    RULE_MATCH_START: 'About to evaluate rule #',
    LOCATION_ACTIVATED: 'Location # activated',
    LOCATION_DEACTIVATED: 'Location # deactivated',
    BUCKETED_VISITOR_FOUND: 'Visitor is already bucketed for variation #',
    BUCKETED_VISITOR_FORCED: 'Forcing variation #',
    BUCKETED_VISITOR: 'Visitor is bucketed for variation #',
    GOAL_NOT_FOUND: 'Goal not found',
    GOAL_RULE_NOT_MATCH: 'Goal rule do not match',
    GOAL_FOUND: 'Goal # already triggered',
    SEGMENTS_NOT_FOUND: 'Segments not found',
    SEGMENTS_RULE_NOT_MATCH: 'Segments rule do not match',
    CUSTOM_SEGMENTS_KEY_FOUND: 'Custom segments key already set',
    SEND_BEACON_SUCCESS: 'The user agent successfully queued the data for transfer',
    RELEASING_QUEUE: 'Releasing event queue...'
};

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var DoNotTrack;
(function (DoNotTrack) {
    DoNotTrack["OFF"] = "OFF";
    DoNotTrack["EU_ONLY"] = "EU ONLY";
    DoNotTrack["EEA_ONLY"] = "EEA ONLY";
    DoNotTrack["WORLDWIDE"] = "Worldwide";
})(DoNotTrack || (DoNotTrack = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var EntityType;
(function (EntityType) {
    EntityType["AUDIENCE"] = "audience";
    EntityType["LOCATION"] = "location";
    EntityType["SEGMENT"] = "segment";
    EntityType["FEATURE"] = "feature";
    EntityType["GOAL"] = "goal";
    EntityType["EXPERIENCE"] = "experience";
    EntityType["VARIATION"] = "variation";
})(EntityType || (EntityType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var FeatureStatus;
(function (FeatureStatus) {
    FeatureStatus["ENABLED"] = "enabled";
    FeatureStatus["DISABLED"] = "disabled";
})(FeatureStatus || (FeatureStatus = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var GoalDataKey;
(function (GoalDataKey) {
    GoalDataKey["AMOUNT"] = "amount";
    GoalDataKey["PRODUCTS_COUNT"] = "productsCount";
    GoalDataKey["TRANSACTION_ID"] = "transactionId";
})(GoalDataKey || (GoalDataKey = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["TRACE"] = 0] = "TRACE";
    LogLevel[LogLevel["DEBUG"] = 1] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
    LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var LogMethod;
(function (LogMethod) {
    LogMethod["LOG"] = "log";
    LogMethod["TRACE"] = "trace";
    LogMethod["DEBUG"] = "debug";
    LogMethod["INFO"] = "info";
    LogMethod["WARN"] = "warn";
    LogMethod["ERROR"] = "error";
})(LogMethod || (LogMethod = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var ProjectType;
(function (ProjectType) {
    ProjectType["WEB"] = "web";
    ProjectType["FULLSTACK"] = "fullstack";
})(ProjectType || (ProjectType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var RuleError;
(function (RuleError) {
    RuleError["NO_DATA_FOUND"] = "convert.com_no_data_found";
    RuleError["NEED_MORE_DATA"] = "convert.com_need_more_data";
})(RuleError || (RuleError = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * SDK system events. Possible values: 'ready' | 'queue-released'
 * or custom visitor's event
 */
var SystemEvents;
(function (SystemEvents) {
    SystemEvents["READY"] = "ready";
    SystemEvents["CONFIG_UPDATED"] = "config.updated";
    SystemEvents["API_QUEUE_RELEASED"] = "api.queue.released";
    SystemEvents["BUCKETING"] = "bucketing";
    SystemEvents["CONVERSION"] = "conversion";
    SystemEvents["SEGMENTS"] = "segments";
    SystemEvents["LOCATION_ACTIVATED"] = "location.activated";
    SystemEvents["LOCATION_DEACTIVATED"] = "location.deactivated";
    SystemEvents["AUDIENCES"] = "audiences";
    SystemEvents["DATA_STORE_QUEUE_RELEASED"] = "datastore.queue.released";
})(SystemEvents || (SystemEvents = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var VariationChangeType;
(function (VariationChangeType) {
    VariationChangeType["RICH_STRUCTURE"] = "richStructure";
    VariationChangeType["CUSTOM_CODE"] = "customCode";
    VariationChangeType["DEFAULT_CODE"] = "defaultCode";
    VariationChangeType["DEFAULT_CODE_MULTIPAGE"] = "defaultCodeMultipage";
    VariationChangeType["DEFAULT_REDIRECT"] = "defaultRedirect";
    VariationChangeType["FULLSTACK_FEATURE"] = "fullStackFeature";
})(VariationChangeType || (VariationChangeType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var BrowserType;
(function (BrowserType) {
    BrowserType["IE"] = "IE";
    BrowserType["CH"] = "CH";
    BrowserType["FF"] = "FF";
    BrowserType["OP"] = "OP";
    BrowserType["SF"] = "SF";
    BrowserType["EDG"] = "EDG";
    BrowserType["MO"] = "MO";
    BrowserType["NS"] = "NS";
    BrowserType["OTH"] = "OTH";
})(BrowserType || (BrowserType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var DeviceType;
(function (DeviceType) {
    DeviceType["ALLPH"] = "ALLPH";
    DeviceType["IPH"] = "IPH";
    DeviceType["OTHPH"] = "OTHPH";
    DeviceType["ALLTAB"] = "ALLTAB";
    DeviceType["IPAD"] = "IPAD";
    DeviceType["OTHTAB"] = "OTHTAB";
    DeviceType["DESK"] = "DESK";
    DeviceType["OTHDEV"] = "OTHDEV";
})(DeviceType || (DeviceType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var SegmentsKeys;
(function (SegmentsKeys) {
    SegmentsKeys["COUNTRY"] = "country";
    SegmentsKeys["BROWSER"] = "browser";
    SegmentsKeys["DEVICES"] = "devices";
    SegmentsKeys["SOURCE"] = "source";
    SegmentsKeys["CAMPAIGN"] = "campaign";
    SegmentsKeys["VISITOR_TYPE"] = "visitorType";
    SegmentsKeys["CUSTOM_SEGMENTS"] = "customSegments";
})(SegmentsKeys || (SegmentsKeys = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var SourceType;
(function (SourceType) {
    SourceType["CAMPAIGN"] = "campaign";
    SourceType["SEARCH"] = "search";
    SourceType["REFERRAL"] = "referral";
    SourceType["DIRECT"] = "direct";
})(SourceType || (SourceType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var VisitorType;
(function (VisitorType) {
    VisitorType["NEW"] = "new";
    VisitorType["RETURNING"] = "returning";
})(VisitorType || (VisitorType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var HttpStatusCode;
(function (HttpStatusCode) {
    HttpStatusCode[HttpStatusCode["Continue"] = 100] = "Continue";
    HttpStatusCode[HttpStatusCode["SwitchingProtocols"] = 101] = "SwitchingProtocols";
    HttpStatusCode[HttpStatusCode["Processing"] = 102] = "Processing";
    HttpStatusCode[HttpStatusCode["EarlyHints"] = 103] = "EarlyHints";
    HttpStatusCode[HttpStatusCode["Ok"] = 200] = "Ok";
    HttpStatusCode[HttpStatusCode["Created"] = 201] = "Created";
    HttpStatusCode[HttpStatusCode["Accepted"] = 202] = "Accepted";
    HttpStatusCode[HttpStatusCode["NonAuthoritativeInformation"] = 203] = "NonAuthoritativeInformation";
    HttpStatusCode[HttpStatusCode["NoContent"] = 204] = "NoContent";
    HttpStatusCode[HttpStatusCode["ResetContent"] = 205] = "ResetContent";
    HttpStatusCode[HttpStatusCode["PartialContent"] = 206] = "PartialContent";
    HttpStatusCode[HttpStatusCode["MultiStatus"] = 207] = "MultiStatus";
    HttpStatusCode[HttpStatusCode["AlreadyReported"] = 208] = "AlreadyReported";
    HttpStatusCode[HttpStatusCode["ImUsed"] = 226] = "ImUsed";
    HttpStatusCode[HttpStatusCode["MultipleChoices"] = 300] = "MultipleChoices";
    HttpStatusCode[HttpStatusCode["MovedPermanently"] = 301] = "MovedPermanently";
    HttpStatusCode[HttpStatusCode["Found"] = 302] = "Found";
    HttpStatusCode[HttpStatusCode["SeeOther"] = 303] = "SeeOther";
    HttpStatusCode[HttpStatusCode["NotModified"] = 304] = "NotModified";
    HttpStatusCode[HttpStatusCode["UseProxy"] = 305] = "UseProxy";
    HttpStatusCode[HttpStatusCode["Unused"] = 306] = "Unused";
    HttpStatusCode[HttpStatusCode["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpStatusCode[HttpStatusCode["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpStatusCode[HttpStatusCode["BadRequest"] = 400] = "BadRequest";
    HttpStatusCode[HttpStatusCode["Unauthorized"] = 401] = "Unauthorized";
    HttpStatusCode[HttpStatusCode["PaymentRequired"] = 402] = "PaymentRequired";
    HttpStatusCode[HttpStatusCode["Forbidden"] = 403] = "Forbidden";
    HttpStatusCode[HttpStatusCode["NotFound"] = 404] = "NotFound";
    HttpStatusCode[HttpStatusCode["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpStatusCode[HttpStatusCode["NotAcceptable"] = 406] = "NotAcceptable";
    HttpStatusCode[HttpStatusCode["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpStatusCode[HttpStatusCode["RequestTimeout"] = 408] = "RequestTimeout";
    HttpStatusCode[HttpStatusCode["Conflict"] = 409] = "Conflict";
    HttpStatusCode[HttpStatusCode["Gone"] = 410] = "Gone";
    HttpStatusCode[HttpStatusCode["LengthRequired"] = 411] = "LengthRequired";
    HttpStatusCode[HttpStatusCode["PreconditionFailed"] = 412] = "PreconditionFailed";
    HttpStatusCode[HttpStatusCode["PayloadTooLarge"] = 413] = "PayloadTooLarge";
    HttpStatusCode[HttpStatusCode["UriTooLong"] = 414] = "UriTooLong";
    HttpStatusCode[HttpStatusCode["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
    HttpStatusCode[HttpStatusCode["RangeNotSatisfiable"] = 416] = "RangeNotSatisfiable";
    HttpStatusCode[HttpStatusCode["ExpectationFailed"] = 417] = "ExpectationFailed";
    HttpStatusCode[HttpStatusCode["ImATeapot"] = 418] = "ImATeapot";
    HttpStatusCode[HttpStatusCode["MisdirectedRequest"] = 421] = "MisdirectedRequest";
    HttpStatusCode[HttpStatusCode["UnprocessableEntity"] = 422] = "UnprocessableEntity";
    HttpStatusCode[HttpStatusCode["Locked"] = 423] = "Locked";
    HttpStatusCode[HttpStatusCode["FailedDependency"] = 424] = "FailedDependency";
    HttpStatusCode[HttpStatusCode["TooEarly"] = 425] = "TooEarly";
    HttpStatusCode[HttpStatusCode["UpgradeRequired"] = 426] = "UpgradeRequired";
    HttpStatusCode[HttpStatusCode["PreconditionRequired"] = 428] = "PreconditionRequired";
    HttpStatusCode[HttpStatusCode["TooManyRequests"] = 429] = "TooManyRequests";
    HttpStatusCode[HttpStatusCode["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
    HttpStatusCode[HttpStatusCode["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
    HttpStatusCode[HttpStatusCode["InternalServerError"] = 500] = "InternalServerError";
    HttpStatusCode[HttpStatusCode["NotImplemented"] = 501] = "NotImplemented";
    HttpStatusCode[HttpStatusCode["BadGateway"] = 502] = "BadGateway";
    HttpStatusCode[HttpStatusCode["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpStatusCode[HttpStatusCode["GatewayTimeout"] = 504] = "GatewayTimeout";
    HttpStatusCode[HttpStatusCode["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
    HttpStatusCode[HttpStatusCode["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
    HttpStatusCode[HttpStatusCode["InsufficientStorage"] = 507] = "InsufficientStorage";
    HttpStatusCode[HttpStatusCode["LoopDetected"] = 508] = "LoopDetected";
    HttpStatusCode[HttpStatusCode["NotExtended"] = 510] = "NotExtended";
    HttpStatusCode[HttpStatusCode["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
})(HttpStatusCode || (HttpStatusCode = {}));

// This file is auto-generated by @hey-api/openapi-ts
/**
 * Type of the Audience. Can be one of the following: `permanent`, `transient`. For full-stack projects, `transient` is the only valid option, the rest will be ignored.
 * * **permanent** - A permanent audience is one that is checked only at the time the user is being bucketed into the experience
 * * **transient** - A transient audience is one that is checked every time the user is being bucketed into the experience
 *
 */
const ConfigAudienceTypes = {
    PERMANENT: 'permanent',
    TRANSIENT: 'transient'
};
/**
 * The way the list is processed. `any` means at least one element in the list is matched.
 * `all` means all elements in the list are matched. Default is any.
 *
 */
const GenericListMatchingOptions = {
    ANY: 'any',
    ALL: 'all'
};
/**
 * Variation status
 */
const VariationStatuses = {
    STOPPED: 'stopped',
    RUNNING: 'running'
};
/**
 * Type of the event. It can be a bucketing or a conversion event
 */
const eventType = {
    BUCKETING: 'bucketing',
    CONVERSION: 'conversion'
};

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
const DEFAULT_BATCH_SIZE = 1;
const DEFAULT_RELEASE_INTERVAL = 5000;
/**
 * Data Store wrapper
 * @category Modules
 * @constructor
 * @implements {DataStoreManagerInterface}
 */
class DataStoreManager {
    /**
     * @param {Config=} config
     * @param {Object=} dependencies
     * @param {Object=} dependencies.dataStore
     * @param {EventManagerInterface=} dependencies.eventManager
     * @param {LogManagerInterface=} dependencies.loggerManager
     */
    constructor(config, { dataStore, eventManager, loggerManager } = {}) {
        var _a, _b;
        this.batchSize = DEFAULT_BATCH_SIZE;
        this.releaseInterval = DEFAULT_RELEASE_INTERVAL;
        this._loggerManager = loggerManager;
        this._eventManager = eventManager;
        this.batchSize = Number((_a = config === null || config === void 0 ? void 0 : config.events) === null || _a === void 0 ? void 0 : _a.batch_size) || DEFAULT_BATCH_SIZE;
        this.releaseInterval =
            Number((_b = config === null || config === void 0 ? void 0 : config.events) === null || _b === void 0 ? void 0 : _b.release_interval) || DEFAULT_RELEASE_INTERVAL;
        this.dataStore = dataStore;
        this._mapper = (config === null || config === void 0 ? void 0 : config.mapper) || ((value) => value);
        this._requestsQueue = {};
    }
    set(key, data) {
        var _a, _b, _c, _d;
        try {
            (_b = (_a = this.dataStore) === null || _a === void 0 ? void 0 : _a.set) === null || _b === void 0 ? void 0 : _b.call(_a, key, data);
        }
        catch (error) {
            (_d = (_c = this._loggerManager) === null || _c === void 0 ? void 0 : _c.error) === null || _d === void 0 ? void 0 : _d.call(_c, 'DataStoreManager.set()', {
                error: error.message
            });
        }
    }
    get(key) {
        var _a, _b, _c, _d;
        try {
            return (_b = (_a = this.dataStore) === null || _a === void 0 ? void 0 : _a.get) === null || _b === void 0 ? void 0 : _b.call(_a, key);
        }
        catch (error) {
            (_d = (_c = this._loggerManager) === null || _c === void 0 ? void 0 : _c.error) === null || _d === void 0 ? void 0 : _d.call(_c, 'DataStoreManager.get()', {
                error: error.message
            });
        }
        return null;
    }
    enqueue(key, data) {
        var _a, _b;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataStoreManager.enqueue()', this._mapper({
            key: key,
            data: data
        }));
        const addData = {};
        addData[key] = data;
        this._requestsQueue = objectDeepMerge(this._requestsQueue, addData);
        if (Object.keys(this._requestsQueue).length >= this.batchSize) {
            this.releaseQueue('size');
        }
        else {
            if (Object.keys(this._requestsQueue).length === 1) {
                this.startQueue();
            }
        }
    }
    releaseQueue(reason) {
        var _a, _b, _c, _d;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.info) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataStoreManager.releaseQueue()', {
            reason: reason || ''
        });
        this.stopQueue();
        for (const key in this._requestsQueue) {
            this.set(key, this._requestsQueue[key]);
        }
        (_d = (_c = this._eventManager) === null || _c === void 0 ? void 0 : _c.fire) === null || _d === void 0 ? void 0 : _d.call(_c, SystemEvents.DATA_STORE_QUEUE_RELEASED, {
            reason: reason || ''
        });
    }
    stopQueue() {
        clearTimeout(this._requestsQueueTimerID);
    }
    startQueue() {
        this._requestsQueueTimerID = setTimeout(() => {
            this.releaseQueue('timeout');
        }, this.releaseInterval);
    }
    /**
     * dataStore setter
     * @param {any=} dataStore
     */
    set dataStore(dataStore) {
        var _a, _b;
        if (dataStore) {
            if (this.isValidDataStore(dataStore)) {
                this._dataStore = dataStore;
            }
            else {
                (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataStoreManager.dataStore.set()', ERROR_MESSAGES.DATA_STORE_NOT_VALID);
            }
        }
    }
    /**
     * dataStore getter
     */
    get dataStore() {
        return this._dataStore;
    }
    /**
     * Validates dataStore object
     * @param {any=} dataStore
     * @return {boolean}
     */
    isValidDataStore(dataStore) {
        return (typeof dataStore === 'object' &&
            typeof dataStore['get'] === 'function' &&
            typeof dataStore['set'] === 'function');
    }
}

const LOCAL_STORE_LIMIT = 10000;
/**
 * Provides logic for data. Stores bucket with help of dataStore if it's provided
 * @category Modules
 * @constructor
 * @implements {DataManagerInterface}
 */
class DataManager {
    /**
     * @param {Config} config
     * @param {Object} dependencies
     * @param {ApiManagerInterface} dependencies.apiManager
     * @param {BucketingManagerInterface} dependencies.bucketingManager
     * @param {RuleManagerInterface} dependencies.ruleManager
     * @param {LogManagerInterface} dependencies.loggerManager
     */
    constructor(config, { bucketingManager, ruleManager, eventManager, apiManager, loggerManager }, { asyncStorage = true } = {}) {
        var _a, _b, _c, _d, _e;
        this._dataEntities = DATA_ENTITIES;
        this._localStoreLimit = LOCAL_STORE_LIMIT;
        this._bucketedVisitors = new Map();
        this._environment = config === null || config === void 0 ? void 0 : config.environment;
        this._apiManager = apiManager;
        this._bucketingManager = bucketingManager;
        this._ruleManager = ruleManager;
        this._loggerManager = loggerManager;
        this._eventManager = eventManager;
        this._config = config;
        this._mapper = (config === null || config === void 0 ? void 0 : config.mapper) || ((value) => value);
        this._asyncStorage = asyncStorage;
        this._data = objectDeepValue(config, 'data');
        this._accountId = (_a = this._data) === null || _a === void 0 ? void 0 : _a.account_id;
        this._projectId = (_c = (_b = this._data) === null || _b === void 0 ? void 0 : _b.project) === null || _c === void 0 ? void 0 : _c.id;
        this.dataStoreManager = config === null || config === void 0 ? void 0 : config.dataStore;
        (_e = (_d = this._loggerManager) === null || _d === void 0 ? void 0 : _d.trace) === null || _e === void 0 ? void 0 : _e.call(_d, 'DataManager()', MESSAGES.DATA_CONSTRUCTOR, this);
    }
    set data(data) {
        var _a, _b, _c;
        if (this.isValidConfigData(data)) {
            this._data = data;
            this._accountId = data === null || data === void 0 ? void 0 : data.account_id;
            this._projectId = (_a = data === null || data === void 0 ? void 0 : data.project) === null || _a === void 0 ? void 0 : _a.id;
        }
        else {
            (_c = (_b = this._loggerManager) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.call(_b, 'DataManager.data.set()', ERROR_MESSAGES.CONFIG_DATA_NOT_VALID);
        }
    }
    /**
     * data getter
     */
    get data() {
        return this._data;
    }
    /**
     * dataStoreManager setter
     * @param {any=} dataStore
     */
    set dataStoreManager(dataStore) {
        this._dataStoreManager = null;
        if (dataStore) {
            this._dataStoreManager = new DataStoreManager(this._config, {
                dataStore: dataStore,
                eventManager: this._eventManager,
                loggerManager: this._loggerManager
            });
        }
    }
    /**
     * dataStoreManager getter
     */
    get dataStoreManager() {
        return this._dataStoreManager;
    }
    /**
     * Set dataStoreManager at run-time
     */
    setDataStore(dataStore) {
        this._dataStoreManager = null;
        if (dataStore) {
            this._dataStoreManager = new DataStoreManager(this._config, {
                dataStore: dataStore,
                eventManager: this._eventManager,
                loggerManager: this._loggerManager
            });
        }
    }
    /**
     * Validate locationProperties against locations rules and visitorProperties against audiences rules
     * @param {string} visitorId
     * @param {string} identity Value of the field which name is provided in identityField
     * @param {IdentityField=} identityField Defaults to 'key'
     * @param {BucketingAttributes} attributes
     * @param {Record<any, any>} attributes.locationProperties
     * @param {Record<any, any>} attributes.visitorProperties
     * @param {string=} attributes.environment
     * @return {ConfigExperience | RuleError}
     */
    matchRulesByField(visitorId, identity, identityField = 'key', attributes) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4;
        const { visitorProperties, locationProperties, ignoreLocationProperties, environment = this._environment } = attributes;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager.matchRulesByField()', this._mapper({
            visitorId: visitorId,
            identity: identity,
            identityField: identityField,
            visitorProperties: visitorProperties,
            locationProperties: locationProperties,
            ignoreLocationProperties: ignoreLocationProperties,
            environment: environment
        }));
        // Retrieve the experience
        const experience = this._getEntityByField(identity, 'experiences', identityField);
        // Check experience
        if (!experience) {
            (_d = (_c = this._loggerManager) === null || _c === void 0 ? void 0 : _c.debug) === null || _d === void 0 ? void 0 : _d.call(_c, 'DataManager.matchRulesByField()', MESSAGES.EXPERIENCE_NOT_FOUND, this._mapper({
                identity: identity,
                identityField: identityField
            }));
            return null;
        }
        // Retrieve archived experiences
        const archivedExperiences = this.getEntitiesList('archived_experiences');
        // Check whether the experience is archived
        const isArchivedExperience = !!archivedExperiences.find((id) => String(experience === null || experience === void 0 ? void 0 : experience.id) === String(id));
        if (isArchivedExperience) {
            (_f = (_e = this._loggerManager) === null || _e === void 0 ? void 0 : _e.debug) === null || _f === void 0 ? void 0 : _f.call(_e, 'DataManager.matchRulesByField()', MESSAGES.EXPERIENCE_ARCHIVED, this._mapper({
                identity: identity,
                identityField: identityField
            }));
            return null;
        }
        // Check environment
        const isEnvironmentMatch = (experience === null || experience === void 0 ? void 0 : experience.environment)
            ? experience.environment === environment
            : true; // skip if no environment
        if (!isEnvironmentMatch) {
            (_h = (_g = this._loggerManager) === null || _g === void 0 ? void 0 : _g.debug) === null || _h === void 0 ? void 0 : _h.call(_g, 'DataManager.matchRulesByField()', MESSAGES.EXPERIENCE_ENVIRONMENT_NOT_MATCH, this._mapper({
                identity: identity,
                identityField: identityField
            }));
            return null;
        }
        let matchedErrors = [];
        // Check that visitor id already bucketed and stored and skip bucketing logic
        const { bucketing } = this.getData(visitorId) || {};
        const { [experience.id.toString()]: variationId } = bucketing || {};
        let isBucketed = false;
        if (variationId &&
            this.retrieveVariation(experience.id, String(variationId))) {
            isBucketed = true;
        }
        // Check location rules against locationProperties
        let locationMatched = ignoreLocationProperties === true;
        if (!locationMatched && locationProperties) {
            if (Array.isArray(experience === null || experience === void 0 ? void 0 : experience.locations) && experience.locations.length) {
                let matchedLocations = [];
                // Get attached locations
                const locations = this.getItemsByIds(experience.locations, 'locations');
                if (locations.length) {
                    // Validate locationProperties against locations rules
                    // and trigger activated/deactivated events
                    matchedLocations = this.selectLocations(visitorId, locations, {
                        locationProperties,
                        identityField
                    });
                    // Return rule errors if present
                    matchedErrors = matchedLocations.filter((match) => Object.values(RuleError).includes(match));
                    if (matchedErrors.length)
                        return matchedErrors[0];
                }
                // If there are some matched locations
                locationMatched = Boolean(matchedLocations.length);
            }
            else if (experience === null || experience === void 0 ? void 0 : experience.site_area) {
                // Validate locationProperties against site area rules
                locationMatched = this._ruleManager.isRuleMatched(locationProperties, experience.site_area, 'SiteArea');
                // Return rule errors if present
                if (Object.values(RuleError).includes(locationMatched))
                    return locationMatched;
            }
            else {
                locationMatched = true; // Empty experience locations list means no restrictions
                (_k = (_j = this._loggerManager) === null || _j === void 0 ? void 0 : _j.info) === null || _k === void 0 ? void 0 : _k.call(_j, 'DataManager.matchRulesByField()', MESSAGES.LOCATION_NOT_RESTRICTED);
            }
        }
        if (!locationMatched) {
            (_m = (_l = this._loggerManager) === null || _l === void 0 ? void 0 : _l.debug) === null || _m === void 0 ? void 0 : _m.call(_l, 'DataManager.matchRulesByField()', MESSAGES.LOCATION_NOT_MATCH, this._mapper({
                locationProperties: locationProperties,
                [(experience === null || experience === void 0 ? void 0 : experience.locations)
                    ? 'experiences[].variations[].locations'
                    : 'experiences[].variations[].site_area']: (experience === null || experience === void 0 ? void 0 : experience.locations) || (experience === null || experience === void 0 ? void 0 : experience.site_area) || ''
            }));
            return null;
        }
        // Check audience rules against visitorProperties
        let audiences = [], segments = [], matchedAudiences = [], matchedSegments = [], audiencesToCheck = [], audiencesMatched = false, segmentsMatched = false;
        if (visitorProperties) {
            if (Array.isArray(experience === null || experience === void 0 ? void 0 : experience.audiences) && experience.audiences.length) {
                // Get attached transient and/or permnent audiences
                audiences = this.getItemsByIds(experience.audiences, 'audiences');
                // If visitor already bucketed into this experience, check only audiences of type transient
                audiencesToCheck = audiences.filter((audience) => !(isBucketed && audience.type === ConfigAudienceTypes.PERMANENT));
                if (audiencesToCheck.length) {
                    // Validate visitorProperties against audiences rules
                    matchedAudiences = this.filterMatchedRecordsWithRule(audiencesToCheck, visitorProperties, 'audience', identityField);
                    // Return rule errors if present
                    matchedErrors = matchedAudiences.filter((match) => Object.values(RuleError).includes(match));
                    if (matchedErrors.length)
                        return matchedErrors[0];
                    if (matchedAudiences.length) {
                        for (const item of matchedAudiences) {
                            (_p = (_o = this._loggerManager) === null || _o === void 0 ? void 0 : _o.info) === null || _p === void 0 ? void 0 : _p.call(_o, 'DataManager.matchRulesByField()', MESSAGES.AUDIENCE_MATCH.replace('#', item === null || item === void 0 ? void 0 : item[identityField]));
                        }
                    }
                    if (experience.settings.matching_options.audiences ===
                        GenericListMatchingOptions.ALL) {
                        audiencesMatched = Boolean(matchedAudiences.length === audiencesToCheck.length);
                    }
                    else {
                        audiencesMatched = Boolean(matchedAudiences.length);
                    }
                }
                else {
                    audiencesMatched = true; // Empty non-permanent experience audiences list means no restrictions
                    (_r = (_q = this._loggerManager) === null || _q === void 0 ? void 0 : _q.info) === null || _r === void 0 ? void 0 : _r.call(_q, 'DataManager.matchRulesByField()', MESSAGES.NON_PERMANENT_AUDIENCE_NOT_RESTRICTED);
                }
            }
            else {
                audiencesMatched = true; // Empty experience audiences list means no restrictions
                (_t = (_s = this._loggerManager) === null || _s === void 0 ? void 0 : _s.info) === null || _t === void 0 ? void 0 : _t.call(_s, 'DataManager.matchRulesByField()', MESSAGES.AUDIENCE_NOT_RESTRICTED);
            }
        }
        // Get attached segmentation audiences
        segments = this.getItemsByIds(experience.audiences, 'segments');
        if (segments.length) {
            // Validate custom segments against segmentations
            matchedSegments = this.filterMatchedCustomSegments(segments, visitorId);
            if (matchedSegments.length) {
                for (const item of matchedSegments) {
                    (_v = (_u = this._loggerManager) === null || _u === void 0 ? void 0 : _u.info) === null || _v === void 0 ? void 0 : _v.call(_u, 'DataManager.matchRulesByField()', MESSAGES.SEGMENTATION_MATCH.replace('#', item === null || item === void 0 ? void 0 : item[identityField]));
                }
            }
            segmentsMatched = Boolean(matchedSegments.length);
        }
        else {
            segmentsMatched = true; // Empty experience segmentation list means no restrictions
            (_x = (_w = this._loggerManager) === null || _w === void 0 ? void 0 : _w.info) === null || _x === void 0 ? void 0 : _x.call(_w, 'DataManager.matchRulesByField()', MESSAGES.SEGMENTATION_NOT_RESTRICTED);
        }
        // If there are some matched audiences
        if (audiencesMatched && segmentsMatched) {
            // And experience has variations
            if ((experience === null || experience === void 0 ? void 0 : experience.variations) && ((_y = experience === null || experience === void 0 ? void 0 : experience.variations) === null || _y === void 0 ? void 0 : _y.length)) {
                (_0 = (_z = this._loggerManager) === null || _z === void 0 ? void 0 : _z.info) === null || _0 === void 0 ? void 0 : _0.call(_z, 'DataManager.matchRulesByField()', MESSAGES.EXPERIENCE_RULES_MATCHED);
                return experience;
            }
            else {
                (_2 = (_1 = this._loggerManager) === null || _1 === void 0 ? void 0 : _1.debug) === null || _2 === void 0 ? void 0 : _2.call(_1, 'DataManager.matchRulesByField()', MESSAGES.VARIATIONS_NOT_FOUND, this._mapper({
                    visitorProperties: visitorProperties,
                    audiences: audiences
                }));
            }
        }
        else {
            (_4 = (_3 = this._loggerManager) === null || _3 === void 0 ? void 0 : _3.debug) === null || _4 === void 0 ? void 0 : _4.call(_3, 'DataManager.matchRulesByField()', MESSAGES.AUDIENCE_NOT_MATCH, this._mapper({
                visitorProperties: visitorProperties,
                audiences: audiences
            }));
        }
        return null;
    }
    /**
     * Retrieve variation for visitor
     * @param {string} visitorId
     * @param {string} identity Value of the field which name is provided in identityField
     * @param {IdentityField=} identityField Defaults to 'key'
     * @param {BucketingAttributes} attributes
     * @param {Record<any, any>} attributes.locationProperties
     * @param {Record<any, any>} attributes.visitorProperties
     * @param {boolean=} attributes.updateVisitorProperties
     * @param {string=} attributes.forceVariationId
     * @param {boolean=} attributes.enableTracking Defaults to `true`
     * @param {boolean=} attributes.asyncStorage Defaults to `true`
     * @param {string=} attributes.environment
     * @return {BucketedVariation | RuleError | BucketingError}
     * @private
     */
    _getBucketingByField(visitorId, identity, identityField = 'key', attributes) {
        var _a, _b;
        const { visitorProperties, locationProperties, updateVisitorProperties, forceVariationId, enableTracking = true, ignoreLocationProperties, environment = this._environment } = attributes;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager._getBucketingByField()', this._mapper({
            visitorId: visitorId,
            identity: identity,
            identityField: identityField,
            visitorProperties: visitorProperties,
            locationProperties: locationProperties,
            forceVariationId: forceVariationId,
            enableTracking: enableTracking,
            ignoreLocationProperties: ignoreLocationProperties,
            environment: environment
        }));
        // Retrieve the experience
        const experience = this.matchRulesByField(visitorId, identity, identityField, {
            visitorProperties,
            locationProperties,
            ignoreLocationProperties,
            environment
        });
        if (experience) {
            if (Object.values(RuleError).includes(experience)) {
                return experience;
            }
            return this._retrieveBucketing(visitorId, visitorProperties, updateVisitorProperties, experience, forceVariationId, enableTracking);
        }
        return null;
    }
    /**
     * Retrieve bucketing for Visitor
     * @param {string} visitorId
     * @param {Record<string, any> | null} visitorProperties
     * @param {boolean} updateVisitorProperties
     * @param {ConfigExperience} experience
     * @param {string=} forceVariationId
     * @param {boolean=} enableTracking Defaults to `true`
     * @return {BucketedVariation | BucketingError}
     * @private
     */
    _retrieveBucketing(visitorId, visitorProperties, updateVisitorProperties, experience, forceVariationId, enableTracking = true) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
        if (!visitorId || !experience)
            return null;
        if (!(experience === null || experience === void 0 ? void 0 : experience.id))
            return null;
        let variation = null, variationId, bucketedVariation = null, bucketingAllocation;
        const storeKey = this.getStoreKey(visitorId);
        if (forceVariationId &&
            (variation = this.retrieveVariation(experience.id, String(forceVariationId)))) {
            variationId = forceVariationId;
            // If it's found log debug info. The return value will be formed next step
            (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.info) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager._retrieveBucketing()', MESSAGES.BUCKETED_VISITOR_FORCED.replace('#', `#${forceVariationId}`));
            (_d = (_c = this._loggerManager) === null || _c === void 0 ? void 0 : _c.debug) === null || _d === void 0 ? void 0 : _d.call(_c, 'DataManager._retrieveBucketing()', this._mapper({
                storeKey: storeKey,
                visitorId: visitorId,
                variationId: forceVariationId
            }));
        }
        // Check that visitor id already bucketed and stored and skip bucketing logic
        const { bucketing, segments } = this.getData(visitorId) || {};
        const { [experience.id.toString()]: storedVariationId } = bucketing || {};
        if (storedVariationId &&
            (!variationId || String(variationId) === String(storedVariationId)) && // variation might be forced but already bucketed before
            (variation = this.retrieveVariation(experience.id, String(storedVariationId)))) {
            variationId = storedVariationId;
            // If it's found log debug info. The return value will be formed next step
            (_f = (_e = this._loggerManager) === null || _e === void 0 ? void 0 : _e.info) === null || _f === void 0 ? void 0 : _f.call(_e, 'DataManager._retrieveBucketing()', MESSAGES.BUCKETED_VISITOR_FOUND.replace('#', `#${variationId}`));
            (_h = (_g = this._loggerManager) === null || _g === void 0 ? void 0 : _g.debug) === null || _h === void 0 ? void 0 : _h.call(_g, 'DataManager._retrieveBucketing()', this._mapper({
                storeKey: storeKey,
                visitorId: visitorId,
                variationId: variationId
            }));
        }
        else {
            // Build buckets where key is variation id and value is traffic distribution
            const buckets = experience.variations
                .filter((variation) => (variation === null || variation === void 0 ? void 0 : variation.status)
                ? variation.status === VariationStatuses.RUNNING
                : true)
                .filter((variation) => (variation === null || variation === void 0 ? void 0 : variation.traffic_allocation) > 0 || // zero-traffic means stopped variation
                isNaN(variation === null || variation === void 0 ? void 0 : variation.traffic_allocation) // no allocation means 100% traffic
            )
                .reduce((bucket, variation) => {
                if (variation === null || variation === void 0 ? void 0 : variation.id)
                    bucket[variation.id] = (variation === null || variation === void 0 ? void 0 : variation.traffic_allocation) || 100.0;
                return bucket;
            }, {});
            // Select bucket based for provided visitor id
            const bucketing = this._bucketingManager.getBucketForVisitor(buckets, visitorId, ((_k = (_j = this._config) === null || _j === void 0 ? void 0 : _j.bucketing) === null || _k === void 0 ? void 0 : _k.excludeExperienceIdHash)
                ? null
                : { experienceId: experience.id.toString() });
            variationId = variationId || (bucketing === null || bucketing === void 0 ? void 0 : bucketing.variationId); // variation might be forced
            bucketingAllocation = bucketing === null || bucketing === void 0 ? void 0 : bucketing.bucketingAllocation;
            // Return bucketing errors if present
            if (!variationId) {
                (_m = (_l = this._loggerManager) === null || _l === void 0 ? void 0 : _l.debug) === null || _m === void 0 ? void 0 : _m.call(_l, 'DataManager._retrieveBucketing()', ERROR_MESSAGES.UNABLE_TO_SELECT_BUCKET_FOR_VISITOR, this._mapper({
                    visitorId: visitorId,
                    experience: experience,
                    buckets: buckets,
                    bucketing: bucketing
                }));
                return BucketingError.VARIAION_NOT_DECIDED;
            }
            (_p = (_o = this._loggerManager) === null || _o === void 0 ? void 0 : _o.info) === null || _p === void 0 ? void 0 : _p.call(_o, 'DataManager._retrieveBucketing()', MESSAGES.BUCKETED_VISITOR.replace('#', `#${variationId}`));
            // Store the data
            if (updateVisitorProperties) {
                this.putData(visitorId, Object.assign({ bucketing: {
                        [experience.id.toString()]: variationId
                    } }, (visitorProperties ? { segments: visitorProperties } : {})));
            }
            else {
                this.putData(visitorId, {
                    bucketing: { [experience.id.toString()]: variationId }
                });
            }
            if (enableTracking) {
                // Enqueue bucketing event to api
                const bucketingEvent = {
                    experienceId: experience.id.toString(),
                    variationId: variationId.toString()
                };
                const visitorEvent = {
                    eventType: eventType.BUCKETING,
                    data: bucketingEvent
                };
                const visitorSegments = this._ruleManager.isUsingCustomInterface(visitorProperties)
                    ? ((_q = visitorProperties === null || visitorProperties === void 0 ? void 0 : visitorProperties.get) === null || _q === void 0 ? void 0 : _q.call(visitorProperties)) || {}
                    : segments;
                this._apiManager.enqueue(visitorId, visitorEvent, visitorSegments);
                (_s = (_r = this._loggerManager) === null || _r === void 0 ? void 0 : _r.trace) === null || _s === void 0 ? void 0 : _s.call(_r, 'DataManager._retrieveBucketing()', this._mapper({
                    visitorEvent
                }));
            }
            // Retrieve and return variation
            variation = this.retrieveVariation(experience.id, String(variationId));
        }
        // Build the response as bucketed variation object
        if (variation) {
            bucketedVariation = Object.assign(Object.assign({
                experienceId: experience === null || experience === void 0 ? void 0 : experience.id,
                experienceName: experience === null || experience === void 0 ? void 0 : experience.name,
                experienceKey: experience === null || experience === void 0 ? void 0 : experience.key
            }, { bucketingAllocation }), variation);
        }
        return bucketedVariation;
    }
    /**
     * @param {string} experienceId
     * @param {string} variationId
     * @return {ExperienceVariationConfig}
     * @private
     */
    retrieveVariation(experienceId, variationId) {
        return this.getSubItem('experiences', experienceId, 'variations', variationId, 'id', 'id');
    }
    reset() {
        this._bucketedVisitors = new Map();
    }
    /**
     * @param {string} visitorId
     * @param {StoreData} newData
     * @private
     */
    putData(visitorId, newData = {}) {
        const storeKey = this.getStoreKey(visitorId);
        const storeData = this.getData(visitorId) || {};
        const isChanged = !objectDeepEqual(storeData, newData);
        if (isChanged) {
            const updatedData = objectDeepMerge(storeData, newData);
            this._bucketedVisitors.set(storeKey, updatedData);
            if (this._bucketedVisitors.size > this._localStoreLimit) {
                // Delete one of the oldest record
                for (const [key] of this._bucketedVisitors) {
                    this._bucketedVisitors.delete(key);
                    break;
                }
            }
            if (this.dataStoreManager) {
                const { segments: storedSegments = {} } = storeData, data = __rest(storeData, ["segments"]);
                const { segments: reportSegments = {} } = this.filterReportSegments(storedSegments);
                const { segments: newSegments } = this.filterReportSegments((newData === null || newData === void 0 ? void 0 : newData.segments) || {});
                if (newSegments) {
                    if (this._asyncStorage) {
                        // Enqueue to store in dataStore
                        this.dataStoreManager.enqueue(storeKey, objectDeepMerge(data, {
                            segments: Object.assign(Object.assign({}, reportSegments), newSegments)
                        }));
                    }
                    else {
                        // Save now to store in dataStore
                        this.dataStoreManager.set(storeKey, objectDeepMerge(data, {
                            segments: Object.assign(Object.assign({}, reportSegments), newSegments)
                        }));
                    }
                }
                else {
                    if (this._asyncStorage) {
                        // Enqueue to store in dataStore
                        this.dataStoreManager.enqueue(storeKey, updatedData);
                    }
                    else {
                        // Save now to store in dataStore
                        this.dataStoreManager.set(storeKey, updatedData);
                    }
                }
            }
        }
    }
    /**
     * @param {string} visitorId
     * @return {StoreData} variation id
     * @private
     */
    getData(visitorId) {
        const storeKey = this.getStoreKey(visitorId);
        const memoryData = this._bucketedVisitors.get(storeKey) || null;
        if (this.dataStoreManager) {
            return objectDeepMerge(memoryData || {}, this.dataStoreManager.get(storeKey) || {});
        }
        return memoryData;
    }
    /**
     * @param {string} visitorId
     * @return {string} storeKey
     * @private
     */
    getStoreKey(visitorId) {
        return `${this._accountId}-${this._projectId}-${visitorId}`;
    }
    /**
     *
     * @param {string} visitorId
     * @param {Array<Record<string, any>>} items
     * @param {Record<string, any>} attributes.locationProperties
     * @param {IdentityField=} attributes.identityField
     * @param {boolean=} attributes.forceEvent
     * @returns {Array<Record<string, any> | RuleError>}
     */
    selectLocations(visitorId, items, attributes) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
        const { locationProperties, identityField = 'key', forceEvent } = attributes;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager.selectLocations()', this._mapper({
            items: items,
            locationProperties: locationProperties
        }));
        // Get locations from DataStore
        const { locations = [] } = this.getData(visitorId) || {};
        const matchedRecords = [];
        let match;
        if (arrayNotEmpty(items)) {
            for (let i = 0, length = items.length; i < length; i++) {
                if (!((_c = items === null || items === void 0 ? void 0 : items[i]) === null || _c === void 0 ? void 0 : _c.rules))
                    continue;
                match = this._ruleManager.isRuleMatched(locationProperties, items[i].rules, `ConfigLocation #${items[i][identityField]}`);
                const identity = (_f = (_e = (_d = items === null || items === void 0 ? void 0 : items[i]) === null || _d === void 0 ? void 0 : _d[identityField]) === null || _e === void 0 ? void 0 : _e.toString) === null || _f === void 0 ? void 0 : _f.call(_e);
                if (match === true) {
                    (_h = (_g = this._loggerManager) === null || _g === void 0 ? void 0 : _g.info) === null || _h === void 0 ? void 0 : _h.call(_g, 'DataManager.selectLocations()', MESSAGES.LOCATION_MATCH.replace('#', `#${identity}`));
                    if (!locations.includes(identity) || forceEvent) {
                        this._eventManager.fire(SystemEvents.LOCATION_ACTIVATED, {
                            visitorId,
                            location: {
                                id: (_j = items === null || items === void 0 ? void 0 : items[i]) === null || _j === void 0 ? void 0 : _j.id,
                                key: (_k = items === null || items === void 0 ? void 0 : items[i]) === null || _k === void 0 ? void 0 : _k.key,
                                name: (_l = items === null || items === void 0 ? void 0 : items[i]) === null || _l === void 0 ? void 0 : _l.name
                            }
                        }, null, true);
                        (_o = (_m = this._loggerManager) === null || _m === void 0 ? void 0 : _m.info) === null || _o === void 0 ? void 0 : _o.call(_m, 'DataManager.selectLocations()', MESSAGES.LOCATION_ACTIVATED.replace('#', `#${identity}`));
                    }
                    if (!locations.includes(identity))
                        locations.push(identity);
                    matchedRecords.push(items[i]);
                }
                else if (match !== false) {
                    // catch rule errors
                    matchedRecords.push(match);
                }
                else if (match === false && locations.includes(identity)) {
                    this._eventManager.fire(SystemEvents.LOCATION_DEACTIVATED, {
                        visitorId,
                        location: {
                            id: (_p = items === null || items === void 0 ? void 0 : items[i]) === null || _p === void 0 ? void 0 : _p.id,
                            key: (_q = items === null || items === void 0 ? void 0 : items[i]) === null || _q === void 0 ? void 0 : _q.key,
                            name: (_r = items === null || items === void 0 ? void 0 : items[i]) === null || _r === void 0 ? void 0 : _r.name
                        }
                    }, null, true);
                    const locationIndex = locations.findIndex((location) => location === identity);
                    locations.splice(locationIndex, 1);
                    (_t = (_s = this._loggerManager) === null || _s === void 0 ? void 0 : _s.info) === null || _t === void 0 ? void 0 : _t.call(_s, 'DataManager.selectLocations()', MESSAGES.LOCATION_DEACTIVATED.replace('#', `#${identity}`));
                }
            }
        }
        // Store the data
        this.putData(visitorId, {
            locations
        });
        (_v = (_u = this._loggerManager) === null || _u === void 0 ? void 0 : _u.debug) === null || _v === void 0 ? void 0 : _v.call(_u, 'DataManager.selectLocations()', this._mapper({
            matchedRecords: matchedRecords
        }));
        return matchedRecords;
    }
    /**
     * Retrieve variation for visitor
     * @param {string} visitorId
     * @param {string} key
     * @param {BucketingAttributes} attributes
     * @param {Record<any, any>} attributes.locationProperties
     * @param {Record<any, any>} attributes.visitorProperties
     * @param {boolean=} attributes.updateVisitorProperties
     * @param {boolean=} attributes.enableTracking
     * @param {string=} attributes.environment
     * @return {BucketedVariation | RuleError}
     */
    getBucketing(visitorId, key, attributes) {
        return this._getBucketingByField(visitorId, key, 'key', attributes);
    }
    /**
     * Retrieve variation for Visitor
     * @param {string} visitorId
     * @param {string} id
     * @param {BucketingAttributes} attributes
     * @param {Record<any, any>} attributes.locationProperties
     * @param {Record<any, any>} attributes.visitorProperties
     * @param {boolean=} attributes.updateVisitorProperties
     * @param {boolean=} attributes.enableTracking
     * @param {string=} attributes.environment
     * @return {BucketedVariation | RuleError}
     */
    getBucketingById(visitorId, id, attributes) {
        return this._getBucketingByField(visitorId, id, 'id', attributes);
    }
    /**
     * Process conversion event
     * @param {string} visitorId
     * @param {string} goalId
     * @param {Record<string, any>=} goalRule An object of key-value pairs that are used for goal matching
     * @param {Array<GoalData>} goalData An array of object of key-value pairs
     * @param {VisitorSegments} segments
     * @param {Record<ConversionSettingKey, number | string | boolean>} conversionSetting An object of key-value pairs that are used for tracking settings
     */
    convert(visitorId, goalId, goalRule, goalData, segments, conversionSetting) {
        var _a, _b, _c, _d, _e, _f;
        const goal = typeof goalId === 'string'
            ? this.getEntity(goalId, 'goals')
            : this.getEntityById(goalId, 'goals');
        if (!(goal === null || goal === void 0 ? void 0 : goal.id)) {
            (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager.convert()', MESSAGES.GOAL_NOT_FOUND);
            return;
        }
        if (goalRule) {
            if (!(goal === null || goal === void 0 ? void 0 : goal.rules))
                return;
            const ruleMatched = this._ruleManager.isRuleMatched(goalRule, goal.rules, `ConfigGoal #${goalId}`);
            // Return rule errors if present
            if (Object.values(RuleError).includes(ruleMatched))
                return ruleMatched;
            if (!ruleMatched) {
                (_d = (_c = this._loggerManager) === null || _c === void 0 ? void 0 : _c.error) === null || _d === void 0 ? void 0 : _d.call(_c, 'DataManager.convert()', MESSAGES.GOAL_RULE_NOT_MATCH);
                return;
            }
        }
        const forceMultipleTransactions = conversionSetting === null || conversionSetting === void 0 ? void 0 : conversionSetting[ConversionSettingKey.FORCE_MULTIPLE_TRANSACTIONS];
        // Check that goal id already triggred and stored and skip tracking conversion event
        const { bucketing: bucketingData, goals: { [goalId.toString()]: goalTriggered } = {} } = this.getData(visitorId) || {};
        if (goalTriggered) {
            (_f = (_e = this._loggerManager) === null || _e === void 0 ? void 0 : _e.debug) === null || _f === void 0 ? void 0 : _f.call(_e, 'DataManager.convert()', MESSAGES.GOAL_FOUND.replace('#', goalId.toString()), this._mapper({
                visitorId: visitorId,
                goalId: goalId
            }));
            if (!forceMultipleTransactions)
                return;
        }
        // Store the data
        this.putData(visitorId, {
            goals: { [goalId.toString()]: true }
        });
        // Send conversion event
        if (!goalTriggered)
            sendConversion.call(this);
        // Send transaction event
        if (goalData && (!goalTriggered || forceMultipleTransactions))
            sendTransaction.call(this);
        function sendConversion() {
            var _a, _b;
            const data = {
                goalId: goal.id
            };
            if (bucketingData)
                data.bucketingData = bucketingData;
            const event = {
                eventType: eventType.CONVERSION,
                data
            };
            this._apiManager.enqueue(visitorId, event, segments);
            (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager.convert()', this._mapper({
                event
            }));
        }
        function sendTransaction() {
            var _a, _b;
            const data = {
                goalId: goal.id,
                goalData
            };
            if (bucketingData)
                data.bucketingData = bucketingData;
            const event = {
                eventType: eventType.CONVERSION,
                data
            };
            this._apiManager.enqueue(visitorId, event, segments);
            (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager.convert()', this._mapper({
                event
            }));
        }
        return true;
    }
    /**
     * Get audiences that meet the visitorProperties
     * @param {Array<Record<any, any>>} items
     * @param {Record<string, any>} visitorProperties
     * @return {Array<Record<string, any> | RuleError>}
     */
    filterMatchedRecordsWithRule(items, visitorProperties, entityType, field = 'id') {
        var _a, _b, _c, _d, _e;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager.filterMatchedRecordsWithRule()', this._mapper({
            items: items,
            visitorProperties: visitorProperties
        }));
        const matchedRecords = [];
        let match;
        if (arrayNotEmpty(items)) {
            for (let i = 0, length = items.length; i < length; i++) {
                if (!((_c = items === null || items === void 0 ? void 0 : items[i]) === null || _c === void 0 ? void 0 : _c.rules))
                    continue;
                match = this._ruleManager.isRuleMatched(visitorProperties, items[i].rules, `${camelCase(entityType)} #${items[i][field]}`);
                if (match === true) {
                    matchedRecords.push(items[i]);
                }
                else if (match !== false) {
                    // catch rule errors
                    matchedRecords.push(match);
                }
            }
        }
        (_e = (_d = this._loggerManager) === null || _d === void 0 ? void 0 : _d.debug) === null || _e === void 0 ? void 0 : _e.call(_d, 'DataManager.filterMatchedRecordsWithRule()', this._mapper({
            matchedRecords: matchedRecords
        }));
        return matchedRecords;
    }
    /**
     * Get audiences that meet the custom segments
     * @param {Array<Record<any, any>>} items
     * @param {string} visitorId
     * @return {Array<Record<string, any>>}
     */
    filterMatchedCustomSegments(items, visitorId) {
        var _a, _b, _c, _d, _e;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager.filterMatchedCustomSegments()', this._mapper({
            items: items,
            visitorId: visitorId
        }));
        // Get custom segments ID from DataStore
        const { segments: { [SegmentsKeys.CUSTOM_SEGMENTS]: customSegments = [] } = {} } = this.getData(visitorId) || {};
        const matchedRecords = [];
        if (arrayNotEmpty(items)) {
            for (let i = 0, length = items.length; i < length; i++) {
                if (!((_c = items === null || items === void 0 ? void 0 : items[i]) === null || _c === void 0 ? void 0 : _c.id))
                    continue;
                if (customSegments.includes(items[i].id)) {
                    matchedRecords.push(items[i]);
                }
            }
        }
        (_e = (_d = this._loggerManager) === null || _d === void 0 ? void 0 : _d.debug) === null || _e === void 0 ? void 0 : _e.call(_d, 'DataManager.filterMatchedCustomSegments()', this._mapper({
            matchedRecords: matchedRecords
        }));
        return matchedRecords;
    }
    /**
     * Extract report segments from other attribues in Visitor properties
     * @param {Record<string, any>=} visitorProperties An object of key-value pairs that are used for audience targeting
     * @return {Record<string, any>}
     */
    filterReportSegments(visitorProperties) {
        const segmentsKeys = Object.values(SegmentsKeys).map((key) => key);
        const segments = {};
        const properties = {};
        for (const key in visitorProperties) {
            if (segmentsKeys.includes(key)) {
                segments[key] = visitorProperties[key];
            }
            else {
                properties[key] = visitorProperties[key];
            }
        }
        return {
            properties: Object.keys(properties).length ? properties : null,
            segments: Object.keys(segments).length ? segments : null
        };
    }
    /**
     * Get list of data entities
     * @param {string} entityType
     * @return {Array<Entity | string>}
     */
    getEntitiesList(entityType) {
        var _a, _b;
        let list = [];
        const mappedEntityType = DATA_ENTITIES_MAP[entityType] || entityType;
        if (this._dataEntities.indexOf(mappedEntityType) !== -1) {
            list = objectDeepValue(this._data, mappedEntityType) || [];
        }
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager.getEntitiesList()', this._mapper({
            entityType: mappedEntityType,
            list: list
        }));
        return list;
    }
    /**
     * Get list of data entities grouped by field
     * @param {string} entityType
     * @param {IdentityField=} field
     * @return {Record<string, Entity>}
     */
    getEntitiesListObject(entityType, field = 'id') {
        return this.getEntitiesList(entityType).reduce((target, entity) => {
            target[entity[field]] = entity;
            return target;
        }, {});
    }
    /**
     *
     * @param {string} identity Value of the field which name is provided in identityField
     * @param {string} entityType
     * @param {IdentityField=} identityField Defaults to 'key'
     * @return {Entity}
     * @private
     */
    _getEntityByField(identity, entityType, identityField = 'key') {
        var _a, _b, _c;
        const mappedEntityType = DATA_ENTITIES_MAP[entityType] || entityType;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager._getEntityByField()', this._mapper({
            identity: identity,
            entityType: mappedEntityType,
            identityField: identityField
        }));
        const list = this.getEntitiesList(mappedEntityType);
        if (arrayNotEmpty(list)) {
            for (let i = 0, length = list.length; i < length; i++) {
                if (list[i] && String((_c = list[i]) === null || _c === void 0 ? void 0 : _c[identityField]) === String(identity)) {
                    return list[i];
                }
            }
        }
        return null;
    }
    /**
     * Find the entity in list by id
     * @param {string} key
     * @param {string} entityType
     * @return {Entity}
     */
    getEntity(key, entityType) {
        return this._getEntityByField(key, entityType, 'key');
    }
    /**
     * Find the entity in list by keys
     * @param {Array<string>} keys
     * @param {string} entityType
     * @return {Array<Entity>}
     */
    getEntities(keys, entityType) {
        return this.getItemsByKeys(keys, entityType);
    }
    /**
     * Find the entity in list by id
     * @param {string} id
     * @param {string} entityType
     * @return {Entity}
     */
    getEntityById(id, entityType) {
        return this._getEntityByField(id, entityType, 'id');
    }
    /**
     * Find the entity in list by ids
     * @param {Array<string>} ids
     * @param {string} entityType
     * @return {Array<Entity>}
     */
    getEntitiesByIds(ids, entityType) {
        return this.getItemsByIds(ids, entityType);
    }
    /**
     * Find the items in list by  keys
     * @param {Array<string>} keys
     * @param {string} path
     * @return {Array<Record<string, any>>}
     */
    getItemsByKeys(keys, path) {
        var _a;
        const list = this.getEntitiesList(path);
        const items = [];
        if (arrayNotEmpty(list)) {
            for (let i = 0, length = list.length; i < length; i++) {
                if (keys.indexOf((_a = list[i]) === null || _a === void 0 ? void 0 : _a.key) !== -1) {
                    items.push(list[i]);
                }
            }
        }
        return items;
    }
    /**
     * Find the items in list by ids
     * @param {Array<string>} ids
     * @param {String} path
     * @return {Array<Record<string, any>>}
     */
    getItemsByIds(ids, path) {
        var _a, _b, _c;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager.getItemsByIds()', this._mapper({
            ids: ids,
            path: path
        }));
        const items = [];
        if (arrayNotEmpty(ids)) {
            const list = this.getEntitiesList(path);
            if (arrayNotEmpty(list)) {
                for (let i = 0, length = list.length; i < length; i++) {
                    if (ids.indexOf((_c = list[i]) === null || _c === void 0 ? void 0 : _c.id) !== -1) {
                        items.push(list[i]);
                    }
                }
            }
        }
        return items;
    }
    /**
     * Find nested item
     * @param {string} entityType
     * @param {string|number} entityIdentity
     * @param {string} subEntityType
     * @param {string|number} subEntityIdentity
     * @param {IdentityField} identityField
     * @param {IdentityField} subIdentityField
     * @return {Record<any, any>}
     */
    getSubItem(entityType, entityIdentity, subEntityType, subEntityIdentity, identityField, subIdentityField) {
        const entity = this._getEntityByField(entityIdentity, entityType, identityField);
        for (const subEntity of entity[subEntityType]) {
            if (subEntity[subIdentityField] === subEntityIdentity) {
                return subEntity;
            }
        }
        return null;
    }
    /**
     * Validates data object
     * @param data
     * @return {boolean}
     */
    isValidConfigData(data) {
        var _a;
        return (objectNotEmpty(data) &&
            ((!!(data === null || data === void 0 ? void 0 : data.account_id) && !!((_a = data === null || data === void 0 ? void 0 : data.project) === null || _a === void 0 ? void 0 : _a.id)) || Boolean(data['error'])));
    }
}

exports.DataManager = DataManager;
exports.DataStoreManager = DataStoreManager;
//# sourceMappingURL=index.js.map
