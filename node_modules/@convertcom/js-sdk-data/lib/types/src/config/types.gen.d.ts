/**
 * Base Audience object
 */
export type ConfigAudience = {
    /**
     * Audience ID
     */
    id?: string;
    /**
     * Audience unique key
     */
    key?: string;
    /**
     * Audience Name
     */
    name?: string;
    type?: ConfigAudienceTypes;
    rules?: RuleObject | null;
};
/**
 * Type of the Audience. Can be one of the following: `permanent`, `transient`. For full-stack projects, `transient` is the only valid option, the rest will be ignored.
 * * **permanent** - A permanent audience is one that is checked only at the time the user is being bucketed into the experience
 * * **transient** - A transient audience is one that is checked every time the user is being bucketed into the experience
 *
 */
export type ConfigAudienceTypes = 'permanent' | 'transient';
/**
 * Type of the Audience. Can be one of the following: `permanent`, `transient`. For full-stack projects, `transient` is the only valid option, the rest will be ignored.
 * * **permanent** - A permanent audience is one that is checked only at the time the user is being bucketed into the experience
 * * **transient** - A transient audience is one that is checked every time the user is being bucketed into the experience
 *
 */
export declare const ConfigAudienceTypes: {
    readonly PERMANENT: "permanent";
    readonly TRANSIENT: "transient";
};
export type PageNumber = {
    /**
     * Describes the page number of the fetched results. "results_per_page" results are gonna be returned for each page
     *
     * Defaults to 1 when not sent
     *
     */
    page?: number;
};
export type Pagination = {
    /**
     * Current page number
     */
    current_page?: number;
    /**
     * Total number of records
     */
    items_count?: number;
    /**
     * Number of records per page
     */
    items_per_page?: number;
    /**
     * Limitation number of records per page
     */
    pages_count?: number;
};
export type ResultsPerPage = {
    /**
     * A value that would be used for setting the number of records that
     * would be returned per page.
     *
     * Defaults to 30 when not sent
     *
     */
    results_per_page?: number | null;
};
export type SortDirection = {
    /**
     * Data sorting direction using "sort_by" field. "asc" for ascending direction, "desc" for descending direction
     *
     * Defaults to **desc** when not sent in a request
     *
     */
    sort_direction?: ('asc' | 'desc') | null;
};
/**
 * Data sorting direction using "sort_by" field. "asc" for ascending direction, "desc" for descending direction
 *
 * Defaults to **desc** when not sent in a request
 *
 */
export type sort_direction = 'asc' | 'desc';
/**
 * Data sorting direction using "sort_by" field. "asc" for ascending direction, "desc" for descending direction
 *
 * Defaults to **desc** when not sent in a request
 *
 */
export declare const sort_direction: {
    readonly ASC: "asc";
    readonly DESC: "desc";
};
export type OnlyCount = {
    /**
     * When provided in requests that allow it, the response would only contain count of records and no real records' data
     *
     */
    onlyCount?: boolean;
};
export type Extra = {
    pagination?: Pagination;
};
export type BaseRule = {
    /**
     * It defines the type of the rule
     */
    rule_type: string;
};
export type BaseRuleWithStringValue = BaseRule & {
    /**
     * The value used to match against 'rule_type' using 'matching'
     */
    value?: string;
};
export type BaseRuleWithJsCodeValue = BaseRule & {
    /**
     * The JS code that would be executed when rule is checked. The return value of this JS code is what is gonna be matched
     * against **true**(or **false** if **matching.negated = true** is provided)
     *
     */
    value?: string;
};
export type BaseRuleWithBooleanValue = BaseRule & {
    /**
     * The value used to match against 'rule_type' using 'matching'
     */
    value?: boolean;
};
export type BaseRuleWithNumericValue = BaseRule & {
    /**
     * The value used to match against 'rule_type' using 'matching'
     */
    value?: number;
};
export type BaseRuleWithCountryCodeValue = BaseRule & {
    /**
     * The 2 letter ISO country code used for matching
     */
    value?: string;
};
export type BaseRuleWithLanguageCodeValue = BaseRule & {
    /**
     * The 2 letter ISO language code used for matching
     */
    value?: string;
};
export type BaseRuleWithGoalTriggeredValue = BaseRule & {
    /**
     * ID of the goal used for matching
     */
    value?: number;
};
export type BaseRuleWithVisitorTypeValue = BaseRule & {
    /**
     * Type of the visitors
     */
    value?: 'new' | 'returning';
};
/**
 * Type of the visitors
 */
export type value = 'new' | 'returning';
/**
 * Type of the visitors
 */
export declare const value: {
    readonly NEW: "new";
    readonly RETURNING: "returning";
};
export type BaseRuleWithExperienceBucketedValue = BaseRule & {
    /**
     * ID of the experience used for matching
     */
    value?: number;
};
export type BaseRuleWithSegmentBucketedValue = BaseRule & {
    /**
     * ID of the segment used for matching
     */
    value?: number;
};
export type BaseRuleWithDayOfWeekValue = BaseRule & {
    /**
     * Day of week used for matching
     */
    value?: number;
};
export type BaseRuleWithHourOfDayValue = BaseRule & {
    /**
     * Hour of day used for matching
     */
    value?: number;
};
export type BaseRuleWithMinuteOfHourValue = BaseRule & {
    /**
     * Minute of hour used for matching
     */
    value?: number;
};
export type BaseRuleWithBrowserNameValue = BaseRule & {
    /**
     * Browser name used for matching
     */
    value?: 'chrome' | 'microsoft_ie' | 'firefox' | 'microsoft_edge' | 'mozilla' | 'opera' | 'safari';
};
/**
 * Browser name used for matching
 */
export type value2 = 'chrome' | 'microsoft_ie' | 'firefox' | 'microsoft_edge' | 'mozilla' | 'opera' | 'safari';
/**
 * Browser name used for matching
 */
export declare const value2: {
    readonly CHROME: "chrome";
    readonly MICROSOFT_IE: "microsoft_ie";
    readonly FIREFOX: "firefox";
    readonly MICROSOFT_EDGE: "microsoft_edge";
    readonly MOZILLA: "mozilla";
    readonly OPERA: "opera";
    readonly SAFARI: "safari";
};
export type BaseRuleWithOsValue = BaseRule & {
    /**
     * Operating System name used for matching
     */
    value?: 'android' | 'iphone' | 'ipod' | 'ipad' | 'windows' | 'macos' | 'linux';
};
/**
 * Operating System name used for matching
 */
export type value3 = 'android' | 'iphone' | 'ipod' | 'ipad' | 'windows' | 'macos' | 'linux';
/**
 * Operating System name used for matching
 */
export declare const value3: {
    readonly ANDROID: "android";
    readonly IPHONE: "iphone";
    readonly IPOD: "ipod";
    readonly IPAD: "ipad";
    readonly WINDOWS: "windows";
    readonly MACOS: "macos";
    readonly LINUX: "linux";
};
export type BaseRuleWithWeatherConditionValue = BaseRule & {
    /**
     * Weather Condition name used for matching. Full or partial condition.
     * The weather provider used by Convert detects the following conditions:
     * - Blizzard
     * - Blowing snow
     * - Cloudy
     * - Fog
     * - Freezing drizzle
     * - Freezing fog
     * - Heavy freezing drizzle
     * - Heavy rain
     * - Heavy rain at times
     * - Light drizzle
     * - Light freezing rain
     * - Light rain
     * - Mist
     * - Moderate rain
     * - Moderate rain at times
     * - Overcast
     * - Partly cloudy
     * - Patchy freezing drizzle possible
     * - Patchy light drizzle
     * - Patchy light rain
     * - Patchy rain possible
     * - Patchy sleet possible
     * - Patchy snow possible
     * - Sunny
     * - Thundery outbreaks possible
     *
     */
    value?: string;
};
/**
 * Weather Conditions
 */
export type WeatherConditions = 'Blizzard' | 'Blowing snow' | 'Cloudy' | 'Fog' | 'Freezing drizzle' | 'Freezing fog' | 'Heavy freezing drizzle' | 'Heavy rain' | 'Heavy rain at times' | 'Light drizzle' | 'Light freezing rain' | 'Light rain' | 'Mist' | 'Moderate rain' | 'Moderate rain at times' | 'Overcast' | 'Partly cloudy' | 'Patchy freezing drizzle possible' | 'Patchy light drizzle' | 'Patchy light rain' | 'Patchy rain possible' | 'Patchy sleet possible' | 'Patchy snow possible' | 'Sunny' | 'Thundery outbreaks possible';
/**
 * Weather Conditions
 */
export declare const WeatherConditions: {
    readonly BLIZZARD: "Blizzard";
    readonly BLOWING_SNOW: "Blowing snow";
    readonly CLOUDY: "Cloudy";
    readonly FOG: "Fog";
    readonly FREEZING_DRIZZLE: "Freezing drizzle";
    readonly FREEZING_FOG: "Freezing fog";
    readonly HEAVY_FREEZING_DRIZZLE: "Heavy freezing drizzle";
    readonly HEAVY_RAIN: "Heavy rain";
    readonly HEAVY_RAIN_AT_TIMES: "Heavy rain at times";
    readonly LIGHT_DRIZZLE: "Light drizzle";
    readonly LIGHT_FREEZING_RAIN: "Light freezing rain";
    readonly LIGHT_RAIN: "Light rain";
    readonly MIST: "Mist";
    readonly MODERATE_RAIN: "Moderate rain";
    readonly MODERATE_RAIN_AT_TIMES: "Moderate rain at times";
    readonly OVERCAST: "Overcast";
    readonly PARTLY_CLOUDY: "Partly cloudy";
    readonly PATCHY_FREEZING_DRIZZLE_POSSIBLE: "Patchy freezing drizzle possible";
    readonly PATCHY_LIGHT_DRIZZLE: "Patchy light drizzle";
    readonly PATCHY_LIGHT_RAIN: "Patchy light rain";
    readonly PATCHY_RAIN_POSSIBLE: "Patchy rain possible";
    readonly PATCHY_SLEET_POSSIBLE: "Patchy sleet possible";
    readonly PATCHY_SNOW_POSSIBLE: "Patchy snow possible";
    readonly SUNNY: "Sunny";
    readonly THUNDERY_OUTBREAKS_POSSIBLE: "Thundery outbreaks possible";
};
export type BaseMatch = {
    /**
     * When true, the rule result is gonna be negated.
     * example: `url contains "test"` with *negated* = true becomes `url does not contain "test"`
     *
     */
    negated?: boolean;
};
export type TextMatchRulesTypes = 'url' | 'url_with_query' | 'query_string' | 'campaign' | 'keyword' | 'medium' | 'source_name' | 'city' | 'region' | 'browser_version' | 'user_agent' | 'page_tag_page_type' | 'page_tag_category_id' | 'page_tag_category_name' | 'page_tag_product_sku' | 'page_tag_product_name' | 'page_tag_customer_id' | 'page_tag_custom_1' | 'page_tag_custom_2' | 'page_tag_custom_3' | 'page_tag_custom_4';
export declare const TextMatchRulesTypes: {
    readonly URL: "url";
    readonly URL_WITH_QUERY: "url_with_query";
    readonly QUERY_STRING: "query_string";
    readonly CAMPAIGN: "campaign";
    readonly KEYWORD: "keyword";
    readonly MEDIUM: "medium";
    readonly SOURCE_NAME: "source_name";
    readonly CITY: "city";
    readonly REGION: "region";
    readonly BROWSER_VERSION: "browser_version";
    readonly USER_AGENT: "user_agent";
    readonly PAGE_TAG_PAGE_TYPE: "page_tag_page_type";
    readonly PAGE_TAG_CATEGORY_ID: "page_tag_category_id";
    readonly PAGE_TAG_CATEGORY_NAME: "page_tag_category_name";
    readonly PAGE_TAG_PRODUCT_SKU: "page_tag_product_sku";
    readonly PAGE_TAG_PRODUCT_NAME: "page_tag_product_name";
    readonly PAGE_TAG_CUSTOMER_ID: "page_tag_customer_id";
    readonly PAGE_TAG_CUSTOM_1: "page_tag_custom_1";
    readonly PAGE_TAG_CUSTOM_2: "page_tag_custom_2";
    readonly PAGE_TAG_CUSTOM_3: "page_tag_custom_3";
    readonly PAGE_TAG_CUSTOM_4: "page_tag_custom_4";
};
export type NumericMatchRulesTypes = 'avg_time_page' | 'days_since_last_visit' | 'pages_visited_count' | 'visit_duration' | 'visits_count' | 'page_tag_product_price';
export declare const NumericMatchRulesTypes: {
    readonly AVG_TIME_PAGE: "avg_time_page";
    readonly DAYS_SINCE_LAST_VISIT: "days_since_last_visit";
    readonly PAGES_VISITED_COUNT: "pages_visited_count";
    readonly VISIT_DURATION: "visit_duration";
    readonly VISITS_COUNT: "visits_count";
    readonly PAGE_TAG_PRODUCT_PRICE: "page_tag_product_price";
};
export type BoolMatchRulesTypes = 'bucketed_into_experience' | 'is_desktop' | 'is_mobile' | 'is_tablet';
export declare const BoolMatchRulesTypes: {
    readonly BUCKETED_INTO_EXPERIENCE: "bucketed_into_experience";
    readonly IS_DESKTOP: "is_desktop";
    readonly IS_MOBILE: "is_mobile";
    readonly IS_TABLET: "is_tablet";
};
export type GenericTextKeyValueMatchRulesTypes = 'generic_text_key_value';
export declare const GenericTextKeyValueMatchRulesTypes: {
    readonly GENERIC_TEXT_KEY_VALUE: "generic_text_key_value";
};
export type GenericNumericKeyValueMatchRulesTypes = 'generic_numeric_key_value';
export declare const GenericNumericKeyValueMatchRulesTypes: {
    readonly GENERIC_NUMERIC_KEY_VALUE: "generic_numeric_key_value";
};
export type GenericBoolKeyValueMatchRulesTypes = 'generic_bool_key_value';
export declare const GenericBoolKeyValueMatchRulesTypes: {
    readonly GENERIC_BOOL_KEY_VALUE: "generic_bool_key_value";
};
export type JsConditionMatchRulesTypes = 'js_condition';
export declare const JsConditionMatchRulesTypes: {
    readonly JS_CONDITION: "js_condition";
};
export type KeyValueMatchRulesTypes = GenericTextKeyValueMatchRulesTypes & GenericNumericKeyValueMatchRulesTypes & GenericBoolKeyValueMatchRulesTypes;
export type CookieMatchRulesTypes = 'cookie';
export declare const CookieMatchRulesTypes: {
    readonly COOKIE: "cookie";
};
export type CountryMatchRulesTypes = 'country';
export declare const CountryMatchRulesTypes: {
    readonly COUNTRY: "country";
};
export type VisitorTypeMatchRulesTypes = 'visitor_type';
export declare const VisitorTypeMatchRulesTypes: {
    readonly VISITOR_TYPE: "visitor_type";
};
export type LanguageMatchRulesTypes = 'language';
export declare const LanguageMatchRulesTypes: {
    readonly LANGUAGE: "language";
};
export type GoalTriggeredMatchRulesTypes = 'goal_triggered';
export declare const GoalTriggeredMatchRulesTypes: {
    readonly GOAL_TRIGGERED: "goal_triggered";
};
export type SegmentBucketedMatchRulesTypes = 'bucketed_into_segment';
export declare const SegmentBucketedMatchRulesTypes: {
    readonly BUCKETED_INTO_SEGMENT: "bucketed_into_segment";
};
export type DayOfWeekMatchRulesTypes = 'local_time_day_of_week' | 'project_time_day_of_week';
export declare const DayOfWeekMatchRulesTypes: {
    readonly LOCAL_TIME_DAY_OF_WEEK: "local_time_day_of_week";
    readonly PROJECT_TIME_DAY_OF_WEEK: "project_time_day_of_week";
};
export type HourOfDayMatchRulesTypes = 'local_time_hour_of_day' | 'project_time_hour_of_day';
export declare const HourOfDayMatchRulesTypes: {
    readonly LOCAL_TIME_HOUR_OF_DAY: "local_time_hour_of_day";
    readonly PROJECT_TIME_HOUR_OF_DAY: "project_time_hour_of_day";
};
export type MinuteOfHourMatchRulesTypes = 'local_time_minute_of_hour' | 'project_time_minute_of_hour';
export declare const MinuteOfHourMatchRulesTypes: {
    readonly LOCAL_TIME_MINUTE_OF_HOUR: "local_time_minute_of_hour";
    readonly PROJECT_TIME_MINUTE_OF_HOUR: "project_time_minute_of_hour";
};
export type BrowserNameMatchRulesTypes = 'browser_name';
export declare const BrowserNameMatchRulesTypes: {
    readonly BROWSER_NAME: "browser_name";
};
export type OsMatchRulesTypes = 'os';
export declare const OsMatchRulesTypes: {
    readonly OS: "os";
};
export type WeatherConditionMatchRulesTypes = 'weather_condition';
export declare const WeatherConditionMatchRulesTypes: {
    readonly WEATHER_CONDITION: "weather_condition";
};
export type RulesTypes = TextMatchRulesTypes & NumericMatchRulesTypes & BoolMatchRulesTypes & KeyValueMatchRulesTypes & CookieMatchRulesTypes & CountryMatchRulesTypes & VisitorTypeMatchRulesTypes & LanguageMatchRulesTypes & GoalTriggeredMatchRulesTypes & SegmentBucketedMatchRulesTypes & DayOfWeekMatchRulesTypes & HourOfDayMatchRulesTypes & MinuteOfHourMatchRulesTypes & BrowserNameMatchRulesTypes & OsMatchRulesTypes & WeatherConditionMatchRulesTypes;
export type GenericTextMatchRule = BaseRuleWithStringValue & {
    rule_type: TextMatchRulesTypes;
    matching?: BaseMatch & {
        match_type?: TextMatchingOptions;
    };
};
export type GenericNumericMatchRule = BaseRuleWithNumericValue & {
    rule_type: NumericMatchRulesTypes;
    matching?: BaseMatch & {
        match_type?: NumericMatchingOptions;
    };
};
export type GenericBoolMatchRule = BaseRuleWithBooleanValue & {
    rule_type: BoolMatchRulesTypes;
    matching?: BaseMatch & {
        match_type?: ChoiceMatchingOptions;
    };
};
export type GenericSetMatchRule = BaseRuleWithStringValue & {
    rule_type: string;
    matching?: BaseMatch & {
        match_type?: SetMatchingOptions;
    };
};
export type GenericKey = {
    /**
     * The key used to identify the data that would be matched against rule **value**
     */
    key?: string;
};
export type GenericTextKeyValueMatchRule = BaseRuleWithStringValue & {
    rule_type: GenericTextKeyValueMatchRulesTypes;
    matching?: BaseMatch & {
        match_type?: TextMatchingOptions;
    };
} & GenericKey;
export type GenericNumericKeyValueMatchRule = BaseRuleWithNumericValue & {
    rule_type: GenericNumericKeyValueMatchRulesTypes;
    matching?: BaseMatch & {
        match_type?: NumericMatchingOptions;
    };
} & GenericKey;
export type GenericBoolKeyValueMatchRule = BaseRuleWithBooleanValue & {
    rule_type: GenericBoolKeyValueMatchRulesTypes;
    matching?: BaseMatch & {
        match_type?: ChoiceMatchingOptions;
    };
} & GenericKey;
export type CookieMatchRule = BaseRuleWithStringValue & {
    rule_type: CookieMatchRulesTypes;
    matching?: BaseMatch & {
        match_type?: TextMatchingOptions;
    };
    /**
     * The name of the cookie which value is compared to the given rule value
     */
    key?: string;
};
export type CountryMatchRule = BaseRuleWithCountryCodeValue & {
    rule_type: CountryMatchRulesTypes;
    matching?: BaseMatch & {
        match_type?: ChoiceMatchingOptions;
    };
};
export type JsConditionMatchRule = BaseRuleWithJsCodeValue & {
    rule_type: JsConditionMatchRulesTypes;
    matching?: BaseMatch & {
        match_type?: ChoiceMatchingOptions;
    };
};
export type VisitorTypeMatchRule = BaseRuleWithVisitorTypeValue & {
    rule_type: VisitorTypeMatchRulesTypes;
    matching?: BaseMatch & {
        match_type?: ChoiceMatchingOptions;
    };
};
export type LanguageMatchRule = BaseRuleWithLanguageCodeValue & {
    rule_type: LanguageMatchRulesTypes;
    matching?: BaseMatch & {
        match_type?: ChoiceMatchingOptions;
    };
};
export type GoalTriggeredMatchRule = BaseRuleWithGoalTriggeredValue & {
    rule_type: GoalTriggeredMatchRulesTypes;
    matching?: BaseMatch & {
        match_type?: ChoiceMatchingOptions;
    };
};
export type SegmentBucketedMatchRule = BaseRuleWithSegmentBucketedValue & {
    rule_type: SegmentBucketedMatchRulesTypes;
    matching?: BaseMatch & {
        match_type?: ChoiceMatchingOptions;
    };
};
export type ExperienceBucketedMatchRule = BaseRuleWithExperienceBucketedValue & {
    rule_type: string;
    matching?: BaseMatch & {
        match_type?: ChoiceMatchingOptions;
    };
};
export type DayOfWeekMatchRule = BaseRuleWithDayOfWeekValue & {
    rule_type: DayOfWeekMatchRulesTypes;
    matching?: BaseMatch & {
        match_type?: NumericMatchingOptions;
    };
};
export type HourOfDayMatchRule = BaseRuleWithHourOfDayValue & {
    rule_type: HourOfDayMatchRulesTypes;
    matching?: BaseMatch & {
        match_type?: NumericMatchingOptions;
    };
};
export type MinuteOfHourMatchRule = BaseRuleWithMinuteOfHourValue & {
    rule_type: MinuteOfHourMatchRulesTypes;
    matching?: BaseMatch & {
        match_type?: NumericMatchingOptions;
    };
};
export type BrowserNameMatchRule = BaseRuleWithBrowserNameValue & {
    rule_type: BrowserNameMatchRulesTypes;
    matching?: BaseMatch & {
        match_type?: ChoiceMatchingOptions;
    };
};
export type OsMatchRule = BaseRuleWithOsValue & {
    rule_type: OsMatchRulesTypes;
    matching?: BaseMatch & {
        match_type?: ChoiceMatchingOptions;
    };
};
export type WeatherConditionMatchRule = BaseRuleWithWeatherConditionValue & {
    rule_type: WeatherConditionMatchRulesTypes;
    matching?: BaseMatch & {
        match_type?: TextMatchingOptions;
    };
};
export type RuleElementNoUrl = GenericTextMatchRule | GenericNumericMatchRule | GenericBoolMatchRule | CookieMatchRule | GenericTextKeyValueMatchRule | GenericNumericKeyValueMatchRule | GenericBoolKeyValueMatchRule | CountryMatchRule | LanguageMatchRule | GoalTriggeredMatchRule | SegmentBucketedMatchRule | DayOfWeekMatchRule | HourOfDayMatchRule | MinuteOfHourMatchRule | BrowserNameMatchRule | OsMatchRule | WeatherConditionMatchRule | VisitorTypeMatchRule | JsConditionMatchRule;
export type RuleElement = GenericTextMatchRule | GenericNumericMatchRule | GenericBoolMatchRule | GenericTextKeyValueMatchRule | GenericNumericKeyValueMatchRule | GenericBoolKeyValueMatchRule | CookieMatchRule | CountryMatchRule | LanguageMatchRule | GoalTriggeredMatchRule | SegmentBucketedMatchRule | DayOfWeekMatchRule | HourOfDayMatchRule | MinuteOfHourMatchRule | BrowserNameMatchRule | OsMatchRule | WeatherConditionMatchRule | VisitorTypeMatchRule | JsConditionMatchRule;
export type TextMatchingOptions = 'matches' | 'regexMatches' | 'contains' | 'endsWith' | 'startsWith';
export declare const TextMatchingOptions: {
    readonly MATCHES: "matches";
    readonly REGEX_MATCHES: "regexMatches";
    readonly CONTAINS: "contains";
    readonly ENDS_WITH: "endsWith";
    readonly STARTS_WITH: "startsWith";
};
export type NumericMatchingOptions = 'equalsNumber' | 'less' | 'lessEqual';
export declare const NumericMatchingOptions: {
    readonly EQUALS_NUMBER: "equalsNumber";
    readonly LESS: "less";
    readonly LESS_EQUAL: "lessEqual";
};
export type ChoiceMatchingOptions = 'equals';
export declare const ChoiceMatchingOptions: {
    readonly EQUALS: "equals";
};
export type ChoiceContainsOptions = 'contains';
export declare const ChoiceContainsOptions: {
    readonly CONTAINS: "contains";
};
export type SetMatchingOptions = 'isIn';
export declare const SetMatchingOptions: {
    readonly IS_IN: "isIn";
};
/**
 * This one describes a logical rule that is being used inside the app for triggering goals, matching audiences etc
 */
export type RuleObject = {
    /**
     * This describes an outer set of blocks which are evaluated using OR's between them
     */
    OR?: Array<{
        /**
         * This describes a colections of logical blocks which are evaluated using AND's between them
         */
        AND?: Array<{
            /**
             * This describes a colections of logical blocks which are evaluated using OR's between them
             */
            OR_WHEN?: Array<RuleElement>;
        }>;
    }>;
} | null;
/**
 * This one describes a logical rule that is being used inside the app for triggering goals, matching audiences etc
 */
export type RuleObjectNoUrl = {
    /**
     * This describes an outer set of blocks which are evaluated using OR's between them
     */
    OR?: Array<{
        /**
         * This describes a colections of logical blocks which are evaluated using AND's between them
         */
        AND?: Array<{
            /**
             * This describes a colections of logical blocks which are evaluated using OR's between them
             */
            OR_WHEN?: Array<RuleElementNoUrl>;
        }>;
    }>;
} | null;
export type Base64Image = {
    /**
     * Image's content, base64 encoded
     */
    data?: string;
};
export type ErrorData = {
    code?: number;
    message?: string;
    fields?: string;
};
export type SuccessData = {
    code?: number;
    message?: string;
};
export type ImportProjectDataSuccess = SuccessData & {
    /**
     * List of imported objects
     */
    imported?: {
        /**
         * List of created experiences. Empty if nothing imported
         */
        experiences?: Array<number>;
        /**
         * List of created audiences. Empty if nothing imported
         */
        audiences?: Array<number>;
        /**
         * List of created locations. Empty if nothing imported
         */
        locations?: Array<number>;
        /**
         * List of created goals. Empty if nothing imported
         */
        goals?: Array<number>;
        /**
         * List of created hypothesis. Empty if nothing imported
         */
        hypothesis?: Array<number>;
    };
};
export type BulkSuccessData = SuccessData & {
    code?: number;
    /**
     * List of unprocessed entities. Would be empty, if all passed entities processed
     */
    errors?: Array<BulkEntityError>;
};
export type BulkEntityError = {
    /**
     * ID of entity which has not been processed
     */
    id?: number;
    /**
     * A reason explaining why entity has not been processed
     */
    message?: string;
};
/**
 * Offset in seconds, from UTC time, for the give timezone
 */
export type UTC_Offset = number;
export type GA_SettingsBase = {
    /**
     * Flag indicating whether Google Analytics integration is enabled or not.
     */
    enabled?: boolean;
};
export type IntegrationGA3 = {
    type?: 'ga3';
    /**
     * Universal Analytics property to be used for tracking
     */
    property_UA?: string | null;
};
export type type = 'ga3';
export declare const type: {
    readonly GA3: "ga3";
};
export type IntegrationGA4Base = {
    type?: 'ga4';
    /**
     * ID of the ga4 property where data will be sent. Used internally for API calls to GoogleAnalytics
     */
    measurementId?: string;
};
export type type2 = 'ga4';
export declare const type2: {
    readonly GA4: "ga4";
};
export type IntegrationGA4 = IntegrationGA4Base & {
    /**
     * ID of the ga4 property where data will be sent. Used internally for API calls to GoogleAnalytics
     */
    propertyId?: string;
};
/**
 * The way the list is processed. `any` means at least one element in the list is matched.
 * `all` means all elements in the list are matched. Default is any.
 *
 */
export type GenericListMatchingOptions = 'any' | 'all';
/**
 * The way the list is processed. `any` means at least one element in the list is matched.
 * `all` means all elements in the list are matched. Default is any.
 *
 */
export declare const GenericListMatchingOptions: {
    readonly ANY: "any";
    readonly ALL: "all";
};
/**
 * Type of the outlier detection mechanism
 */
export type NumericOutlierTypes = 'none' | 'min_max' | 'percentile';
/**
 * Type of the outlier detection mechanism
 */
export declare const NumericOutlierTypes: {
    readonly NONE: "none";
    readonly MIN_MAX: "min_max";
    readonly PERCENTILE: "percentile";
};
export type NumericOutlierBase = {
    detection_type: NumericOutlierTypes;
};
export type NumericOutlierNone = NumericOutlierBase & {
    detection_type?: 'none';
};
export type detection_type = 'none';
export declare const detection_type: {
    readonly NONE: "none";
};
export type NumericOutlierMinMax = NumericOutlierBase & {
    detection_type?: 'min_max';
    /**
     * Minimum value for the outlier detection, under which, the value is considered an outlier
     */
    min?: number;
    /**
     * Maximum value for the outlier detection, over which, the value is considered an outlier
     */
    max?: number;
};
export type detection_type2 = 'min_max';
export declare const detection_type2: {
    readonly MIN_MAX: "min_max";
};
export type NumericOutlierPercentile = NumericOutlierBase & {
    detection_type?: 'percentile';
    min?: unknown & Percentiles;
    max?: unknown & Percentiles;
};
export type detection_type3 = 'percentile';
export declare const detection_type3: {
    readonly PERCENTILE: "percentile";
};
export type NumericOutlier = NumericOutlierNone | NumericOutlierMinMax | NumericOutlierPercentile;
/**
 * List of supported percentiles
 */
export type Percentiles = 1 | 5 | 10 | 25 | 50 | 75 | 90 | 95 | 99;
/**
 * List of supported percentiles
 */
export declare const Percentiles: {
    readonly _1: 1;
    readonly _5: 5;
    readonly _10: 10;
    readonly _25: 25;
    readonly _50: 50;
    readonly _75: 75;
    readonly _90: 90;
    readonly _95: 95;
    readonly _99: 99;
};
/**
 * Response containing project's config data needed in order to serve experiences
 */
export type ConfigResponseData = {
    /**
     * Account ID under which the project exists
     */
    account_id?: string;
    project?: ConfigProject;
    /**
     * List of goals to be tracked in the project
     */
    goals?: Array<ConfigGoal>;
    /**
     * List of locations that are used inside this project
     */
    locations?: Array<ConfigLocation>;
    /**
     * List of audiences that are used inside this project
     */
    audiences?: Array<ConfigAudience>;
    /**
     * List of custom that are devined inside this project
     */
    segments?: Array<ConfigSegment>;
    /**
     * List of active experiences inside this project
     */
    experiences?: Array<ConfigExperience>;
    /**
     * List of archived experiences inside this project, which were archived within the last 8 months
     */
    archived_experiences?: Array<string>;
    /**
     * List of features inside this project. Presented only for fullstack projects
     */
    features?: Array<ConfigFeature>;
    /**
     * Flag indicating if the returned config is in debug mode
     */
    is_debug?: boolean;
};
export type ConfigMinimalResponseData = {
    /**
     * Account ID
     */
    account_id?: string;
    /**
     * Project ID
     */
    project_id?: string;
} & ConfigProjectMinimalSettings;
/**
 * Object that represents the change done inside an experience
 */
export type ExperienceChangeBase = {
    type?: 'richStructure' | 'customCode' | 'defaultCode' | 'defaultCodeMultipage' | 'defaultRedirect' | 'fullStackFeature';
    /**
     * This contains all data of this change, any code, settings etc
     *
     * This is sent by default in the following requests responses: **getExperienceChange**;
     *
     * All other responses that return this field, will only return it if "include" request parameter contains its name
     *
     * Data object structure will correspond to the "type" field
     *
     */
    data?: {
        [key: string]: unknown;
    };
};
export type type3 = 'richStructure' | 'customCode' | 'defaultCode' | 'defaultCodeMultipage' | 'defaultRedirect' | 'fullStackFeature';
export declare const type3: {
    readonly RICH_STRUCTURE: "richStructure";
    readonly CUSTOM_CODE: "customCode";
    readonly DEFAULT_CODE: "defaultCode";
    readonly DEFAULT_CODE_MULTIPAGE: "defaultCodeMultipage";
    readonly DEFAULT_REDIRECT: "defaultRedirect";
    readonly FULL_STACK_FEATURE: "fullStackFeature";
};
/**
 * Object that represents id of the change done inside an experience
 */
export type ExperienceChangeId = {
    /**
     * The ID of the experience change
     */
    id: number;
};
/**
 * Object that represents id of the change done inside an experience
 */
export type ExperienceChangeIdReadOnly = {
    /**
     * The ID of the experience change
     */
    readonly id?: number;
};
/**
 * Object that represents one change done inside an experience
 */
export type ExperienceChange = ExperienceChangeDefaultCodeData | ExperienceChangeDefaultCodeMultipageData | ExperienceChangeDefaultRedirectData | ExperienceChangeCustomCodeData | ExperienceChangeRichStructureData | ExperienceChangeFullStackFeature;
/**
 * Object that represents one change done inside an experience, used when adding changes
 */
export type ExperienceChangeAdd = ExperienceChangeDefaultCodeDataAdd | ExperienceChangeDefaultCodeMultipageDataAdd | ExperienceChangeDefaultRedirectDataAdd | ExperienceChangeCustomCodeDataAdd | ExperienceChangeRichStructureDataAdd | ExperienceChangeFullStackFeatureAdd;
/**
 * Object that represents one change done inside an experience
 */
export type ExperienceChangeUpdate = ExperienceChangeDefaultCodeDataUpdate | ExperienceChangeDefaultCodeMultipageDataUpdate | ExperienceChangeDefaultRedirectDataUpdate | ExperienceChangeRichStructureDataUpdate | ExperienceChangeCustomCodeDataUpdate | ExperienceChangeFullStackFeatureUpdate;
/**
 * Object that represents one change done inside an experience
 */
export type ExperienceChangeUpdateNoId = ExperienceChangeDefaultCodeDataUpdateNoId | ExperienceChangeDefaultCodeMultipageDataUpdateNoId | ExperienceChangeDefaultRedirectDataUpdateNoId | ExperienceChangeRichStructureDataUpdateNoId | ExperienceChangeCustomCodeDataUpdateNoId | ExperienceChangeFullStackFeatureUpdateNoId;
/**
 * Describes structure for "defaultCode" type of experience change
 */
export type ExperienceChangeDefaultCodeDataBase = ExperienceChangeBase & {
    type?: 'defaultCode';
    /**
     * Describes structure for "defaultCode" type of experience change
     */
    data?: {
        /**
         * CSS code to be applied by this change
         */
        css?: string | null;
        /**
         * Javascript code generated by the visual editor or written in the same structure, to be applied by this experience change
         */
        js?: string | null;
        /**
         * Custom javascript code to be applied by this change
         */
        custom_js?: string | null;
    };
};
export type type4 = 'defaultCode';
export declare const type4: {
    readonly DEFAULT_CODE: "defaultCode";
};
/**
 * Describes structure for "defaultCode" type of experience change
 */
export type ExperienceChangeDefaultCodeData = ExperienceChangeIdReadOnly & ExperienceChangeDefaultCodeDataBase;
/**
 * Describes structure for adding a "defaultCode" type of experience change
 */
export type ExperienceChangeDefaultCodeDataAdd = ExperienceChangeIdReadOnly & ExperienceChangeDefaultCodeDataBase & {
    data: unknown;
};
/**
 * Describes structure for "defaultCode" type of experience change
 */
export type ExperienceChangeDefaultCodeDataUpdateNoId = ExperienceChangeDefaultCodeDataBase & unknown;
/**
 * Describes structure for "defaultCode" type of experience change
 */
export type ExperienceChangeDefaultCodeDataUpdate = ExperienceChangeId & ExperienceChangeDefaultCodeDataBase & unknown;
/**
 * Describes structure for "defaultRedirect" type of experience change
 */
export type ExperienceChangeDefaultRedirectDataBase = ExperienceChangeBase & {
    type?: 'defaultRedirect';
    /**
     * Describes structure for "defaultRedirect" type of experience change
     */
    data?: {
        /**
         * Defines whether the URL matching is case sensitive or not
         */
        case_sensitive?: boolean;
        /**
         * Pattern for matching the Original URL in order to construct the redirect URL
         */
        original_pattern?: string;
        /**
         * String used to construct the variation redirect URL. This string can contain matches from original_url or it can be a standard URL
         */
        variation_pattern?: string;
    };
};
export type type5 = 'defaultRedirect';
export declare const type5: {
    readonly DEFAULT_REDIRECT: "defaultRedirect";
};
/**
 * Describes structure for "defaultRedirect" type of experience change
 */
export type ExperienceChangeDefaultRedirectData = ExperienceChangeIdReadOnly & ExperienceChangeDefaultRedirectDataBase;
/**
 * Describes structure for "defaultRedirect" type of experience change
 */
export type ExperienceChangeDefaultRedirectDataAdd = ExperienceChangeIdReadOnly & ExperienceChangeDefaultRedirectDataBase & {
    data: unknown;
};
/**
 * Describes structure for "defaultRedirect" type of experience change
 */
export type ExperienceChangeDefaultRedirectDataUpdateNoId = ExperienceChangeDefaultRedirectDataBase & unknown;
/**
 * Describes structure for "defaultRedirect" type of experience change
 */
export type ExperienceChangeDefaultRedirectDataUpdate = ExperienceChangeId & ExperienceChangeDefaultRedirectDataBase & unknown;
/**
 * Describes structure for "defaultCodeMultipage" type of experience change
 */
export type ExperienceChangeDefaultCodeMultipageDataBase = ExperienceChangeBase & {
    type?: 'defaultCodeMultipage';
    /**
     * Describes structure for "defaultCodeMultipage" type of experience change
     */
    data?: {
        /**
         * CSS code to be applied by this change
         */
        css?: string | null;
        /**
         * Javascript code generated by the visual editor or written in the same structure, to be applied by this experience change
         */
        js?: string | null;
        /**
         * Custom javascript code to be applied by this change
         */
        custom_js?: string | null;
        /**
         * The **id** of the page connected to this change.
         */
        page_id?: string;
    };
};
export type type6 = 'defaultCodeMultipage';
export declare const type6: {
    readonly DEFAULT_CODE_MULTIPAGE: "defaultCodeMultipage";
};
/**
 * Describes structure for "defaultCodeMultipage" type of experience change
 */
export type ExperienceChangeDefaultCodeMultipageData = ExperienceChangeIdReadOnly & ExperienceChangeDefaultCodeMultipageDataBase;
/**
 * Describes structure for "defaultCodeMultipage" type of experience change
 */
export type ExperienceChangeDefaultCodeMultipageDataAdd = ExperienceChangeIdReadOnly & ExperienceChangeDefaultCodeMultipageDataBase & {
    data: unknown;
};
/**
 * Describes structure for "defaultCodeMultipage" type of experience change
 */
export type ExperienceChangeDefaultCodeMultipageDataUpdateNoId = ExperienceChangeDefaultCodeMultipageDataBase & unknown;
/**
 * Describes structure for "defaultCodeMultipage" type of experience change
 */
export type ExperienceChangeDefaultCodeMultipageDataUpdate = ExperienceChangeId & ExperienceChangeDefaultCodeMultipageDataBase & unknown;
/**
 * Describes structure for "defaultCode" type of experience change
 */
export type ExperienceChangeRichStructureDataBase = ExperienceChangeBase & {
    type?: 'richStructure';
    /**
     * Describes structure for "defaultCode" type of experience change
     */
    data?: {
        /**
         * Javascript code generated by the visual editor or written in the same structure, to be applied by this experience change
         */
        js?: string | null;
        /**
         * CSS selector of the element to which the change refers to, if this is a change concerning one DOM element
         */
        selector?: string;
        /**
         * The **id** of the page connected to this change, in case this is a **multi-page** experiment
         */
        page_id?: string;
        /**
         * Various key - value data
         */
        [key: string]: string | undefined;
    };
};
export type type7 = 'richStructure';
export declare const type7: {
    readonly RICH_STRUCTURE: "richStructure";
};
/**
 * Describes structure for "defaultCode" type of experience change
 */
export type ExperienceChangeRichStructureData = ExperienceChangeIdReadOnly & ExperienceChangeRichStructureDataBase;
/**
 * Describes structure for "defaultCode" type of experience change
 */
export type ExperienceChangeRichStructureDataAdd = ExperienceChangeIdReadOnly & ExperienceChangeRichStructureDataBase & {
    data: unknown;
};
/**
 * Describes structure for "defaultCode" type of experience change
 */
export type ExperienceChangeRichStructureDataUpdateNoId = ExperienceChangeRichStructureDataBase & unknown;
/**
 * Describes structure for "defaultCode" type of experience change
 */
export type ExperienceChangeRichStructureDataUpdate = ExperienceChangeId & ExperienceChangeRichStructureDataBase & unknown;
/**
 * Describes structure for "defaultCode" type of experience change
 */
export type ExperienceChangeCustomCodeDataBase = ExperienceChangeBase & {
    type?: 'customCode';
    /**
     * Describes structure for "defaultCode" type of experience change
     */
    data?: {
        /**
         * CSS code to be applied by this change
         */
        css?: string | null;
        /**
         * Custom javascript code to be applied by this change
         */
        js?: string | null;
        /**
         * The **id** of the page connected to this change, in case this is a **multi-page** experiment
         */
        page_id?: string;
    };
};
export type type8 = 'customCode';
export declare const type8: {
    readonly CUSTOM_CODE: "customCode";
};
/**
 * Describes structure for "defaultCode" type of experience change
 */
export type ExperienceChangeCustomCodeData = ExperienceChangeIdReadOnly & ExperienceChangeCustomCodeDataBase;
/**
 * Describes structure for "defaultCode" type of experience change
 */
export type ExperienceChangeCustomCodeDataAdd = ExperienceChangeIdReadOnly & ExperienceChangeCustomCodeDataBase & {
    data: unknown;
};
/**
 * Describes structure for "customCode" type of experience change
 */
export type ExperienceChangeCustomCodeDataUpdateNoId = ExperienceChangeCustomCodeDataBase & unknown;
/**
 * Describes structure for "customCode" type of experience change
 */
export type ExperienceChangeCustomCodeDataUpdate = ExperienceChangeId & ExperienceChangeCustomCodeDataBase & unknown;
/**
 * Describes structure for "fullStackFeature" type of experience change
 */
export type ExperienceChangeFullStackFeatureBase = ExperienceChangeBase & {
    type?: 'fullStackFeature';
    /**
     * Describes structure for "fullStackFeature" type of experience change
     */
    data?: {
        /**
         * The **id** of the feature connected to this change
         */
        feature_id?: number;
        /**
         * A key-value object defined by user which describes the variables values. Where the key is variable name defined in connected feature and value is a variable's value with corresponding type
         */
        variables_data?: {
            [key: string]: unknown;
        };
    };
};
export type type9 = 'fullStackFeature';
export declare const type9: {
    readonly FULL_STACK_FEATURE: "fullStackFeature";
};
/**
 * Describes structure for "fullStackFeature" type of experience change
 */
export type ExperienceChangeFullStackFeature = ExperienceChangeIdReadOnly & ExperienceChangeFullStackFeatureBase;
/**
 * Describes structure for "fullStackFeature" type of experience change
 */
export type ExperienceChangeFullStackFeatureAdd = ExperienceChangeIdReadOnly & ExperienceChangeFullStackFeatureBase & {
    data: unknown;
};
/**
 * Describes structure for "fullStackFeature" type of experience change
 */
export type ExperienceChangeFullStackFeatureUpdate = ExperienceChangeId & ExperienceChangeFullStackFeatureBase & unknown;
/**
 * Describes structure for "fullStackFeature" type of experience change
 */
export type ExperienceChangeFullStackFeatureUpdateNoId = ExperienceChangeFullStackFeatureBase & unknown;
export type UpdateExperienceChangeRequestData = ExperienceChangeAdd;
/**
 * Describes the provider with which Convert integrates to send experience data
 */
export type IntegrationProvider = 'baidu' | 'clicktale' | 'clicky' | 'cnzz' | 'crazyegg' | 'econda' | 'eulerian' | 'google_analytics' | 'gosquared' | 'heapanalytics' | 'hotjar' | 'mixpanel' | 'mouseflow' | 'piwik' | 'segmentio' | 'sitecatalyst' | 'woopra' | 'ysance';
/**
 * Describes the provider with which Convert integrates to send experience data
 */
export declare const IntegrationProvider: {
    readonly BAIDU: "baidu";
    readonly CLICKTALE: "clicktale";
    readonly CLICKY: "clicky";
    readonly CNZZ: "cnzz";
    readonly CRAZYEGG: "crazyegg";
    readonly ECONDA: "econda";
    readonly EULERIAN: "eulerian";
    readonly GOOGLE_ANALYTICS: "google_analytics";
    readonly GOSQUARED: "gosquared";
    readonly HEAPANALYTICS: "heapanalytics";
    readonly HOTJAR: "hotjar";
    readonly MIXPANEL: "mixpanel";
    readonly MOUSEFLOW: "mouseflow";
    readonly PIWIK: "piwik";
    readonly SEGMENTIO: "segmentio";
    readonly SITECATALYST: "sitecatalyst";
    readonly WOOPRA: "woopra";
    readonly YSANCE: "ysance";
};
export type ExperienceIntegrationBase = {
    provider: IntegrationProvider;
    /**
     * Boolean flag indicating whether the integration is enabled or not. When updating experience's integrations,
     * to disable an integration, this flag needs to be passed as **false**. If not passed, integration is assumed to be **enabled=true**
     *
     */
    enabled?: boolean | null;
};
export type ExperienceIntegrationBaidu = ExperienceIntegrationBase & {
    /**
     * Custom dimension where experience data should be sent to.
     */
    custom_dimension: string;
};
export type ExperienceIntegrationClicktale = ExperienceIntegrationBase;
export type ExperienceIntegrationClicky = ExperienceIntegrationBase;
export type ExperienceIntegrationCnzz = ExperienceIntegrationBase & {
    /**
     * Custom dimension where experience data should be sent to.
     */
    custom_dimension: string;
};
/**
 * Crazyegg integration requires API key and secret which are set at the project level and can be
 * updated using updateProject operation
 *
 * **Important:** Not having API key and secret set for the project, would cause integration to fail
 *
 */
export type ExperienceIntegrationCrazyegg = ExperienceIntegrationBase;
export type ExperienceIntegrationEconda = ExperienceIntegrationBase;
export type ExperienceIntegrationEulerian = ExperienceIntegrationBase;
export type ExperienceIntegrationGA3 = GA_SettingsBase & ExperienceIntegrationBase & IntegrationGA3 & {
    /**
     * Custom dimension where experience data should be sent to.
     */
    custom_dimension?: string;
};
export type ExperienceIntegrationGA4Base = GA_SettingsBase & ExperienceIntegrationBase & IntegrationGA4Base;
export type ExperienceIntegrationGA4 = ExperienceIntegrationGA4Base & IntegrationGA4 & {
    /**
     * List of GA audiences created for each of this experience's variations
     */
    audiences?: {
        [key: string]: string;
    };
};
export type ExperienceIntegrationGoogleAnalytics = ExperienceIntegrationGA3 | ExperienceIntegrationGA4;
export type ExperienceIntegrationGosquared = ExperienceIntegrationBase;
export type ExperienceIntegrationHeapanalytics = ExperienceIntegrationBase;
export type ExperienceIntegrationHotjar = ExperienceIntegrationBase;
export type ExperienceIntegrationMixpanel = ExperienceIntegrationBase;
export type ExperienceIntegrationMouseflow = ExperienceIntegrationBase;
export type ExperienceIntegrationPiwik = ExperienceIntegrationBase & {
    /**
     * Custom dimension where experience data should be sent to.
     */
    custom_dimension: string;
};
export type ExperienceIntegrationSegmentio = ExperienceIntegrationBase;
export type ExperienceIntegrationSitecatalyst = ExperienceIntegrationBase & {
    /**
     * Custom dimension where experience data should be sent to.
     */
    evar: string;
};
export type ExperienceIntegrationWoopra = ExperienceIntegrationBase;
export type ExperienceIntegrationYsance = ExperienceIntegrationBase & {
    /**
     * Custom dimension where experience data should be sent to.
     */
    custom_dimension: string;
};
export type ConfigExperience = {
    /**
     * Experience ID
     */
    id?: string;
    /**
     * Experience Name
     */
    name?: string;
    /**
     * Experience readable key that uniquely identifies this experience
     */
    key?: string;
    /**
     * List of locations IDs on which this experience is presented. Either this or **site_area** is given but should not be both.
     */
    locations?: Array<string> | null;
    /**
     * Rules that define where the experience is gonna run. Either this or **locations** is given but should not be both.
     */
    site_area?: RuleObject | null;
    /**
     * List of audiences IDs to which this experience is presented to
     */
    audiences?: Array<string> | null;
    /**
     * List of goals IDs to which will be tracked for this experience
     */
    goals?: Array<string>;
    status?: ExperienceStatuses;
    /**
     * Global Experience's JavaScript that will run for this experience before its changes are applied
     *
     */
    global_js?: string;
    /**
     * Global Experience's StyleSheet that will run for this experience before its changes are applied
     *
     */
    global_css?: string;
    type?: ExperienceTypes;
    /**
     * Experience's version number
     */
    version?: number;
    /**
     * Experience's variations list
     */
    variations?: Array<ExperienceVariationConfig>;
    /**
     * List of integrations that this experience's data is sent to
     */
    integrations?: Array<ExperienceIntegrationBaidu | ExperienceIntegrationClicktale | ExperienceIntegrationClicky | ExperienceIntegrationCnzz | ExperienceIntegrationCrazyegg | ExperienceIntegrationEconda | ExperienceIntegrationEulerian | ExperienceIntegrationGAServing | ExperienceIntegrationGosquared | ExperienceIntegrationHeapanalytics | ExperienceIntegrationHotjar | ExperienceIntegrationMixpanel | ExperienceIntegrationMouseflow | ExperienceIntegrationPiwik | ExperienceIntegrationSegmentio | ExperienceIntegrationSitecatalyst | ExperienceIntegrationWoopra | ExperienceIntegrationYsance>;
    /**
     * List of environments that this experience is supposed to run on. The full list of available environments is defined at
     * project level. If this list is empty, the experience will run on all environments.
     *
     * @deprecated
     */
    environments?: Array<string>;
    /**
     * The environment where this experience will run. It has to be one of the environments defined at the project level
     */
    environment?: string;
    /**
     * Various experience's settings
     */
    settings?: {
        /**
         * Minimum order value for transactions outliers
         * @deprecated
         */
        min_order_value?: number;
        /**
         * Maximum order value for transactions outliers
         * @deprecated
         */
        max_order_value?: number;
        /**
         * Various settings used by the stats engine to detect outliers
         */
        outliers?: {
            /**
             * Order value outlier settings
             */
            order_value?: NumericOutlier;
            /**
             * Products Ordered count outlier settings
             */
            products_ordered_count?: NumericOutlier;
        };
        /**
         * Various settings used for matching the list of Audiences and Locations
         */
        matching_options?: {
            audiences?: GenericListMatchingOptions;
            locations?: GenericListMatchingOptions;
        };
    };
};
/**
 * Variation Object
 */
export type ExperienceVariationConfig = {
    /**
     * Variation ID
     */
    id?: string;
    /**
     * Variation name
     */
    name?: string;
    /**
     * Variation Key
     */
    key?: string;
    /**
     * Percentage of traffic allocation for this variation, as a number from 0 to 10000.
     * For an experience, the sum of the traffic allocations for all variations cannot be greater than 10000.
     *
     */
    traffic_allocation?: number;
    status?: VariationStatuses;
    /**
     * List of changes that this variation is exposing.
     */
    changes?: Array<ExperienceChange>;
};
export type ExperienceStatuses = 'draft' | 'active' | 'paused' | 'completed' | 'scheduled';
export declare const ExperienceStatuses: {
    readonly DRAFT: "draft";
    readonly ACTIVE: "active";
    readonly PAUSED: "paused";
    readonly COMPLETED: "completed";
    readonly SCHEDULED: "scheduled";
};
export type ExperienceTypes = 'a/b' | 'a/a' | 'mvt' | 'split_url' | 'multipage' | 'deploy';
export declare const ExperienceTypes: {
    readonly A_B: "a/b";
    readonly A_A: "a/a";
    readonly MVT: "mvt";
    readonly SPLIT_URL: "split_url";
    readonly MULTIPAGE: "multipage";
    readonly DEPLOY: "deploy";
};
/**
 * Variation status
 */
export type VariationStatuses = 'stopped' | 'running';
/**
 * Variation status
 */
export declare const VariationStatuses: {
    readonly STOPPED: "stopped";
    readonly RUNNING: "running";
};
export type ExperienceIntegrationGAServing = ExperienceIntegrationGA3 | ExperienceIntegrationGA4Base;
/**
 * Base Feature Object
 */
export type ConfigFeature = {
    /**
     * Feature ID
     */
    id?: string;
    /**
     * A name given to the feature to identify it easily
     */
    name?: string;
    /**
     * A unique per project level identifier
     */
    key?: string;
    /**
     * An array of user-defined variables of a feature.
     */
    variables?: Array<FeatureVariableItemData>;
};
/**
 * An object which describes the variable of a feature. Where key is variable name and value is one of the possible types [boolean, float, json, integer, string]
 */
export type FeatureVariableItemData = {
    /**
     * A user-defined variable name
     */
    key?: string;
    /**
     * A variable's type
     */
    type?: 'boolean' | 'float' | 'json' | 'integer' | 'string';
};
/**
 * A variable's type
 */
export type type10 = 'boolean' | 'float' | 'json' | 'integer' | 'string';
/**
 * A variable's type
 */
export declare const type10: {
    readonly BOOLEAN: "boolean";
    readonly FLOAT: "float";
    readonly JSON: "json";
    readonly INTEGER: "integer";
    readonly STRING: "string";
};
/**
 * Goal item to be tracked  inside a project
 */
export type ConfigGoalBase = {
    /**
     * Goal ID
     */
    id?: string;
    /**
     * Goal Name.
     */
    name?: string;
    /**
     * Goal Key
     */
    key?: string;
    /**
     * List of goal types to be returned
     */
    type?: Array<GoalTypes>;
    rules?: RuleObject | null;
};
export type ConfigGoal = DomInteractionGoal | ScrollPercentageGoal | RevenueGoal | NoSettingsGoal | GaGoal | SubmitsFormGoal | ClicksLinkGoal | ClicksElementGoal;
export type DomInteractionGoal = ConfigGoalBase & {
    type?: 'dom_interaction';
    settings?: DomInteractionGoalSettings;
};
export type type11 = 'dom_interaction';
export declare const type11: {
    readonly DOM_INTERACTION: "dom_interaction";
};
export type ScrollPercentageGoal = ConfigGoalBase & {
    type?: 'scroll_percentage';
    settings?: ScrollPercentageGoalSettings;
};
export type type12 = 'scroll_percentage';
export declare const type12: {
    readonly SCROLL_PERCENTAGE: "scroll_percentage";
};
export type RevenueGoal = ConfigGoalBase & {
    type?: 'revenue';
    settings?: RevenueGoalSettings;
};
export type type13 = 'revenue';
export declare const type13: {
    readonly REVENUE: "revenue";
};
export type NoSettingsGoal = ConfigGoalBase & {
    type?: 'advanced' | 'visits_page' | 'code_trigger';
};
export type type14 = 'advanced' | 'visits_page' | 'code_trigger';
export declare const type14: {
    readonly ADVANCED: "advanced";
    readonly VISITS_PAGE: "visits_page";
    readonly CODE_TRIGGER: "code_trigger";
};
export type GaGoal = ConfigGoalBase & {
    type?: 'ga_import';
    settings?: GaGoalSettings;
};
export type type15 = 'ga_import';
export declare const type15: {
    readonly GA_IMPORT: "ga_import";
};
export type SubmitsFormGoal = ConfigGoalBase & {
    type?: 'submits_form';
    settings?: SubmitsFormGoalSettings;
};
export type type16 = 'submits_form';
export declare const type16: {
    readonly SUBMITS_FORM: "submits_form";
};
export type ClicksLinkGoal = ConfigGoalBase & {
    type?: 'clicks_link';
    settings?: ClicksLinkGoalSettings;
};
export type type17 = 'clicks_link';
export declare const type17: {
    readonly CLICKS_LINK: "clicks_link";
};
export type ClicksElementGoal = ConfigGoalBase & {
    type?: 'clicks_element';
    settings?: ClicksElementGoalSettings;
};
export type type18 = 'clicks_element';
export declare const type18: {
    readonly CLICKS_ELEMENT: "clicks_element";
};
export type DomInteractionGoalSettings = {
    /**
     * Array of Events to be tracked by this goal
     */
    tracked_items: Array<{
        /**
         * Css selector that identifies the DOM element(s) on which 'event' is to be monitored in order to fire the goal.
         */
        selector?: string;
        /**
         * The event to monitor in order to fire the goal.
         */
        event?: string;
    }>;
};
export type ScrollPercentageGoalSettings = {
    /**
     * The percentage of scrolling after which the goal will be fired
     */
    percentage: number;
};
export type GaGoalSettings = {
    /**
     * GA4 event name
     */
    ga_event?: string;
};
export type RevenueGoalSettings = {
    /**
     * Type of the revenue goal tracking, one of the below.
     * * "manual" - goal will be triggered through the given revenue tracking code;
     * An empty **triggering_rule** has to be provided as that takes priority over manual triggering
     * * "ga" - Convert will attempt to pick revenue from GA revenue tracking code and attach it to this goal,
     * when on page where this goal is triggered via "triggering_rule"
     *
     */
    triggering_type: 'manual' | 'ga';
};
/**
 * Type of the revenue goal tracking, one of the below.
 * * "manual" - goal will be triggered through the given revenue tracking code;
 * An empty **triggering_rule** has to be provided as that takes priority over manual triggering
 * * "ga" - Convert will attempt to pick revenue from GA revenue tracking code and attach it to this goal,
 * when on page where this goal is triggered via "triggering_rule"
 *
 */
export type triggering_type = 'manual' | 'ga';
/**
 * Type of the revenue goal tracking, one of the below.
 * * "manual" - goal will be triggered through the given revenue tracking code;
 * An empty **triggering_rule** has to be provided as that takes priority over manual triggering
 * * "ga" - Convert will attempt to pick revenue from GA revenue tracking code and attach it to this goal,
 * when on page where this goal is triggered via "triggering_rule"
 *
 */
export declare const triggering_type: {
    readonly MANUAL: "manual";
    readonly GA: "ga";
};
export type SubmitsFormGoalSettings = {
    /**
     * Url representing form's action attribute used to identify forms which will be tracked for submit event.
     */
    action: string;
};
export type ClicksLinkGoalSettings = {
    /**
     * Url representing link's href attribute used to identify links which will be tracked for click event
     */
    href: string;
};
export type ClicksElementGoalSettings = {
    /**
     * Css selector that identifies the DOM element(s) on which will track clicks in order to fire the goal.
     */
    selector: string;
};
/**
 * Goals type, one of below.
 */
export type GoalTypes = 'advanced' | 'dom_interaction' | 'scroll_percentage' | 'code_trigger' | 'revenue';
/**
 * Goals type, one of below.
 */
export declare const GoalTypes: {
    readonly ADVANCED: "advanced";
    readonly DOM_INTERACTION: "dom_interaction";
    readonly SCROLL_PERCENTAGE: "scroll_percentage";
    readonly CODE_TRIGGER: "code_trigger";
    readonly REVENUE: "revenue";
};
/**
 * This one describes a logical triggering rule that is being used inside the app
 */
export type LocationTrigger = LocationTriggerDomElement | LocationTriggerCallback | LocationTriggerManual | LocationTriggerUponRun;
/**
 * Describes possible location trigger types.
 * Note that `upon_run` is always the case for **fullstack** projects.
 *
 */
export type LocationTriggerTypes = 'upon_run' | 'manual' | 'dom_element' | 'callback';
/**
 * Describes possible location trigger types.
 * Note that `upon_run` is always the case for **fullstack** projects.
 *
 */
export declare const LocationTriggerTypes: {
    readonly UPON_RUN: "upon_run";
    readonly MANUAL: "manual";
    readonly DOM_ELEMENT: "dom_element";
    readonly CALLBACK: "callback";
};
export type LocationTriggerBase = {
    type: LocationTriggerTypes;
};
export type LocationTriggerUponRun = LocationTriggerBase & {
    type?: 'upon_run';
};
export type type19 = 'upon_run';
export declare const type19: {
    readonly UPON_RUN: "upon_run";
};
export type LocationTriggerManual = LocationTriggerBase & {
    type?: 'manual';
};
export type type20 = 'manual';
export declare const type20: {
    readonly MANUAL: "manual";
};
/**
 * Allowed events for LocationTriggerDomElement
 */
export type LocationDomTriggerEvents = 'click' | 'hover' | 'in_view' | 'change';
/**
 * Allowed events for LocationTriggerDomElement
 */
export declare const LocationDomTriggerEvents: {
    readonly CLICK: "click";
    readonly HOVER: "hover";
    readonly IN_VIEW: "in_view";
    readonly CHANGE: "change";
};
export type LocationTriggerDomElement = LocationTriggerBase & {
    type?: 'dom_element';
    /**
     * Describes html selector
     */
    selector: string;
    /**
     * Events for LocationTriggerDomElement
     */
    events: Array<LocationDomTriggerEvents>;
};
export type type21 = 'dom_element';
export declare const type21: {
    readonly DOM_ELEMENT: "dom_element";
};
export type LocationTriggerCallback = LocationTriggerBase & {
    type?: 'callback';
    /**
     * Describes the js callback that will be executed in order to fire the experience.
     * It is called with two arguments:
     * - `activate` - a function that should be called when the experience should be activated
     * - `options` - an object with the following properties:
     * - `locationId` - id of the location that is being activated
     * - `isActive` - boolean flag that indicates if the location is active
     *
     * Example:
     * ```
     * function(activate, options) {
     * if (options.isActive) {
     * setTimeout(function() {
     * * it activates the experiences 1 second after the
     * location trigger is initialized - at the load of the tracking script*
     * activate();
     * }, 1000);
     * }
     * }
     * ```
     *
     */
    js: string;
};
export type type22 = 'callback';
export declare const type22: {
    readonly CALLBACK: "callback";
};
/**
 * Base Location object
 */
export type ConfigLocation = {
    /**
     * Location ID
     */
    id?: string;
    /**
     * Location unique key
     */
    key?: string;
    /**
     * Location Name
     */
    name?: string;
    trigger?: LocationTrigger;
    rules?: RuleObject | null;
};
export type ConfigProjectMinimalSettings = {
    /**
     * Whether to include jQuery library or not into the javascript tracking file served by Convert and loaded via the tracking snippet. If jQuery is not included, it has to be loaded on page, before Convert's tracking code
     */
    include_jquery?: boolean;
    /**
     * Whether to include jQuery library or not into the v1 javascript tracking file served by Convert and loaded via the tracking snippet.
     */
    include_jquery_v1?: boolean;
    /**
     * Whether to disable the SPA (Single Page Application) related functionalities from the tracking scripts V1. Most websites work fine without disabling SPA functionality regardless of the fact they are Single Page Apps or not. In edge situation, this setting might prove handy
     */
    disable_spa_functionality?: boolean;
    /**
     * Tracks the project's version, updated with each change done inside the project, which would affect the config of that project. The format is [ISO_datetime]-[incremental_number].
     *
     */
    readonly version?: string | null;
    tracking_script?: TrackingScriptReleaseBase;
};
/**
 * Project Object under which experiences would get created
 */
export type ConfigProject = {
    /**
     * Project ID
     */
    id?: string;
    /**
     * Project Name. If **settings.data_anonymization** is turned on, the name will be generated from **id** field
     */
    name?: string;
    /**
     * Value which describes project product type
     */
    type?: 'fullstack' | 'web';
    utc_offset?: UTC_Offset;
    /**
     * Object representing the custom domain that is used for loading the tracking scripts and
     * sending tracking requests to Convert servers instead of the standard Convert domain
     *
     */
    custom_domain?: {
        /**
         * Custom domain to be used instead of standard Convert's one
         */
        domain?: string;
    } | null;
    /**
     * List of domains allowed to be tracked under this project
     */
    domains?: Array<{
        /**
         * Top level domain, used for setting cookies where applicable
         */
        tld?: string;
        /**
         * List of host names under **tld** which are allowed to be tracked under this project
         */
        hosts?: unknown;
    }>;
    /**
     * The global javascript code that will be loaded on all pages where
     * the tracking script is installed, prior do processing any of
     * experiences, goals, audiences etc.
     *
     */
    global_javascript?: string | null;
    settings?: {
        /**
         * Flag indicating whether decoration of outgoing links (appending tracking cookies inside the link URL in order to
         * make cross domain tracking possible) is done automatically on page
         *
         */
        allow_crossdomain_tracking?: boolean;
        /**
         * Whether or not data is [anonymized](https://convert.zendesk.com/hc/en-us/articles/204506339-Prevent-Experiment-Details-Data-Leak-with-Data-Anonymization).
         */
        data_anonymization?: boolean;
        /**
         * Follow the 'Do not track' browser settings for users in the mentioned area of the world.
         */
        do_not_track?: 'OFF' | 'EU ONLY' | 'EEA ONLY' | 'Worldwide';
        /**
         * Follow Global Privacy Control (GPC) signals for users in the mentioned area of the world.
         * - OFF: Do not follow GPC signals.
         * - EU ONLY: Follow GPC signals for users in the European Union only.
         * - EEA ONLY: Follow GPC signals for users in the European Economic Area only.
         * - Worldwide: Follow GPC signals for users worldwide.
         *
         */
        global_privacy_control?: 'OFF' | 'EU ONLY' | 'EEA ONLY' | 'Worldwide';
        /**
         * When this is turned to true, Convert won't track any referral data like http referral, utm query strings etc. Those will be used on the current page if available but won't be stored in cookies in order to be used on subsequent pages.
         */
        do_not_track_referral?: boolean;
        /**
         * This holds project wide settings used by integrations
         */
        integrations?: {
            google_analytics?: GA_Settings;
            kissmetrics?: {
                /**
                 * Flag indicating whether Kissmetrics integration is enabled or not for this project
                 */
                enabled?: boolean;
            };
        };
        /**
         * Minimum order value for transactions outliers
         * @deprecated
         */
        min_order_value?: number;
        /**
         * Maximum order value for transactions outliers
         * @deprecated
         */
        max_order_value?: number;
        /**
         * Various settings used by the stats engine to detect outliers
         */
        outliers?: {
            /**
             * Order value outlier settings
             */
            order_value?: NumericOutlier;
            /**
             * Products Ordered count outlier settings
             */
            products_ordered_count?: NumericOutlier;
        };
    } & ConfigProjectMinimalSettings;
    /**
     * A user-defined key-value object which describes environments available for the project. The number of environments a user can add depends on their plan, by default only one environment is allowed.
     */
    environments?: {
        [key: string]: {
            /**
             * The display name of the environment.
             */
            label: string;
            /**
             * Specifies whether this environment is set as the default environment for the project.
             */
            is_default: boolean;
        };
    };
};
/**
 * Value which describes project product type
 */
export type type23 = 'fullstack' | 'web';
/**
 * Value which describes project product type
 */
export declare const type23: {
    readonly FULLSTACK: "fullstack";
    readonly WEB: "web";
};
/**
 * Follow the 'Do not track' browser settings for users in the mentioned area of the world.
 */
export type do_not_track = 'OFF' | 'EU ONLY' | 'EEA ONLY' | 'Worldwide';
/**
 * Follow the 'Do not track' browser settings for users in the mentioned area of the world.
 */
export declare const do_not_track: {
    readonly OFF: "OFF";
    readonly EU_ONLY: "EU ONLY";
    readonly EEA_ONLY: "EEA ONLY";
    readonly WORLDWIDE: "Worldwide";
};
/**
 * Follow Global Privacy Control (GPC) signals for users in the mentioned area of the world.
 * - OFF: Do not follow GPC signals.
 * - EU ONLY: Follow GPC signals for users in the European Union only.
 * - EEA ONLY: Follow GPC signals for users in the European Economic Area only.
 * - Worldwide: Follow GPC signals for users worldwide.
 *
 */
export type global_privacy_control = 'OFF' | 'EU ONLY' | 'EEA ONLY' | 'Worldwide';
/**
 * Follow Global Privacy Control (GPC) signals for users in the mentioned area of the world.
 * - OFF: Do not follow GPC signals.
 * - EU ONLY: Follow GPC signals for users in the European Union only.
 * - EEA ONLY: Follow GPC signals for users in the European Economic Area only.
 * - Worldwide: Follow GPC signals for users worldwide.
 *
 */
export declare const global_privacy_control: {
    readonly OFF: "OFF";
    readonly EU_ONLY: "EU ONLY";
    readonly EEA_ONLY: "EEA ONLY";
    readonly WORLDWIDE: "Worldwide";
};
/**
 * Settings to identify which tracking script version will be applied to the project.
 */
export type TrackingScriptReleaseBase = {
    /**
     * Current version of the tracking script bundle
     */
    readonly current_version?: string;
    /**
     * Latest available version of the tracking script bundle.
     */
    readonly latest_version?: string | null;
} | null;
export type ProjectGASettingsBase = GA_SettingsBase & {
    /**
     * Attempt to pull revenue data from Google Analytics Revenue Tracking code.
     */
    auto_revenue_tracking?: boolean;
};
export type ProjectIntegrationGA3 = ProjectGASettingsBase & IntegrationGA3;
export type ProjectIntegrationGA4 = ProjectGASettingsBase & IntegrationGA4Base & {
    /**
     * Boolean indicating whether to wait for the page view event to complete before sending other events.
     */
    no_wait_pageview?: boolean;
};
export type GA_Settings = ProjectIntegrationGA3 | ProjectIntegrationGA4;
/**
 * Base Segment object
 */
export type ConfigSegment = {
    /**
     * Segment ID
     */
    id?: string;
    /**
     * Segment unique key
     */
    key?: string;
    /**
     * Segment Name
     */
    name?: string;
    rules?: RuleObject | null;
};
/**
 * Tracking Request's data
 */
export type SendTrackingEventsRequestData = {
    /**
     * ID of the account under which the project is setup
     */
    accountId?: string;
    /**
     * ID of the project under which the tracking occurs
     */
    projectId?: string;
    /**
     * Flag to determine whether the data is gonna be enriched before the events are stored for reporting.
     * For example, in case of a conversion event, if this flag is on and bucketing is not provided, the bucketing stored on the backend datastore for the given visitor
     * ID would be used. Same applies for segments.
     *
     * *Note*: this flag is only available for some plans
     *
     */
    enrichData?: boolean;
    /**
     * List of visitors tracked. Each visitor can have multiple events.
     *
     */
    visitors?: Array<{
        segments?: VisitorSegments;
        /**
         * Id of the visitor tracked
         */
        visitorId?: string;
        /**
         * List of events fired for the given visitor
         */
        events?: Array<VisitorTrackingEvents>;
    }>;
};
/**
 * Tracking events related to the same user ID
 */
export type VisitorTrackingEvents = {
    /**
     * Type of the event. It can be a bucketing or a conversion event
     */
    eventType?: 'bucketing' | 'conversion';
    data?: BucketingEvent | ConversionEvent;
};
/**
 * Type of the event. It can be a bucketing or a conversion event
 */
export type eventType = 'bucketing' | 'conversion';
/**
 * Type of the event. It can be a bucketing or a conversion event
 */
export declare const eventType: {
    readonly BUCKETING: "bucketing";
    readonly CONVERSION: "conversion";
};
/**
 * Bucketing event data
 */
export type BucketingEvent = {
    /**
     * Experience ID to which the visitor is bucketed. In case that **enrichData=true** flag is being sent, only unique events are gonna be recorded. Otherwise, it's
     * up to the client to ensure that duplicates of the same event for the same visitor do not get sent to the tracking endpoint.
     *
     */
    experienceId: string;
    /**
     * Variation ID corresponding to the experience identified by experienceID, that is assigned to the visitor.
     */
    variationId: string;
};
/**
 * Conversion event data
 */
export type ConversionEvent = {
    /**
     * Id of the conversion goal to be fired
     */
    goalId: string;
    /**
     * Data connected to this conversion, for non binomial metrics, eg revenue
     */
    goalData?: Array<{
        /**
         * Key of the metric
         */
        key?: 'amount' | 'productsCount' | 'transactionId';
        /**
         * Value of the metric
         */
        value?: number | string;
    }>;
    /**
     * Bucketing data (experiences that this visitor is currently part of) for the visitor. In case that **enrichData=true** flag is being sent and
     * this attribute is not provided, the bucketing stored on the backend datastore for the given visitor is gonna be used. If both **enrichData=true** and
     * **bucketingData**, the **bucketingData** is gonna be merged with the stored data inside the backend data source, the request provided data having the
     * biggest overwriting bucketing for the same experience which might exist on the backend
     *
     */
    bucketingData?: {
        [key: string]: string;
    };
};
/**
 * Segments under which this visitor is placed. Some defaults keys are accepted and any other free field **key value** could be used
 * for fullstack projects
 *
 */
export type VisitorSegments = {
    /**
     * Browser used:
     * IE - Internet Explorer
     * CH - Chrome
     * FF - Firefox
     * OP - Opera
     * SF - Safari
     * OTH - Other
     *
     */
    browser?: 'IE' | 'CH' | 'FF' | 'OP' | 'SF' | 'OTH';
    /**
     * List of device classes that the visitor device falls into
     */
    devices?: Array<'ALLPH' | 'IPH' | 'OTHPH' | 'ALLTAB' | 'IPAD' | 'OTHTAB' | 'DESK' | 'OTHDEV'>;
    /**
     * Traffic source
     */
    source?: 'campaign' | 'search' | 'referral' | 'direct';
    /**
     * Campaign string
     */
    campaign?: string;
    /**
     * Type of the visitor
     */
    visitorType?: 'new' | 'returning';
    /**
     * Two ISO country code for visitor's country
     */
    country?: string;
    /**
     * Custom Segments as defined inside Convert app. This will be the list of segments' IDs
     */
    customSegments?: Array<string>;
};
/**
 * Browser used:
 * IE - Internet Explorer
 * CH - Chrome
 * FF - Firefox
 * OP - Opera
 * SF - Safari
 * OTH - Other
 *
 */
export type browser = 'IE' | 'CH' | 'FF' | 'OP' | 'SF' | 'OTH';
/**
 * Browser used:
 * IE - Internet Explorer
 * CH - Chrome
 * FF - Firefox
 * OP - Opera
 * SF - Safari
 * OTH - Other
 *
 */
export declare const browser: {
    readonly IE: "IE";
    readonly CH: "CH";
    readonly FF: "FF";
    readonly OP: "OP";
    readonly SF: "SF";
    readonly OTH: "OTH";
};
/**
 * Traffic source
 */
export type source = 'campaign' | 'search' | 'referral' | 'direct';
/**
 * Traffic source
 */
export declare const source: {
    readonly CAMPAIGN: "campaign";
    readonly SEARCH: "search";
    readonly REFERRAL: "referral";
    readonly DIRECT: "direct";
};
/**
 * Type of the visitor
 */
export type visitorType = 'new' | 'returning';
/**
 * Type of the visitor
 */
export declare const visitorType: {
    readonly NEW: "new";
    readonly RETURNING: "returning";
};
export type GetProjectConfigData = {
    /**
     * ID of the account that owns the retrieved/saved data
     */
    accountId: number;
    /**
     * Filter experiences based on environment.
     */
    environment?: string;
    /**
     * ID of the project to be retrieved
     */
    projectId: number;
};
export type GetProjectConfigResponse = ConfigResponseData;
export type GetProjectConfigBySdkKeyData = {
    /**
     * Filter experiences based on environment.
     */
    environment?: string;
    /**
     * The SDK key used to retrieve the project's config
     */
    sdkKey: string;
};
export type GetProjectConfigBySdkKeyResponse = ConfigResponseData;
export type GetProjectSettingsData = {
    /**
     * ID of the account that owns the retrieved/saved data
     */
    accountId: number;
    /**
     * ID of the project to be retrieved
     */
    projectId: number;
};
export type GetProjectSettingsResponse = ConfigMinimalResponseData;
export type SendTrackingEventsSdkKeyData = {
    /**
     * A JSON object containing the tracking events sent to the Convert tracking servers.
     */
    requestBody: SendTrackingEventsRequestData;
    /**
     * The SDK key used to identify the project where that the data belongs to
     */
    sdkKey: string;
};
export type SendTrackingEventsSdkKeyResponse = SuccessData;
export type SendTrackingEventsData = {
    /**
     * ID of the account that owns the given project
     */
    accountId: number;
    /**
     * ID of the project to which the events belong to
     */
    projectId: number;
    /**
     * A JSON object containing the tracking events sent to the Convert tracking servers.
     */
    requestBody: SendTrackingEventsRequestData;
};
export type SendTrackingEventsResponse = SuccessData;
export type $OpenApiTs = {
    '/config/{account_id}/{project_id}': {
        get: {
            req: GetProjectConfigData;
            res: {
                /**
                 * Object consumed by SDKs
                 *
                 */
                200: ConfigResponseData;
                /**
                 * A response signaling an error
                 */
                default: ErrorData;
            };
        };
    };
    '/config/{sdk_key}': {
        get: {
            req: GetProjectConfigBySdkKeyData;
            res: {
                /**
                 * Object consumed by SDKs
                 *
                 */
                200: ConfigResponseData;
                /**
                 * A response signaling an error
                 */
                default: ErrorData;
            };
        };
    };
    '/project-settings/{account_id}/{project_id}': {
        get: {
            req: GetProjectSettingsData;
            res: {
                /**
                 * Object consumed by SDKs
                 *
                 */
                200: ConfigMinimalResponseData;
                /**
                 * A response signaling an error
                 */
                default: ErrorData;
            };
        };
    };
    '/track/{sdkKey}': {
        post: {
            req: SendTrackingEventsSdkKeyData;
            res: {
                /**
                 * A response signaling a generic success
                 */
                200: SuccessData;
                /**
                 * A response signaling an error
                 */
                default: ErrorData;
            };
        };
    };
    '/track/{account_id}/{project_id}': {
        post: {
            req: SendTrackingEventsData;
            res: {
                /**
                 * A response signaling a generic success
                 */
                200: SuccessData;
                /**
                 * A response signaling an error
                 */
                default: ErrorData;
            };
        };
    };
};
