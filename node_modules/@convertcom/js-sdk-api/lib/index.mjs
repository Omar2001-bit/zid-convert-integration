/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var BucketingError;
(function (BucketingError) {
    BucketingError["VARIAION_NOT_DECIDED"] = "convert.com_variation_not_decided";
})(BucketingError || (BucketingError = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var ConversionSettingKey;
(function (ConversionSettingKey) {
    ConversionSettingKey["FORCE_MULTIPLE_TRANSACTIONS"] = "forceMultipleTransactions";
})(ConversionSettingKey || (ConversionSettingKey = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
const ERROR_MESSAGES = {
    SDK_KEY_MISSING: 'SDK key is missing',
    DATA_OBJECT_MISSING: 'Data object is missing',
    CONFIG_DATA_NOT_VALID: 'Config Data is not valid',
    SDK_OR_DATA_OBJECT_REQUIRED: 'SDK key or Data object should be provided',
    RULE_NOT_VALID: 'Provided rule is not valid',
    RULE_DATA_NOT_VALID: 'Provided rule data is not valid',
    RULE_MATCH_TYPE_NOT_SUPPORTED: 'Provided rule matching type "#" is not supported',
    RULE_ERROR: 'Rule error',
    DATA_STORE_NOT_VALID: 'DataStore object is not valid. It should contain get and set methods',
    VISITOR_ID_REQUIRED: 'Visitor string string is not present',
    GOAL_DATA_NOT_VALID: 'GoalData object is not valid',
    UNABLE_TO_SELECT_BUCKET_FOR_VISITOR: 'Unable to bucket visitor',
    UNABLE_TO_PERFORM_NETWORK_REQUEST: 'Unable to perform network request',
    UNSUPPORTED_RESPONSE_TYPE: 'Unsupported response type'
};
const MESSAGES = {
    CONFIG_DATA_UPDATED: 'Config Data updated',
    CORE_CONSTRUCTOR: 'Core Manager constructor has been called',
    CORE_INITIALIZED: 'Core Manager has been initialized',
    EXPERIENCE_CONSTRUCTOR: 'Experience Manager constructor has been called',
    EXPERIENCE_NOT_FOUND: 'Experience not found',
    EXPERIENCE_ARCHIVED: 'Experience archived',
    EXPERIENCE_ENVIRONMENT_NOT_MATCH: 'Experience environment does not match',
    EXPERIENCE_RULES_MATCHED: 'Experience rules matched',
    VARIATIONS_NOT_FOUND: 'Variations not found',
    VARIATION_CHANGE_NOT_SUPPORTED: 'Variation change not supported',
    FEATURE_CONSTRUCTOR: 'Feature Manager constructor has been called',
    FEATURE_NOT_FOUND: 'Fullstack Feature not found',
    FEATURE_VARIABLES_NOT_FOUND: 'Fullstack Feature Variables not found',
    FEATURE_VARIABLES_TYPE_NOT_FOUND: 'Fullstack Feature Variables Type not found',
    BUCKETING_CONSTRUCTOR: 'Bucketing Manager constructor has been called',
    DATA_CONSTRUCTOR: 'Data Manager constructor has been called',
    RULE_CONSTRUCTOR: 'Rule Manager constructor has been called',
    PROCESSING_ENTITY: 'Processing #',
    LOCATION_MATCH: 'Location # rule matched',
    LOCATION_NOT_MATCH: 'Location does not match',
    LOCATION_NOT_RESTRICTED: 'Location not restricted',
    AUDIENCE_MATCH: 'Audience # rule matched',
    AUDIENCE_NOT_MATCH: 'Audience does not match',
    NON_PERMANENT_AUDIENCE_NOT_RESTRICTED: 'Non-Permanent Audience not restricted',
    AUDIENCE_NOT_RESTRICTED: 'Audience not restricted',
    SEGMENTATION_MATCH: 'Segmentation # rule matched',
    SEGMENTATION_NOT_RESTRICTED: 'Segmentation not restricted',
    RULE_NOT_MATCH: 'Rule does not match',
    RULE_MATCH: 'Found matched rule at OR block #',
    RULE_MATCH_AND: 'AND block rule macthed',
    RULE_MATCH_START: 'About to evaluate rule #',
    LOCATION_ACTIVATED: 'Location # activated',
    LOCATION_DEACTIVATED: 'Location # deactivated',
    BUCKETED_VISITOR_FOUND: 'Visitor is already bucketed for variation #',
    BUCKETED_VISITOR_FORCED: 'Forcing variation #',
    BUCKETED_VISITOR: 'Visitor is bucketed for variation #',
    GOAL_NOT_FOUND: 'Goal not found',
    GOAL_RULE_NOT_MATCH: 'Goal rule do not match',
    GOAL_FOUND: 'Goal # already triggered',
    SEGMENTS_NOT_FOUND: 'Segments not found',
    SEGMENTS_RULE_NOT_MATCH: 'Segments rule do not match',
    CUSTOM_SEGMENTS_KEY_FOUND: 'Custom segments key already set',
    SEND_BEACON_SUCCESS: 'The user agent successfully queued the data for transfer',
    RELEASING_QUEUE: 'Releasing event queue...'
};

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var DoNotTrack;
(function (DoNotTrack) {
    DoNotTrack["OFF"] = "OFF";
    DoNotTrack["EU_ONLY"] = "EU ONLY";
    DoNotTrack["EEA_ONLY"] = "EEA ONLY";
    DoNotTrack["WORLDWIDE"] = "Worldwide";
})(DoNotTrack || (DoNotTrack = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var EntityType;
(function (EntityType) {
    EntityType["AUDIENCE"] = "audience";
    EntityType["LOCATION"] = "location";
    EntityType["SEGMENT"] = "segment";
    EntityType["FEATURE"] = "feature";
    EntityType["GOAL"] = "goal";
    EntityType["EXPERIENCE"] = "experience";
    EntityType["VARIATION"] = "variation";
})(EntityType || (EntityType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var FeatureStatus;
(function (FeatureStatus) {
    FeatureStatus["ENABLED"] = "enabled";
    FeatureStatus["DISABLED"] = "disabled";
})(FeatureStatus || (FeatureStatus = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var GoalDataKey;
(function (GoalDataKey) {
    GoalDataKey["AMOUNT"] = "amount";
    GoalDataKey["PRODUCTS_COUNT"] = "productsCount";
    GoalDataKey["TRANSACTION_ID"] = "transactionId";
})(GoalDataKey || (GoalDataKey = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["TRACE"] = 0] = "TRACE";
    LogLevel[LogLevel["DEBUG"] = 1] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
    LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var LogMethod;
(function (LogMethod) {
    LogMethod["LOG"] = "log";
    LogMethod["TRACE"] = "trace";
    LogMethod["DEBUG"] = "debug";
    LogMethod["INFO"] = "info";
    LogMethod["WARN"] = "warn";
    LogMethod["ERROR"] = "error";
})(LogMethod || (LogMethod = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var ProjectType;
(function (ProjectType) {
    ProjectType["WEB"] = "web";
    ProjectType["FULLSTACK"] = "fullstack";
})(ProjectType || (ProjectType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var RuleError;
(function (RuleError) {
    RuleError["NO_DATA_FOUND"] = "convert.com_no_data_found";
    RuleError["NEED_MORE_DATA"] = "convert.com_need_more_data";
})(RuleError || (RuleError = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * SDK system events. Possible values: 'ready' | 'queue-released'
 * or custom visitor's event
 */
var SystemEvents;
(function (SystemEvents) {
    SystemEvents["READY"] = "ready";
    SystemEvents["CONFIG_UPDATED"] = "config.updated";
    SystemEvents["API_QUEUE_RELEASED"] = "api.queue.released";
    SystemEvents["BUCKETING"] = "bucketing";
    SystemEvents["CONVERSION"] = "conversion";
    SystemEvents["SEGMENTS"] = "segments";
    SystemEvents["LOCATION_ACTIVATED"] = "location.activated";
    SystemEvents["LOCATION_DEACTIVATED"] = "location.deactivated";
    SystemEvents["AUDIENCES"] = "audiences";
    SystemEvents["DATA_STORE_QUEUE_RELEASED"] = "datastore.queue.released";
})(SystemEvents || (SystemEvents = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var VariationChangeType;
(function (VariationChangeType) {
    VariationChangeType["RICH_STRUCTURE"] = "richStructure";
    VariationChangeType["CUSTOM_CODE"] = "customCode";
    VariationChangeType["DEFAULT_CODE"] = "defaultCode";
    VariationChangeType["DEFAULT_CODE_MULTIPAGE"] = "defaultCodeMultipage";
    VariationChangeType["DEFAULT_REDIRECT"] = "defaultRedirect";
    VariationChangeType["FULLSTACK_FEATURE"] = "fullStackFeature";
})(VariationChangeType || (VariationChangeType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var BrowserType;
(function (BrowserType) {
    BrowserType["IE"] = "IE";
    BrowserType["CH"] = "CH";
    BrowserType["FF"] = "FF";
    BrowserType["OP"] = "OP";
    BrowserType["SF"] = "SF";
    BrowserType["EDG"] = "EDG";
    BrowserType["MO"] = "MO";
    BrowserType["NS"] = "NS";
    BrowserType["OTH"] = "OTH";
})(BrowserType || (BrowserType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var DeviceType;
(function (DeviceType) {
    DeviceType["ALLPH"] = "ALLPH";
    DeviceType["IPH"] = "IPH";
    DeviceType["OTHPH"] = "OTHPH";
    DeviceType["ALLTAB"] = "ALLTAB";
    DeviceType["IPAD"] = "IPAD";
    DeviceType["OTHTAB"] = "OTHTAB";
    DeviceType["DESK"] = "DESK";
    DeviceType["OTHDEV"] = "OTHDEV";
})(DeviceType || (DeviceType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var SegmentsKeys;
(function (SegmentsKeys) {
    SegmentsKeys["COUNTRY"] = "country";
    SegmentsKeys["BROWSER"] = "browser";
    SegmentsKeys["DEVICES"] = "devices";
    SegmentsKeys["SOURCE"] = "source";
    SegmentsKeys["CAMPAIGN"] = "campaign";
    SegmentsKeys["VISITOR_TYPE"] = "visitorType";
    SegmentsKeys["CUSTOM_SEGMENTS"] = "customSegments";
})(SegmentsKeys || (SegmentsKeys = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var SourceType;
(function (SourceType) {
    SourceType["CAMPAIGN"] = "campaign";
    SourceType["SEARCH"] = "search";
    SourceType["REFERRAL"] = "referral";
    SourceType["DIRECT"] = "direct";
})(SourceType || (SourceType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var VisitorType;
(function (VisitorType) {
    VisitorType["NEW"] = "new";
    VisitorType["RETURNING"] = "returning";
})(VisitorType || (VisitorType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * Returns the value at path of object
 * TODO: get this utility to work with the optional mapper() helper from config
 * @param {Record<string, any>} object
 * @param {string} path
 * @param {any=} defaultValue
 * @param {boolean=} truthy Should Number 0 number and Boolean false be considered as normal value
 * @return {any}
 */
function objectDeepValue(object, path, defaultValue, truthy = false) {
    try {
        if (typeof object === 'object') {
            const v = path.split('.').reduce((a, v) => a[v], object);
            if (v || (truthy && (v === false || v === 0))) {
                return v;
            }
        }
        // eslint-disable-next-line no-empty
    }
    catch (e) { }
    {
        return null;
    }
}
/**
 * Validates variable is object and not empty
 * @param object
 */
function objectNotEmpty(object) {
    return (typeof object === 'object' &&
        object !== null &&
        Object.keys(object).length > 0);
}

var murmurhash = {exports: {}};

(function (module) {
	(function(){

	  const createBuffer = (val) => new TextEncoder().encode(val);

	  /**
	   * JS Implementation of MurmurHash2
	   *
	   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
	   * @see http://github.com/garycourt/murmurhash-js
	   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
	   * @see http://sites.google.com/site/murmurhash/
	   *
	   * @param {Uint8Array | string} str ASCII only
	   * @param {number} seed Positive integer only
	   * @return {number} 32-bit positive integer hash
	   */
	  function MurmurHashV2(str, seed) {
	    if (typeof str === 'string') str = createBuffer(str);
	    let
	      l = str.length,
	      h = seed ^ l,
	      i = 0,
	      k;

	    while (l >= 4) {
	      k =
	        ((str[i] & 0xff)) |
	        ((str[++i] & 0xff) << 8) |
	        ((str[++i] & 0xff) << 16) |
	        ((str[++i] & 0xff) << 24);

	      k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));
	      k ^= k >>> 24;
	      k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));

	    h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)) ^ k;

	      l -= 4;
	      ++i;
	    }

	    switch (l) {
	    case 3: h ^= (str[i + 2] & 0xff) << 16;
	    case 2: h ^= (str[i + 1] & 0xff) << 8;
	    case 1: h ^= (str[i] & 0xff);
	            h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));
	    }

	    h ^= h >>> 13;
	    h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));
	    h ^= h >>> 15;

	    return h >>> 0;
	  }
	  /*
	   * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)
	   *
	   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
	   * @see http://github.com/garycourt/murmurhash-js
	   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
	   * @see http://sites.google.com/site/murmurhash/
	   *
	   * @param {Uint8Array | string} key ASCII only
	   * @param {number} seed Positive integer only
	   * @return {number} 32-bit positive integer hash
	   */
	  function MurmurHashV3(key, seed) {
	    if (typeof key === 'string') key = createBuffer(key);

	    let remainder, bytes, h1, h1b, c1, c2, k1, i;

	    remainder = key.length & 3; // key.length % 4
	    bytes = key.length - remainder;
	    h1 = seed;
	    c1 = 0xcc9e2d51;
	    c2 = 0x1b873593;
	    i = 0;

	    while (i < bytes) {
	        k1 =
	          ((key[i] & 0xff)) |
	          ((key[++i] & 0xff) << 8) |
	          ((key[++i] & 0xff) << 16) |
	          ((key[++i] & 0xff) << 24);
	      ++i;

	      k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
	      k1 = (k1 << 15) | (k1 >>> 17);
	      k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

	      h1 ^= k1;
	          h1 = (h1 << 13) | (h1 >>> 19);
	      h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
	      h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
	    }

	    k1 = 0;

	    switch (remainder) {
	      case 3: k1 ^= (key[i + 2] & 0xff) << 16;
	      case 2: k1 ^= (key[i + 1] & 0xff) << 8;
	      case 1: k1 ^= (key[i] & 0xff);

	      k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
	      k1 = (k1 << 15) | (k1 >>> 17);
	      k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
	      h1 ^= k1;
	    }

	    h1 ^= key.length;

	    h1 ^= h1 >>> 16;
	    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
	    h1 ^= h1 >>> 13;
	    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
	    h1 ^= h1 >>> 16;

	    return h1 >>> 0;
	  }

	  const murmur = MurmurHashV3;
	  murmur.v2 = MurmurHashV2;
	  murmur.v3 = MurmurHashV3;

	  {
	    module.exports = murmur;
	  }
	}()); 
} (murmurhash));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * Check if a value is numeric
 * @param {string | number} value
 * @returns {boolean}
 */
function isNumeric(value) {
    if (typeof value === 'number') {
        return true;
    }
    const number = parseFloat(String(value));
    return Number.isFinite(number) && !isNaN(number);
}
/**
 * Convert a string to a number
 * @param {string | number} value
 * @returns {number}
 */
function toNumber(value) {
    if (typeof value === 'number') {
        return value;
    }
    const parts = String(value).split(',');
    return parseFloat(parts[0] == '0'
        ? String(value).replace(/,/g, '.')
        : String(value).replace(/,/g, ''));
}

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var _a;
/**
 * Comparison Processor. Provides comparison methods for rules validation
 */
class Comparisons {
    static equals(value, testAgainst, negation) {
        if (Array.isArray(value))
            return this._returnNegationCheck(value.indexOf(testAgainst) !== -1, negation);
        if (objectNotEmpty(value))
            return this._returnNegationCheck(Object.keys(value).indexOf(String(testAgainst)) !== -1, negation);
        value = String(value);
        testAgainst = String(testAgainst);
        value = value.valueOf().toLowerCase();
        testAgainst = testAgainst.valueOf().toLowerCase();
        return this._returnNegationCheck(value === testAgainst, negation);
    }
    static less(value, testAgainst, negation) {
        value = isNumeric(value) ? toNumber(value) : value;
        testAgainst = isNumeric(testAgainst) ? toNumber(testAgainst) : testAgainst;
        if (typeof value !== typeof testAgainst) {
            return false;
        }
        return this._returnNegationCheck(value < testAgainst, negation);
    }
    static lessEqual(value, testAgainst, negation) {
        value = isNumeric(value) ? toNumber(value) : value;
        testAgainst = isNumeric(testAgainst) ? toNumber(testAgainst) : testAgainst;
        if (typeof value !== typeof testAgainst) {
            return false;
        }
        return this._returnNegationCheck(value <= testAgainst, negation);
    }
    static contains(value, testAgainst, negation) {
        value = String(value);
        testAgainst = String(testAgainst);
        value = value.valueOf().toLowerCase();
        testAgainst = testAgainst.valueOf().toLowerCase();
        if (testAgainst.replace(/^([\s]*)|([\s]*)$/g, '').length === 0) {
            return this._returnNegationCheck(true, negation);
        }
        return this._returnNegationCheck(value.indexOf(testAgainst) !== -1, negation);
    }
    static isIn(values, testAgainst, negation = false, splitter = '|') {
        const matchedValuesArray = String(values)
            .split(splitter)
            .map((item) => {
            return String(item);
        });
        if (typeof testAgainst === 'string') {
            testAgainst = testAgainst.split(splitter);
        }
        if (!Array.isArray(testAgainst)) {
            testAgainst = [];
        }
        testAgainst = testAgainst.map((item) => {
            return String(item).valueOf().toLowerCase();
        });
        for (let i = 0; i < matchedValuesArray.length; i++) {
            if (testAgainst.indexOf(matchedValuesArray[i]) !== -1) {
                return this._returnNegationCheck(true, negation);
            }
        }
        return this._returnNegationCheck(false, negation);
    }
    static startsWith(value, testAgainst, negation) {
        value = String(value).valueOf().toLowerCase();
        testAgainst = String(testAgainst).valueOf().toLowerCase();
        return this._returnNegationCheck(value.indexOf(testAgainst) === 0, negation);
    }
    static endsWith(value, testAgainst, negation) {
        value = String(value).valueOf().toLowerCase();
        testAgainst = String(testAgainst).valueOf().toLowerCase();
        return this._returnNegationCheck(value.indexOf(testAgainst, value.length - testAgainst.length) !== -1, negation);
    }
    static regexMatches(value, testAgainst, negation) {
        value = String(value).valueOf().toLowerCase();
        testAgainst = String(testAgainst).valueOf();
        const regExp = new RegExp(testAgainst, 'i');
        return this._returnNegationCheck(regExp.test(value), negation);
    }
    static _returnNegationCheck(value, negation = false) {
        if (negation) {
            return !value;
        }
        else {
            return value;
        }
    }
}
_a = Comparisons;
Comparisons.equalsNumber = _a.equals;
Comparisons.matches = _a.equals;

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var HttpStatusCode;
(function (HttpStatusCode) {
    HttpStatusCode[HttpStatusCode["Continue"] = 100] = "Continue";
    HttpStatusCode[HttpStatusCode["SwitchingProtocols"] = 101] = "SwitchingProtocols";
    HttpStatusCode[HttpStatusCode["Processing"] = 102] = "Processing";
    HttpStatusCode[HttpStatusCode["EarlyHints"] = 103] = "EarlyHints";
    HttpStatusCode[HttpStatusCode["Ok"] = 200] = "Ok";
    HttpStatusCode[HttpStatusCode["Created"] = 201] = "Created";
    HttpStatusCode[HttpStatusCode["Accepted"] = 202] = "Accepted";
    HttpStatusCode[HttpStatusCode["NonAuthoritativeInformation"] = 203] = "NonAuthoritativeInformation";
    HttpStatusCode[HttpStatusCode["NoContent"] = 204] = "NoContent";
    HttpStatusCode[HttpStatusCode["ResetContent"] = 205] = "ResetContent";
    HttpStatusCode[HttpStatusCode["PartialContent"] = 206] = "PartialContent";
    HttpStatusCode[HttpStatusCode["MultiStatus"] = 207] = "MultiStatus";
    HttpStatusCode[HttpStatusCode["AlreadyReported"] = 208] = "AlreadyReported";
    HttpStatusCode[HttpStatusCode["ImUsed"] = 226] = "ImUsed";
    HttpStatusCode[HttpStatusCode["MultipleChoices"] = 300] = "MultipleChoices";
    HttpStatusCode[HttpStatusCode["MovedPermanently"] = 301] = "MovedPermanently";
    HttpStatusCode[HttpStatusCode["Found"] = 302] = "Found";
    HttpStatusCode[HttpStatusCode["SeeOther"] = 303] = "SeeOther";
    HttpStatusCode[HttpStatusCode["NotModified"] = 304] = "NotModified";
    HttpStatusCode[HttpStatusCode["UseProxy"] = 305] = "UseProxy";
    HttpStatusCode[HttpStatusCode["Unused"] = 306] = "Unused";
    HttpStatusCode[HttpStatusCode["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpStatusCode[HttpStatusCode["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpStatusCode[HttpStatusCode["BadRequest"] = 400] = "BadRequest";
    HttpStatusCode[HttpStatusCode["Unauthorized"] = 401] = "Unauthorized";
    HttpStatusCode[HttpStatusCode["PaymentRequired"] = 402] = "PaymentRequired";
    HttpStatusCode[HttpStatusCode["Forbidden"] = 403] = "Forbidden";
    HttpStatusCode[HttpStatusCode["NotFound"] = 404] = "NotFound";
    HttpStatusCode[HttpStatusCode["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpStatusCode[HttpStatusCode["NotAcceptable"] = 406] = "NotAcceptable";
    HttpStatusCode[HttpStatusCode["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpStatusCode[HttpStatusCode["RequestTimeout"] = 408] = "RequestTimeout";
    HttpStatusCode[HttpStatusCode["Conflict"] = 409] = "Conflict";
    HttpStatusCode[HttpStatusCode["Gone"] = 410] = "Gone";
    HttpStatusCode[HttpStatusCode["LengthRequired"] = 411] = "LengthRequired";
    HttpStatusCode[HttpStatusCode["PreconditionFailed"] = 412] = "PreconditionFailed";
    HttpStatusCode[HttpStatusCode["PayloadTooLarge"] = 413] = "PayloadTooLarge";
    HttpStatusCode[HttpStatusCode["UriTooLong"] = 414] = "UriTooLong";
    HttpStatusCode[HttpStatusCode["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
    HttpStatusCode[HttpStatusCode["RangeNotSatisfiable"] = 416] = "RangeNotSatisfiable";
    HttpStatusCode[HttpStatusCode["ExpectationFailed"] = 417] = "ExpectationFailed";
    HttpStatusCode[HttpStatusCode["ImATeapot"] = 418] = "ImATeapot";
    HttpStatusCode[HttpStatusCode["MisdirectedRequest"] = 421] = "MisdirectedRequest";
    HttpStatusCode[HttpStatusCode["UnprocessableEntity"] = 422] = "UnprocessableEntity";
    HttpStatusCode[HttpStatusCode["Locked"] = 423] = "Locked";
    HttpStatusCode[HttpStatusCode["FailedDependency"] = 424] = "FailedDependency";
    HttpStatusCode[HttpStatusCode["TooEarly"] = 425] = "TooEarly";
    HttpStatusCode[HttpStatusCode["UpgradeRequired"] = 426] = "UpgradeRequired";
    HttpStatusCode[HttpStatusCode["PreconditionRequired"] = 428] = "PreconditionRequired";
    HttpStatusCode[HttpStatusCode["TooManyRequests"] = 429] = "TooManyRequests";
    HttpStatusCode[HttpStatusCode["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
    HttpStatusCode[HttpStatusCode["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
    HttpStatusCode[HttpStatusCode["InternalServerError"] = 500] = "InternalServerError";
    HttpStatusCode[HttpStatusCode["NotImplemented"] = 501] = "NotImplemented";
    HttpStatusCode[HttpStatusCode["BadGateway"] = 502] = "BadGateway";
    HttpStatusCode[HttpStatusCode["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpStatusCode[HttpStatusCode["GatewayTimeout"] = 504] = "GatewayTimeout";
    HttpStatusCode[HttpStatusCode["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
    HttpStatusCode[HttpStatusCode["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
    HttpStatusCode[HttpStatusCode["InsufficientStorage"] = 507] = "InsufficientStorage";
    HttpStatusCode[HttpStatusCode["LoopDetected"] = 508] = "LoopDetected";
    HttpStatusCode[HttpStatusCode["NotExtended"] = 510] = "NotExtended";
    HttpStatusCode[HttpStatusCode["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
})(HttpStatusCode || (HttpStatusCode = {}));
const determineRuntime = () => {
    // if window is available, we're in a browser
    if (typeof window !== 'undefined') {
        return { runtime: 'browser' };
    }
    // if window is not available, but fetch is, then we're on a server that has the fetch API available
    if (typeof fetch === 'function') {
        return { runtime: 'server-with-fetch' };
    }
    // if node.js builtins are available, we're on nodejs
    try {
        // Gracefully attempt to NodeJS builtins, to prevent throwing exceptions in browsers
        const url = require('url');
        const http = require('http');
        const https = require('https');
        const queryString = require('querystring');
        return { runtime: 'old-nodejs', url, http, https, queryString };
    }
    catch (err) {
        // not nodejs
    }
    // otherwise, this is some unknown runtime
    return { runtime: 'unknown' };
};
const supportsRequestBody = (method) => !['GET', 'HEAD', 'DELETE', 'TRACE', 'OPTIONS'].includes(method.toUpperCase());
const serialize = (params, method, runtimeResult) => {
    let query = '';
    if (objectNotEmpty(params) && !supportsRequestBody(method)) {
        if (runtimeResult.runtime !== 'old-nodejs') {
            query = Object.keys(params)
                .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`)
                .join('&');
        }
        else {
            query = runtimeResult.queryString.stringify(params);
        }
    }
    return query ? `?${query}` : query;
};
/**
 * Provide http client for newtork requests
 * @param {HttpRequest}
 * @returns {HttpClient}
 */
const HttpClient = {
    request(config) {
        var _a;
        const method = ((_a = config === null || config === void 0 ? void 0 : config.method) === null || _a === void 0 ? void 0 : _a.toUpperCase()) || 'GET';
        const path = (config === null || config === void 0 ? void 0 : config.path)
            ? !config.path.startsWith('/')
                ? `/${config.path}`
                : config.path
            : '';
        const baseURL = config.baseURL.endsWith('/')
            ? config.baseURL.slice(0, -1)
            : config.baseURL;
        const responseType = (config === null || config === void 0 ? void 0 : config.responseType) || 'json';
        const runtimeResult = determineRuntime();
        return new Promise((resolve, reject) => {
            if (runtimeResult.runtime === 'browser' ||
                runtimeResult.runtime === 'server-with-fetch') {
                const options = {
                    method,
                    keepalive: true // to allow the request to complete even if the page unloads
                };
                if (config === null || config === void 0 ? void 0 : config.headers)
                    options.headers = config.headers;
                if ((config === null || config === void 0 ? void 0 : config.data) && supportsRequestBody(method)) {
                    options.body = JSON.stringify(config.data);
                }
                const url = `${baseURL}${path}${serialize(config === null || config === void 0 ? void 0 : config.data, method, runtimeResult)}`;
                if (method.toLowerCase() === 'post' &&
                    typeof navigator !== 'undefined' &&
                    (navigator === null || navigator === void 0 ? void 0 : navigator.sendBeacon)) {
                    /**
                     * navigator.sendBeacon method is intended for analytics
                     * and diagnostics code to send data to a server,
                     * given that analytics data are often sent to different
                     * subdomains or even different domains:
                     * 1. The browser drops CORS restraints resulted in omitting
                     * the OPTIONS request and allowing relevant cookies to be sent.
                     * 2. The browser will not abort the requests upon page unload,
                     * instead completes them in the background while the next page
                     * requests was already being processed.
                     * 3. The browser cannot decide whether the request has failed,
                     * the function only returns a boolean.
                     * 4. The specification does not define body size limitations,
                     * vendors may choose to limit the size of the request.
                     * 5. Only supports requests with POST method.
                     * 6. The following browsers cannot send Blob data: Chrome, Chrome Android, Opera, Opera Android, and WebView Android.
                     */
                    if (navigator.sendBeacon(url, options.body)) {
                        resolve({
                            data: true,
                            status: HttpStatusCode.Ok,
                            statusText: MESSAGES.SEND_BEACON_SUCCESS
                        });
                    }
                    else {
                        reject({
                            message: ERROR_MESSAGES.UNSUPPORTED_RESPONSE_TYPE
                        });
                    }
                }
                else {
                    fetch(url, options)
                        .then((res) => __awaiter(this, void 0, void 0, function* () {
                        if (res.status === HttpStatusCode.Ok) {
                            const output = {
                                status: res.status,
                                statusText: res.statusText,
                                headers: res.headers,
                                data: null
                            };
                            switch (responseType) {
                                case 'json':
                                    output.data = yield res.json();
                                    break;
                                case 'arraybuffer':
                                    output.data = yield res.arrayBuffer();
                                    break;
                                case 'text':
                                    output.data = res;
                                    break;
                                default:
                                    reject({
                                        message: ERROR_MESSAGES.UNSUPPORTED_RESPONSE_TYPE
                                    });
                                    return;
                            }
                            resolve(output);
                        }
                        else {
                            reject({
                                message: res.statusText,
                                status: res.status
                            });
                        }
                    }))
                        .catch((err) => {
                        reject({
                            message: err === null || err === void 0 ? void 0 : err.message,
                            status: err === null || err === void 0 ? void 0 : err.status,
                            statusText: err === null || err === void 0 ? void 0 : err.statusText
                        });
                    });
                }
            }
            else if (runtimeResult.runtime === 'old-nodejs') {
                // Fallback to CommonJS if not targeting a browser
                const parsedBaseUrl = runtimeResult.url.parse(baseURL);
                if (!parsedBaseUrl.port) {
                    parsedBaseUrl.port =
                        parsedBaseUrl.protocol === 'https:' ? '443' : '80';
                }
                const pathPrefix = parsedBaseUrl.path.endsWith('/')
                    ? parsedBaseUrl.path.slice(0, -1)
                    : parsedBaseUrl.path;
                const client = parsedBaseUrl.protocol === 'https:'
                    ? runtimeResult.https
                    : runtimeResult.http;
                const body = [];
                const options = {
                    hostname: parsedBaseUrl.hostname,
                    path: `${pathPrefix}${path}${serialize(config === null || config === void 0 ? void 0 : config.data, method, runtimeResult)}`,
                    port: parsedBaseUrl.port,
                    method
                };
                const postData = (config === null || config === void 0 ? void 0 : config.data) && supportsRequestBody(method)
                    ? JSON.stringify(config.data)
                    : null;
                if (config === null || config === void 0 ? void 0 : config.headers)
                    options.headers = config.headers;
                if (postData) {
                    if (!options.headers)
                        options.headers = {};
                    options.headers['Content-Length'] = Buffer.byteLength(postData);
                }
                const req = client.request(options, (res) => {
                    res.on('data', (chunk) => body.push(chunk));
                    res.on('end', () => {
                        if (res.statusCode === HttpStatusCode.Ok) {
                            const buffer = Buffer.concat(body);
                            const data = buffer.toString();
                            const output = {
                                status: res.statusCode,
                                statusText: res.statusMessage,
                                headers: res.headers,
                                data: null
                            };
                            switch (responseType) {
                                case 'json':
                                    output.data = data ? JSON.parse(data) : '';
                                    break;
                                case 'arraybuffer':
                                    output.data = buffer === null || buffer === void 0 ? void 0 : buffer.buffer;
                                    break;
                                case 'text':
                                    output.data = res;
                                    break;
                                default:
                                    reject({
                                        message: ERROR_MESSAGES.UNSUPPORTED_RESPONSE_TYPE
                                    });
                                    return;
                            }
                            resolve(output);
                        }
                        else {
                            reject({
                                message: res.statusMessage,
                                status: res.statusCode
                            });
                        }
                    });
                });
                req.on('error', (err) => {
                    const e = err;
                    reject({
                        message: e === null || e === void 0 ? void 0 : e.message,
                        status: e === null || e === void 0 ? void 0 : e.code,
                        statusText: e === null || e === void 0 ? void 0 : e.statusText
                    });
                });
                if (postData)
                    req.write(postData);
                req.end();
            }
            else {
                reject({
                    message: ERROR_MESSAGES.UNABLE_TO_PERFORM_NETWORK_REQUEST
                });
            }
        });
    }
};

const DEFAULT_HEADERS = {
    'Content-Type': 'application/json'
};
const DEFAULT_BATCH_SIZE = 10;
const DEFAULT_RELEASE_INTERVAL = 10000;
const DEFAULT_CONFIG_ENDPOINT = 'https://cdn-4.convertexperiments.com/api/v1/';
const DEFAULT_TRACK_ENDPOINT = 'https://[project_id].metrics.convertexperiments.com/v1/';
/**
 * Provides logic for network requests. Reads remote configuration and sends tracking events to Convert server.
 * @category Modules
 * @constructor
 * @implements {ApiManagerInterface}
 */
class ApiManager {
    /**
     * @param {Config=} config
     * @param {Object=} dependencies
     * @param {EventManagerInterface=} dependencies.eventManager
     * @param {LogManagerInterface=} dependencies.loggerManager
     */
    constructor(config, { eventManager, loggerManager } = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        this._configEndpoint = DEFAULT_CONFIG_ENDPOINT;
        this._trackEndpoint = DEFAULT_TRACK_ENDPOINT;
        this._defaultHeaders = DEFAULT_HEADERS;
        this.batchSize = DEFAULT_BATCH_SIZE;
        this.releaseInterval = DEFAULT_RELEASE_INTERVAL;
        this._loggerManager = loggerManager;
        this._eventManager = eventManager;
        this._configEndpoint =
            ((_b = (_a = config === null || config === void 0 ? void 0 : config.api) === null || _a === void 0 ? void 0 : _a.endpoint) === null || _b === void 0 ? void 0 : _b.config) || DEFAULT_CONFIG_ENDPOINT;
        this._trackEndpoint =
            ((_d = (_c = config === null || config === void 0 ? void 0 : config.api) === null || _c === void 0 ? void 0 : _c.endpoint) === null || _d === void 0 ? void 0 : _d.track) || DEFAULT_TRACK_ENDPOINT;
        this._data = objectDeepValue(config, 'data');
        this._enrichData = !objectDeepValue(config, 'dataStore');
        this._environment = config === null || config === void 0 ? void 0 : config.environment;
        this._mapper = (config === null || config === void 0 ? void 0 : config.mapper) || ((value) => value);
        this.batchSize = Number((_e = config === null || config === void 0 ? void 0 : config.events) === null || _e === void 0 ? void 0 : _e.batch_size) || DEFAULT_BATCH_SIZE;
        this.releaseInterval =
            Number((_f = config === null || config === void 0 ? void 0 : config.events) === null || _f === void 0 ? void 0 : _f.release_interval) || DEFAULT_RELEASE_INTERVAL;
        this._accountId = (_g = this._data) === null || _g === void 0 ? void 0 : _g.account_id;
        this._projectId = (_j = (_h = this._data) === null || _h === void 0 ? void 0 : _h.project) === null || _j === void 0 ? void 0 : _j.id;
        this._sdkKey = (config === null || config === void 0 ? void 0 : config.sdkKey) || `${this._accountId}/${this._projectId}`;
        if (config === null || config === void 0 ? void 0 : config.sdkKeySecret)
            this._defaultHeaders['Authorization'] = `Bearer ${config === null || config === void 0 ? void 0 : config.sdkKeySecret}`;
        this._trackingEvent = {
            enrichData: this._enrichData,
            accountId: this._accountId,
            projectId: this._projectId,
            visitors: []
        };
        this._trackingEnabled = (_k = config === null || config === void 0 ? void 0 : config.network) === null || _k === void 0 ? void 0 : _k.tracking;
        this._trackingSource = ((_l = config === null || config === void 0 ? void 0 : config.network) === null || _l === void 0 ? void 0 : _l.source) || 'js-sdk';
        this._cacheLevel = (_m = config === null || config === void 0 ? void 0 : config.network) === null || _m === void 0 ? void 0 : _m.cacheLevel;
        this._requestsQueue = {
            length: 0,
            items: [],
            push(visitorId, eventRequest, segments) {
                const visitorIndex = this.items.findIndex((event) => event.visitorId === visitorId);
                if (visitorIndex !== -1) {
                    this.items[visitorIndex].events.push(eventRequest);
                }
                else {
                    const visitor = {
                        visitorId,
                        events: [eventRequest]
                    };
                    if (segments)
                        visitor.segments = segments;
                    this.items.push(visitor);
                }
                this.length++;
            },
            reset() {
                this.items = [];
                this.length = 0;
            }
        };
    }
    /**
     * Send request to api server
     * @param method
     * @param path
     * @param data
     * @param headers
     * @return {Promise<HttpResponse>}
     */
    request(method_1, path_1) {
        return __awaiter(this, arguments, void 0, function* (method, path, data = {}, headers = {}) {
            const requestHeaders = Object.assign(Object.assign({}, this._defaultHeaders), headers);
            const requestConfig = {
                method: method,
                path: path.route,
                baseURL: path.base,
                headers: requestHeaders,
                data: data,
                responseType: 'json'
            };
            return HttpClient.request(requestConfig);
        });
    }
    /**
     * Add request to queue for sending to server
     * @param {string} visitorId
     * @param {VisitorTrackingEvents} eventRequest
     * @param {VisitorSegments} segments
     */
    enqueue(visitorId, eventRequest, segments) {
        var _a, _b;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'ApiManager.enqueue()', this._mapper({
            eventRequest: eventRequest
        }));
        this._requestsQueue.push(visitorId, eventRequest, segments);
        if (this._trackingEnabled) {
            if (this._requestsQueue.length === 1) {
                this.startQueue();
            }
            else if (this._requestsQueue.length === this.batchSize) {
                this.releaseQueue('size').then();
            }
        }
    }
    /**
     * Send queue to server
     * @param {string=} reason
     * @return {Promise<any>}
     */
    releaseQueue(reason) {
        var _a, _b, _c, _d;
        if (!this._requestsQueue.length)
            return;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.info) === null || _b === void 0 ? void 0 : _b.call(_a, 'ApiManager.releaseQueue()', MESSAGES.RELEASING_QUEUE);
        (_d = (_c = this._loggerManager) === null || _c === void 0 ? void 0 : _c.trace) === null || _d === void 0 ? void 0 : _d.call(_c, 'ApiManager.releaseQueue()', {
            reason: reason || ''
        });
        this.stopQueue();
        const payload = this._trackingEvent;
        payload.visitors = this._requestsQueue.items.slice();
        payload.source = this._trackingSource;
        return this.request('post', {
            base: this._trackEndpoint.replace('[project_id]', this._projectId.toString()),
            route: `/track/${this._sdkKey}`
        }, this._mapper(payload))
            .then((result) => {
            var _a, _b;
            this._requestsQueue.reset();
            (_b = (_a = this._eventManager) === null || _a === void 0 ? void 0 : _a.fire) === null || _b === void 0 ? void 0 : _b.call(_a, SystemEvents.API_QUEUE_RELEASED, {
                reason: reason,
                result: result,
                visitors: payload.visitors
            });
        })
            .catch((error) => {
            var _a, _b, _c, _d;
            // TODO: set an exponential backoff
            (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, 'ApiManager.releaseQueue()', {
                error: error.message
            });
            this.startQueue();
            (_d = (_c = this._eventManager) === null || _c === void 0 ? void 0 : _c.fire) === null || _d === void 0 ? void 0 : _d.call(_c, SystemEvents.API_QUEUE_RELEASED, { reason: reason }, error);
        });
    }
    /**
     * Stop queue timer
     */
    stopQueue() {
        clearTimeout(this._requestsQueueTimerID);
    }
    /**
     * Start queue timer
     */
    startQueue() {
        this._requestsQueueTimerID = setTimeout(() => {
            this.releaseQueue('timeout');
        }, this.releaseInterval);
    }
    /**
     * Enable tracking
     */
    enableTracking() {
        this._trackingEnabled = true;
        this.releaseQueue('trackingEnabled');
    }
    /**
     * Disable tracking
     */
    disableTracking() {
        this._trackingEnabled = false;
    }
    /**
     * Set data
     */
    setData(data) {
        var _a;
        this._data = data;
        this._accountId = data === null || data === void 0 ? void 0 : data.account_id;
        this._projectId = (_a = data === null || data === void 0 ? void 0 : data.project) === null || _a === void 0 ? void 0 : _a.id;
        this._trackingEvent.accountId = this._accountId;
        this._trackingEvent.projectId = this._projectId;
    }
    /**
     * Get config data
     * @return {Promise<ConfigResponseData>}
     */
    getConfig() {
        var _a, _b;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'ApiManager.getConfig()');
        let query = this._cacheLevel === 'low' || this._environment ? '?' : '';
        if (this._environment)
            query += `environment=${this._environment}`;
        if (this._cacheLevel === 'low')
            query += '_conv_low_cache=1';
        return new Promise((resolve, reject) => {
            this.request('get', {
                base: this._configEndpoint,
                route: `/config/${this._sdkKey}${query}`
            })
                .then(({ data }) => resolve(data))
                .catch(reject);
        });
    }
}

export { ApiManager };
//# sourceMappingURL=index.mjs.map
