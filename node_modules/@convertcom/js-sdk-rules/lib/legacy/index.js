'use strict';

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * Validates variable is array and not empty
 * @param array
 */
function arrayNotEmpty(array) {
    return Array.isArray(array) && array.length > 0;
}

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * Returns the value at path of object
 * TODO: get this utility to work with the optional mapper() helper from config
 * @param {Record<string, any>} object
 * @param {string} path
 * @param {any=} defaultValue
 * @param {boolean=} truthy Should Number 0 number and Boolean false be considered as normal value
 * @return {any}
 */
/**
 * Validates variable is object and not empty
 * @param object
 */
function objectNotEmpty(object) {
    return (typeof object === 'object' &&
        object !== null &&
        Object.keys(object).length > 0);
}

var murmurhash = {exports: {}};

(function (module) {
  (function () {
    const createBuffer = val => new TextEncoder().encode(val);

    /**
     * JS Implementation of MurmurHash2
     *
     * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
     * @see http://github.com/garycourt/murmurhash-js
     * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
     * @see http://sites.google.com/site/murmurhash/
     *
     * @param {Uint8Array | string} str ASCII only
     * @param {number} seed Positive integer only
     * @return {number} 32-bit positive integer hash
     */
    function MurmurHashV2(str, seed) {
      if (typeof str === 'string') str = createBuffer(str);
      let l = str.length,
        h = seed ^ l,
        i = 0,
        k;
      while (l >= 4) {
        k = str[i] & 0xff | (str[++i] & 0xff) << 8 | (str[++i] & 0xff) << 16 | (str[++i] & 0xff) << 24;
        k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
        k ^= k >>> 24;
        k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
        h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16) ^ k;
        l -= 4;
        ++i;
      }
      switch (l) {
        case 3:
          h ^= (str[i + 2] & 0xff) << 16;
        case 2:
          h ^= (str[i + 1] & 0xff) << 8;
        case 1:
          h ^= str[i] & 0xff;
          h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
      }
      h ^= h >>> 13;
      h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
      h ^= h >>> 15;
      return h >>> 0;
    }

    /*
     * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)
     *
     * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
     * @see http://github.com/garycourt/murmurhash-js
     * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
     * @see http://sites.google.com/site/murmurhash/
     *
     * @param {Uint8Array | string} key ASCII only
     * @param {number} seed Positive integer only
     * @return {number} 32-bit positive integer hash
     */
    function MurmurHashV3(key, seed) {
      if (typeof key === 'string') key = createBuffer(key);
      let remainder, bytes, h1, h1b, c1, c2, k1, i;
      remainder = key.length & 3; // key.length % 4
      bytes = key.length - remainder;
      h1 = seed;
      c1 = 0xcc9e2d51;
      c2 = 0x1b873593;
      i = 0;
      while (i < bytes) {
        k1 = key[i] & 0xff | (key[++i] & 0xff) << 8 | (key[++i] & 0xff) << 16 | (key[++i] & 0xff) << 24;
        ++i;
        k1 = (k1 & 0xffff) * c1 + (((k1 >>> 16) * c1 & 0xffff) << 16) & 0xffffffff;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = (k1 & 0xffff) * c2 + (((k1 >>> 16) * c2 & 0xffff) << 16) & 0xffffffff;
        h1 ^= k1;
        h1 = h1 << 13 | h1 >>> 19;
        h1b = (h1 & 0xffff) * 5 + (((h1 >>> 16) * 5 & 0xffff) << 16) & 0xffffffff;
        h1 = (h1b & 0xffff) + 0x6b64 + (((h1b >>> 16) + 0xe654 & 0xffff) << 16);
      }
      k1 = 0;
      switch (remainder) {
        case 3:
          k1 ^= (key[i + 2] & 0xff) << 16;
        case 2:
          k1 ^= (key[i + 1] & 0xff) << 8;
        case 1:
          k1 ^= key[i] & 0xff;
          k1 = (k1 & 0xffff) * c1 + (((k1 >>> 16) * c1 & 0xffff) << 16) & 0xffffffff;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = (k1 & 0xffff) * c2 + (((k1 >>> 16) * c2 & 0xffff) << 16) & 0xffffffff;
          h1 ^= k1;
      }
      h1 ^= key.length;
      h1 ^= h1 >>> 16;
      h1 = (h1 & 0xffff) * 0x85ebca6b + (((h1 >>> 16) * 0x85ebca6b & 0xffff) << 16) & 0xffffffff;
      h1 ^= h1 >>> 13;
      h1 = (h1 & 0xffff) * 0xc2b2ae35 + (((h1 >>> 16) * 0xc2b2ae35 & 0xffff) << 16) & 0xffffffff;
      h1 ^= h1 >>> 16;
      return h1 >>> 0;
    }
    const murmur = MurmurHashV3;
    murmur.v2 = MurmurHashV2;
    murmur.v3 = MurmurHashV3;
    {
      module.exports = murmur;
    }
  })();
})(murmurhash);

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * String formatter tool. Transforms a space-separated string into camelCase
 * @param {string} input
 * @return {string}
 */
function camelCase(input) {
    return input
        .replace(/(?:^\w|[A-Z]|\b\w)/g, function (word, index) {
        return index === 0 ? word.toLowerCase() : word.toUpperCase();
    })
        .replace(/\s+/g, '');
}
/**
 * Check if a value is numeric
 * @param {string | number} value
 * @returns {boolean}
 */
function isNumeric(value) {
    if (typeof value === 'number') {
        return true;
    }
    const number = parseFloat(String(value));
    return Number.isFinite(number) && !isNaN(number);
}
/**
 * Convert a string to a number
 * @param {string | number} value
 * @returns {number}
 */
function toNumber(value) {
    if (typeof value === 'number') {
        return value;
    }
    const parts = String(value).split(',');
    return parseFloat(parts[0] == '0'
        ? String(value).replace(/,/g, '.')
        : String(value).replace(/,/g, ''));
}

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var _a;
/**
 * Comparison Processor. Provides comparison methods for rules validation
 */
class Comparisons {
    static equals(value, testAgainst, negation) {
        if (Array.isArray(value))
            return this._returnNegationCheck(value.indexOf(testAgainst) !== -1, negation);
        if (objectNotEmpty(value))
            return this._returnNegationCheck(Object.keys(value).indexOf(String(testAgainst)) !== -1, negation);
        value = String(value);
        testAgainst = String(testAgainst);
        value = value.valueOf().toLowerCase();
        testAgainst = testAgainst.valueOf().toLowerCase();
        return this._returnNegationCheck(value === testAgainst, negation);
    }
    static less(value, testAgainst, negation) {
        value = isNumeric(value) ? toNumber(value) : value;
        testAgainst = isNumeric(testAgainst) ? toNumber(testAgainst) : testAgainst;
        if (typeof value !== typeof testAgainst) {
            return false;
        }
        return this._returnNegationCheck(value < testAgainst, negation);
    }
    static lessEqual(value, testAgainst, negation) {
        value = isNumeric(value) ? toNumber(value) : value;
        testAgainst = isNumeric(testAgainst) ? toNumber(testAgainst) : testAgainst;
        if (typeof value !== typeof testAgainst) {
            return false;
        }
        return this._returnNegationCheck(value <= testAgainst, negation);
    }
    static contains(value, testAgainst, negation) {
        value = String(value);
        testAgainst = String(testAgainst);
        value = value.valueOf().toLowerCase();
        testAgainst = testAgainst.valueOf().toLowerCase();
        if (testAgainst.replace(/^([\s]*)|([\s]*)$/g, '').length === 0) {
            return this._returnNegationCheck(true, negation);
        }
        return this._returnNegationCheck(value.indexOf(testAgainst) !== -1, negation);
    }
    static isIn(values, testAgainst, negation = false, splitter = '|') {
        const matchedValuesArray = String(values)
            .split(splitter)
            .map((item) => {
            return String(item);
        });
        if (typeof testAgainst === 'string') {
            testAgainst = testAgainst.split(splitter);
        }
        if (!Array.isArray(testAgainst)) {
            testAgainst = [];
        }
        testAgainst = testAgainst.map((item) => {
            return String(item).valueOf().toLowerCase();
        });
        for (let i = 0; i < matchedValuesArray.length; i++) {
            if (testAgainst.indexOf(matchedValuesArray[i]) !== -1) {
                return this._returnNegationCheck(true, negation);
            }
        }
        return this._returnNegationCheck(false, negation);
    }
    static startsWith(value, testAgainst, negation) {
        value = String(value).valueOf().toLowerCase();
        testAgainst = String(testAgainst).valueOf().toLowerCase();
        return this._returnNegationCheck(value.indexOf(testAgainst) === 0, negation);
    }
    static endsWith(value, testAgainst, negation) {
        value = String(value).valueOf().toLowerCase();
        testAgainst = String(testAgainst).valueOf().toLowerCase();
        return this._returnNegationCheck(value.indexOf(testAgainst, value.length - testAgainst.length) !== -1, negation);
    }
    static regexMatches(value, testAgainst, negation) {
        value = String(value).valueOf().toLowerCase();
        testAgainst = String(testAgainst).valueOf();
        const regExp = new RegExp(testAgainst, 'i');
        return this._returnNegationCheck(regExp.test(value), negation);
    }
    static _returnNegationCheck(value, negation = false) {
        if (negation) {
            return !value;
        }
        else {
            return value;
        }
    }
}
_a = Comparisons;
Comparisons.equalsNumber = _a.equals;
Comparisons.matches = _a.equals;

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var BucketingError;
(function (BucketingError) {
    BucketingError["VARIAION_NOT_DECIDED"] = "convert.com_variation_not_decided";
})(BucketingError || (BucketingError = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var ConversionSettingKey;
(function (ConversionSettingKey) {
    ConversionSettingKey["FORCE_MULTIPLE_TRANSACTIONS"] = "forceMultipleTransactions";
})(ConversionSettingKey || (ConversionSettingKey = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
const ERROR_MESSAGES = {
    SDK_KEY_MISSING: 'SDK key is missing',
    DATA_OBJECT_MISSING: 'Data object is missing',
    CONFIG_DATA_NOT_VALID: 'Config Data is not valid',
    SDK_OR_DATA_OBJECT_REQUIRED: 'SDK key or Data object should be provided',
    RULE_NOT_VALID: 'Provided rule is not valid',
    RULE_DATA_NOT_VALID: 'Provided rule data is not valid',
    RULE_MATCH_TYPE_NOT_SUPPORTED: 'Provided rule matching type "#" is not supported',
    RULE_ERROR: 'Rule error',
    DATA_STORE_NOT_VALID: 'DataStore object is not valid. It should contain get and set methods',
    VISITOR_ID_REQUIRED: 'Visitor string string is not present',
    GOAL_DATA_NOT_VALID: 'GoalData object is not valid',
    UNABLE_TO_SELECT_BUCKET_FOR_VISITOR: 'Unable to bucket visitor',
    UNABLE_TO_PERFORM_NETWORK_REQUEST: 'Unable to perform network request',
    UNSUPPORTED_RESPONSE_TYPE: 'Unsupported response type'
};
const MESSAGES = {
    CONFIG_DATA_UPDATED: 'Config Data updated',
    CORE_CONSTRUCTOR: 'Core Manager constructor has been called',
    CORE_INITIALIZED: 'Core Manager has been initialized',
    EXPERIENCE_CONSTRUCTOR: 'Experience Manager constructor has been called',
    EXPERIENCE_NOT_FOUND: 'Experience not found',
    EXPERIENCE_ARCHIVED: 'Experience archived',
    EXPERIENCE_ENVIRONMENT_NOT_MATCH: 'Experience environment does not match',
    EXPERIENCE_RULES_MATCHED: 'Experience rules matched',
    VARIATIONS_NOT_FOUND: 'Variations not found',
    VARIATION_CHANGE_NOT_SUPPORTED: 'Variation change not supported',
    FEATURE_CONSTRUCTOR: 'Feature Manager constructor has been called',
    FEATURE_NOT_FOUND: 'Fullstack Feature not found',
    FEATURE_VARIABLES_NOT_FOUND: 'Fullstack Feature Variables not found',
    FEATURE_VARIABLES_TYPE_NOT_FOUND: 'Fullstack Feature Variables Type not found',
    BUCKETING_CONSTRUCTOR: 'Bucketing Manager constructor has been called',
    DATA_CONSTRUCTOR: 'Data Manager constructor has been called',
    RULE_CONSTRUCTOR: 'Rule Manager constructor has been called',
    PROCESSING_ENTITY: 'Processing #',
    LOCATION_MATCH: 'Location # rule matched',
    LOCATION_NOT_MATCH: 'Location does not match',
    LOCATION_NOT_RESTRICTED: 'Location not restricted',
    AUDIENCE_MATCH: 'Audience # rule matched',
    AUDIENCE_NOT_MATCH: 'Audience does not match',
    NON_PERMANENT_AUDIENCE_NOT_RESTRICTED: 'Non-Permanent Audience not restricted',
    AUDIENCE_NOT_RESTRICTED: 'Audience not restricted',
    SEGMENTATION_MATCH: 'Segmentation # rule matched',
    SEGMENTATION_NOT_RESTRICTED: 'Segmentation not restricted',
    RULE_NOT_MATCH: 'Rule does not match',
    RULE_MATCH: 'Found matched rule at OR block #',
    RULE_MATCH_AND: 'AND block rule macthed',
    RULE_MATCH_START: 'About to evaluate rule #',
    LOCATION_ACTIVATED: 'Location # activated',
    LOCATION_DEACTIVATED: 'Location # deactivated',
    BUCKETED_VISITOR_FOUND: 'Visitor is already bucketed for variation #',
    BUCKETED_VISITOR_FORCED: 'Forcing variation #',
    BUCKETED_VISITOR: 'Visitor is bucketed for variation #',
    GOAL_NOT_FOUND: 'Goal not found',
    GOAL_RULE_NOT_MATCH: 'Goal rule do not match',
    GOAL_FOUND: 'Goal # already triggered',
    SEGMENTS_NOT_FOUND: 'Segments not found',
    SEGMENTS_RULE_NOT_MATCH: 'Segments rule do not match',
    CUSTOM_SEGMENTS_KEY_FOUND: 'Custom segments key already set',
    SEND_BEACON_SUCCESS: 'The user agent successfully queued the data for transfer',
    RELEASING_QUEUE: 'Releasing event queue...'
};

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var DoNotTrack;
(function (DoNotTrack) {
    DoNotTrack["OFF"] = "OFF";
    DoNotTrack["EU_ONLY"] = "EU ONLY";
    DoNotTrack["EEA_ONLY"] = "EEA ONLY";
    DoNotTrack["WORLDWIDE"] = "Worldwide";
})(DoNotTrack || (DoNotTrack = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var EntityType;
(function (EntityType) {
    EntityType["AUDIENCE"] = "audience";
    EntityType["LOCATION"] = "location";
    EntityType["SEGMENT"] = "segment";
    EntityType["FEATURE"] = "feature";
    EntityType["GOAL"] = "goal";
    EntityType["EXPERIENCE"] = "experience";
    EntityType["VARIATION"] = "variation";
})(EntityType || (EntityType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var FeatureStatus;
(function (FeatureStatus) {
    FeatureStatus["ENABLED"] = "enabled";
    FeatureStatus["DISABLED"] = "disabled";
})(FeatureStatus || (FeatureStatus = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var GoalDataKey;
(function (GoalDataKey) {
    GoalDataKey["AMOUNT"] = "amount";
    GoalDataKey["PRODUCTS_COUNT"] = "productsCount";
    GoalDataKey["TRANSACTION_ID"] = "transactionId";
})(GoalDataKey || (GoalDataKey = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["TRACE"] = 0] = "TRACE";
    LogLevel[LogLevel["DEBUG"] = 1] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
    LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var LogMethod;
(function (LogMethod) {
    LogMethod["LOG"] = "log";
    LogMethod["TRACE"] = "trace";
    LogMethod["DEBUG"] = "debug";
    LogMethod["INFO"] = "info";
    LogMethod["WARN"] = "warn";
    LogMethod["ERROR"] = "error";
})(LogMethod || (LogMethod = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var ProjectType;
(function (ProjectType) {
    ProjectType["WEB"] = "web";
    ProjectType["FULLSTACK"] = "fullstack";
})(ProjectType || (ProjectType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var RuleError;
(function (RuleError) {
    RuleError["NO_DATA_FOUND"] = "convert.com_no_data_found";
    RuleError["NEED_MORE_DATA"] = "convert.com_need_more_data";
})(RuleError || (RuleError = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * SDK system events. Possible values: 'ready' | 'queue-released'
 * or custom visitor's event
 */
var SystemEvents;
(function (SystemEvents) {
    SystemEvents["READY"] = "ready";
    SystemEvents["CONFIG_UPDATED"] = "config.updated";
    SystemEvents["API_QUEUE_RELEASED"] = "api.queue.released";
    SystemEvents["BUCKETING"] = "bucketing";
    SystemEvents["CONVERSION"] = "conversion";
    SystemEvents["SEGMENTS"] = "segments";
    SystemEvents["LOCATION_ACTIVATED"] = "location.activated";
    SystemEvents["LOCATION_DEACTIVATED"] = "location.deactivated";
    SystemEvents["AUDIENCES"] = "audiences";
    SystemEvents["DATA_STORE_QUEUE_RELEASED"] = "datastore.queue.released";
})(SystemEvents || (SystemEvents = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var VariationChangeType;
(function (VariationChangeType) {
    VariationChangeType["RICH_STRUCTURE"] = "richStructure";
    VariationChangeType["CUSTOM_CODE"] = "customCode";
    VariationChangeType["DEFAULT_CODE"] = "defaultCode";
    VariationChangeType["DEFAULT_CODE_MULTIPAGE"] = "defaultCodeMultipage";
    VariationChangeType["DEFAULT_REDIRECT"] = "defaultRedirect";
    VariationChangeType["FULLSTACK_FEATURE"] = "fullStackFeature";
})(VariationChangeType || (VariationChangeType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var BrowserType;
(function (BrowserType) {
    BrowserType["IE"] = "IE";
    BrowserType["CH"] = "CH";
    BrowserType["FF"] = "FF";
    BrowserType["OP"] = "OP";
    BrowserType["SF"] = "SF";
    BrowserType["EDG"] = "EDG";
    BrowserType["MO"] = "MO";
    BrowserType["NS"] = "NS";
    BrowserType["OTH"] = "OTH";
})(BrowserType || (BrowserType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var DeviceType;
(function (DeviceType) {
    DeviceType["ALLPH"] = "ALLPH";
    DeviceType["IPH"] = "IPH";
    DeviceType["OTHPH"] = "OTHPH";
    DeviceType["ALLTAB"] = "ALLTAB";
    DeviceType["IPAD"] = "IPAD";
    DeviceType["OTHTAB"] = "OTHTAB";
    DeviceType["DESK"] = "DESK";
    DeviceType["OTHDEV"] = "OTHDEV";
})(DeviceType || (DeviceType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var SegmentsKeys;
(function (SegmentsKeys) {
    SegmentsKeys["COUNTRY"] = "country";
    SegmentsKeys["BROWSER"] = "browser";
    SegmentsKeys["DEVICES"] = "devices";
    SegmentsKeys["SOURCE"] = "source";
    SegmentsKeys["CAMPAIGN"] = "campaign";
    SegmentsKeys["VISITOR_TYPE"] = "visitorType";
    SegmentsKeys["CUSTOM_SEGMENTS"] = "customSegments";
})(SegmentsKeys || (SegmentsKeys = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var SourceType;
(function (SourceType) {
    SourceType["CAMPAIGN"] = "campaign";
    SourceType["SEARCH"] = "search";
    SourceType["REFERRAL"] = "referral";
    SourceType["DIRECT"] = "direct";
})(SourceType || (SourceType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var VisitorType;
(function (VisitorType) {
    VisitorType["NEW"] = "new";
    VisitorType["RETURNING"] = "returning";
})(VisitorType || (VisitorType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var HttpStatusCode;
(function (HttpStatusCode) {
    HttpStatusCode[HttpStatusCode["Continue"] = 100] = "Continue";
    HttpStatusCode[HttpStatusCode["SwitchingProtocols"] = 101] = "SwitchingProtocols";
    HttpStatusCode[HttpStatusCode["Processing"] = 102] = "Processing";
    HttpStatusCode[HttpStatusCode["EarlyHints"] = 103] = "EarlyHints";
    HttpStatusCode[HttpStatusCode["Ok"] = 200] = "Ok";
    HttpStatusCode[HttpStatusCode["Created"] = 201] = "Created";
    HttpStatusCode[HttpStatusCode["Accepted"] = 202] = "Accepted";
    HttpStatusCode[HttpStatusCode["NonAuthoritativeInformation"] = 203] = "NonAuthoritativeInformation";
    HttpStatusCode[HttpStatusCode["NoContent"] = 204] = "NoContent";
    HttpStatusCode[HttpStatusCode["ResetContent"] = 205] = "ResetContent";
    HttpStatusCode[HttpStatusCode["PartialContent"] = 206] = "PartialContent";
    HttpStatusCode[HttpStatusCode["MultiStatus"] = 207] = "MultiStatus";
    HttpStatusCode[HttpStatusCode["AlreadyReported"] = 208] = "AlreadyReported";
    HttpStatusCode[HttpStatusCode["ImUsed"] = 226] = "ImUsed";
    HttpStatusCode[HttpStatusCode["MultipleChoices"] = 300] = "MultipleChoices";
    HttpStatusCode[HttpStatusCode["MovedPermanently"] = 301] = "MovedPermanently";
    HttpStatusCode[HttpStatusCode["Found"] = 302] = "Found";
    HttpStatusCode[HttpStatusCode["SeeOther"] = 303] = "SeeOther";
    HttpStatusCode[HttpStatusCode["NotModified"] = 304] = "NotModified";
    HttpStatusCode[HttpStatusCode["UseProxy"] = 305] = "UseProxy";
    HttpStatusCode[HttpStatusCode["Unused"] = 306] = "Unused";
    HttpStatusCode[HttpStatusCode["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpStatusCode[HttpStatusCode["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpStatusCode[HttpStatusCode["BadRequest"] = 400] = "BadRequest";
    HttpStatusCode[HttpStatusCode["Unauthorized"] = 401] = "Unauthorized";
    HttpStatusCode[HttpStatusCode["PaymentRequired"] = 402] = "PaymentRequired";
    HttpStatusCode[HttpStatusCode["Forbidden"] = 403] = "Forbidden";
    HttpStatusCode[HttpStatusCode["NotFound"] = 404] = "NotFound";
    HttpStatusCode[HttpStatusCode["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpStatusCode[HttpStatusCode["NotAcceptable"] = 406] = "NotAcceptable";
    HttpStatusCode[HttpStatusCode["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpStatusCode[HttpStatusCode["RequestTimeout"] = 408] = "RequestTimeout";
    HttpStatusCode[HttpStatusCode["Conflict"] = 409] = "Conflict";
    HttpStatusCode[HttpStatusCode["Gone"] = 410] = "Gone";
    HttpStatusCode[HttpStatusCode["LengthRequired"] = 411] = "LengthRequired";
    HttpStatusCode[HttpStatusCode["PreconditionFailed"] = 412] = "PreconditionFailed";
    HttpStatusCode[HttpStatusCode["PayloadTooLarge"] = 413] = "PayloadTooLarge";
    HttpStatusCode[HttpStatusCode["UriTooLong"] = 414] = "UriTooLong";
    HttpStatusCode[HttpStatusCode["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
    HttpStatusCode[HttpStatusCode["RangeNotSatisfiable"] = 416] = "RangeNotSatisfiable";
    HttpStatusCode[HttpStatusCode["ExpectationFailed"] = 417] = "ExpectationFailed";
    HttpStatusCode[HttpStatusCode["ImATeapot"] = 418] = "ImATeapot";
    HttpStatusCode[HttpStatusCode["MisdirectedRequest"] = 421] = "MisdirectedRequest";
    HttpStatusCode[HttpStatusCode["UnprocessableEntity"] = 422] = "UnprocessableEntity";
    HttpStatusCode[HttpStatusCode["Locked"] = 423] = "Locked";
    HttpStatusCode[HttpStatusCode["FailedDependency"] = 424] = "FailedDependency";
    HttpStatusCode[HttpStatusCode["TooEarly"] = 425] = "TooEarly";
    HttpStatusCode[HttpStatusCode["UpgradeRequired"] = 426] = "UpgradeRequired";
    HttpStatusCode[HttpStatusCode["PreconditionRequired"] = 428] = "PreconditionRequired";
    HttpStatusCode[HttpStatusCode["TooManyRequests"] = 429] = "TooManyRequests";
    HttpStatusCode[HttpStatusCode["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
    HttpStatusCode[HttpStatusCode["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
    HttpStatusCode[HttpStatusCode["InternalServerError"] = 500] = "InternalServerError";
    HttpStatusCode[HttpStatusCode["NotImplemented"] = 501] = "NotImplemented";
    HttpStatusCode[HttpStatusCode["BadGateway"] = 502] = "BadGateway";
    HttpStatusCode[HttpStatusCode["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpStatusCode[HttpStatusCode["GatewayTimeout"] = 504] = "GatewayTimeout";
    HttpStatusCode[HttpStatusCode["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
    HttpStatusCode[HttpStatusCode["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
    HttpStatusCode[HttpStatusCode["InsufficientStorage"] = 507] = "InsufficientStorage";
    HttpStatusCode[HttpStatusCode["LoopDetected"] = 508] = "LoopDetected";
    HttpStatusCode[HttpStatusCode["NotExtended"] = 510] = "NotExtended";
    HttpStatusCode[HttpStatusCode["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
})(HttpStatusCode || (HttpStatusCode = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
const DEFAULT_KEYS_CASE_SENSITIVE = true;
const DEFAULT_NEGATION = '!';
/**
 * Provides rule processing calculations with corresponding comparisons methods
 * @category Modules
 * @constructor
 * @implements {RuleManagerInterface}
 */
class RuleManager {
    /**
     * @param {Config=} config
     * @param {Object=} dependencies
     * @param {LogManagerInterface=} dependencies.loggerManager
     */
    constructor(config, { loggerManager } = {}) {
        var _a, _b, _c, _d, _e;
        this._comparisonProcessor = Comparisons;
        this._negation = DEFAULT_NEGATION;
        this._keys_case_sensitive = DEFAULT_KEYS_CASE_SENSITIVE;
        this._loggerManager = loggerManager;
        this._comparisonProcessor =
            ((_a = config === null || config === void 0 ? void 0 : config.rules) === null || _a === void 0 ? void 0 : _a.comparisonProcessor) || Comparisons;
        this._negation = String(((_b = config === null || config === void 0 ? void 0 : config.rules) === null || _b === void 0 ? void 0 : _b.negation) || DEFAULT_NEGATION);
        this._keys_case_sensitive =
            ((_c = config === null || config === void 0 ? void 0 : config.rules) === null || _c === void 0 ? void 0 : _c.keys_case_sensitive) || DEFAULT_KEYS_CASE_SENSITIVE;
        this._mapper = (config === null || config === void 0 ? void 0 : config.mapper) || ((value) => value);
        (_e = (_d = this._loggerManager) === null || _d === void 0 ? void 0 : _d.trace) === null || _e === void 0 ? void 0 : _e.call(_d, 'RuleManager()', MESSAGES.RULE_CONSTRUCTOR, this);
    }
    /**
     * Setter for comparison processor
     * @param {Record<string, any>} comparisonProcessor
     */
    set comparisonProcessor(comparisonProcessor) {
        this._comparisonProcessor = comparisonProcessor;
    }
    /**
     * Getter for comparison processor
     */
    get comparisonProcessor() {
        return this._comparisonProcessor;
    }
    /**
     * Retrieve comparison methods from comparison processor
     * @return {Array<string>} List of methods of comparison processor
     */
    getComparisonProcessorMethods() {
        return Object.getOwnPropertyNames(this._comparisonProcessor).filter((name) => typeof this._comparisonProcessor[name] === 'function');
    }
    /**
     * Check input data matching to rule set
     * @param {Record<string, any>} data Single value or key-value data set to compare
     * @param {RuleObject} ruleSet
     * @return {boolean | RuleError}
     */
    isRuleMatched(data, ruleSet, logEntry) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'RuleManager.isRuleMatched()', this._mapper({
            data: data,
            ruleSet: ruleSet
        }));
        if (logEntry) {
            (_d = (_c = this._loggerManager) === null || _c === void 0 ? void 0 : _c.info) === null || _d === void 0 ? void 0 : _d.call(_c, 'RuleManager.isRuleMatched()', MESSAGES.PROCESSING_ENTITY.replace('#', logEntry));
        }
        // Top OR level
        let match;
        if (Object.prototype.hasOwnProperty.call(ruleSet, 'OR') &&
            arrayNotEmpty(ruleSet === null || ruleSet === void 0 ? void 0 : ruleSet.OR)) {
            for (let i = 0, l = ruleSet.OR.length; i < l; i++) {
                match = this._processAND(data, ruleSet.OR[i]);
                if (match === true) {
                    return match;
                }
                if (Object.values(RuleError).includes(match)) {
                    (_f = (_e = this._loggerManager) === null || _e === void 0 ? void 0 : _e.info) === null || _f === void 0 ? void 0 : _f.call(_e, 'RuleManager.isRuleMatched()', logEntry || '', ERROR_MESSAGES.RULE_ERROR);
                }
                else {
                    (_h = (_g = this._loggerManager) === null || _g === void 0 ? void 0 : _g.info) === null || _h === void 0 ? void 0 : _h.call(_g, 'RuleManager.isRuleMatched()', logEntry || '', match === false
                        ? MESSAGES.RULE_NOT_MATCH
                        : MESSAGES.RULE_MATCH.replace('#', String(i)));
                }
            }
            if (match !== false) {
                return match;
            }
        }
        else {
            (_k = (_j = this._loggerManager) === null || _j === void 0 ? void 0 : _j.warn) === null || _k === void 0 ? void 0 : _k.call(_j, 'RuleManager.isRuleMatched()', logEntry || '', ERROR_MESSAGES.RULE_NOT_VALID);
        }
        return false;
    }
    /**
     * Check is rule object valid
     * @param {RuleElement} rule
     * @return {boolean}
     */
    isValidRule(rule) {
        var _a, _b;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'RuleManager.isValidRule()', this._mapper({
            rule: rule
        }));
        return (Object.prototype.hasOwnProperty.call(rule, 'matching') &&
            typeof rule.matching === 'object' &&
            Object.prototype.hasOwnProperty.call(rule.matching, 'match_type') &&
            typeof rule.matching.match_type === 'string' &&
            Object.prototype.hasOwnProperty.call(rule.matching, 'negated') &&
            typeof rule.matching.negated === 'boolean' &&
            Object.prototype.hasOwnProperty.call(rule, 'value'));
    }
    /**
     * Process AND block of rule set. Return first false if found
     * @param {Record<string, any>} data Single value or key-value data set to compare
     * @param {RuleAnd} rulesSubset
     * @return {boolean | RuleError}
     * @private
     */
    _processAND(data, rulesSubset) {
        var _a, _b, _c, _d;
        // Second AND level
        let match;
        if (Object.prototype.hasOwnProperty.call(rulesSubset, 'AND') &&
            arrayNotEmpty(rulesSubset === null || rulesSubset === void 0 ? void 0 : rulesSubset.AND)) {
            for (let i = 0, l = rulesSubset.AND.length; i < l; i++) {
                match = this._processORWHEN(data, rulesSubset.AND[i]);
                if (match === false) {
                    return false;
                }
            }
            if (match !== false) {
                (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.info) === null || _b === void 0 ? void 0 : _b.call(_a, 'RuleManager._processAND()', MESSAGES.RULE_MATCH_AND);
            }
            return match;
        }
        else {
            (_d = (_c = this._loggerManager) === null || _c === void 0 ? void 0 : _c.warn) === null || _d === void 0 ? void 0 : _d.call(_c, 'RuleManager._processAND()', ERROR_MESSAGES.RULE_NOT_VALID);
        }
        return false;
    }
    /**
     * Process OR block of rule set. Return first true if found
     * @param {Record<string, any>} data Single value or key-value data set to compare
     * @param {RuleOrWhen} rulesSubset
     * @return {boolean | RuleError}
     * @private
     */
    _processORWHEN(data, rulesSubset) {
        var _a, _b;
        // Third OR level. Called OR_WHEN.
        let match;
        if (Object.prototype.hasOwnProperty.call(rulesSubset, 'OR_WHEN') &&
            arrayNotEmpty(rulesSubset === null || rulesSubset === void 0 ? void 0 : rulesSubset.OR_WHEN)) {
            for (let i = 0, l = rulesSubset.OR_WHEN.length; i < l; i++) {
                match = this._processRuleItem(data, rulesSubset.OR_WHEN[i]);
                if (match === true) {
                    return match;
                }
            }
            if (match !== false) {
                return match;
            }
        }
        else {
            (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.warn) === null || _b === void 0 ? void 0 : _b.call(_a, 'RuleManager._processORWHEN()', ERROR_MESSAGES.RULE_NOT_VALID);
        }
        return false;
    }
    /**
     * Process single rule item
     * @param {Record<string, any>} data Single value or key-value data set to compare
     * @param {RuleElement} rule A single rule to compare
     * @return {boolean | RuleError} Comparison result
     * @private
     */
    _processRuleItem(data, rule) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        if (this.isValidRule(rule)) {
            try {
                const negation = rule.matching.negated || false;
                const matching = rule.matching.match_type;
                if (this.getComparisonProcessorMethods().indexOf(matching) !== -1) {
                    if (data && typeof data === 'object') {
                        // Validate data key-value set.
                        if (this.isUsingCustomInterface(data)) {
                            // RuleElement object has to have `rule_type` field
                            if (rule === null || rule === void 0 ? void 0 : rule.rule_type) {
                                (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.info) === null || _b === void 0 ? void 0 : _b.call(_a, 'RuleManager._processRuleItem()', MESSAGES.RULE_MATCH_START.replace('#', rule.rule_type));
                                for (const method of Object.getOwnPropertyNames(data.constructor.prototype)) {
                                    if (method === 'constructor')
                                        continue;
                                    const rule_method = camelCase(`get ${rule.rule_type.replace(/_/g, ' ')}`);
                                    if (method === rule_method ||
                                        ((_c = data === null || data === void 0 ? void 0 : data.mapper) === null || _c === void 0 ? void 0 : _c.call(data, method)) === rule_method) {
                                        const dataValue = data[method](rule);
                                        if (Object.values(RuleError).includes(dataValue))
                                            return dataValue;
                                        if (rule.rule_type === 'js_condition')
                                            return dataValue;
                                        return this._comparisonProcessor[matching](dataValue, rule.value, negation);
                                    }
                                }
                            }
                        }
                        else if (objectNotEmpty(data)) {
                            // only handle RuleElement with a `key` field
                            for (const key of Object.keys(data)) {
                                const k = this._keys_case_sensitive ? key : key.toLowerCase();
                                const rule_k = this._keys_case_sensitive
                                    ? rule['key']
                                    : String(rule['key']).toLowerCase();
                                if (k === rule_k) {
                                    return this._comparisonProcessor[matching](data[key], rule.value, negation);
                                }
                            }
                        }
                        else {
                            (_e = (_d = this._loggerManager) === null || _d === void 0 ? void 0 : _d.trace) === null || _e === void 0 ? void 0 : _e.call(_d, 'RuleManager._processRuleItem()', {
                                warn: ERROR_MESSAGES.RULE_DATA_NOT_VALID,
                                data
                            });
                        }
                    }
                    else {
                        (_g = (_f = this._loggerManager) === null || _f === void 0 ? void 0 : _f.trace) === null || _g === void 0 ? void 0 : _g.call(_f, 'RuleManager._processRuleItem()', {
                            warn: ERROR_MESSAGES.RULE_NOT_VALID,
                            data,
                            rule
                        });
                    }
                }
                else {
                    (_j = (_h = this._loggerManager) === null || _h === void 0 ? void 0 : _h.warn) === null || _j === void 0 ? void 0 : _j.call(_h, 'RuleManager._processRuleItem()', ERROR_MESSAGES.RULE_MATCH_TYPE_NOT_SUPPORTED.replace('#', matching));
                }
            }
            catch (error) {
                (_l = (_k = this._loggerManager) === null || _k === void 0 ? void 0 : _k.error) === null || _l === void 0 ? void 0 : _l.call(_k, 'RuleManager._processRuleItem()', {
                    error: error.message
                });
            }
        }
        else {
            (_o = (_m = this._loggerManager) === null || _m === void 0 ? void 0 : _m.warn) === null || _o === void 0 ? void 0 : _o.call(_m, 'RuleManager._processRuleItem()', ERROR_MESSAGES.RULE_NOT_VALID);
        }
        return false;
    }
    /**
     * Check is rule data object is a custom interface instead of a literal object
     * @param {Record<string, any>} data Single value or key-value data set to compare
     * @return {boolean}
     */
    isUsingCustomInterface(data) {
        return (objectNotEmpty(data) &&
            Object.prototype.hasOwnProperty.call(data, 'name') &&
            data.name === 'RuleData');
    }
}

exports.RuleManager = RuleManager;
//# sourceMappingURL=index.js.map
