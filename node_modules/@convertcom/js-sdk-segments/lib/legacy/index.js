'use strict';

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var BucketingError;
(function (BucketingError) {
    BucketingError["VARIAION_NOT_DECIDED"] = "convert.com_variation_not_decided";
})(BucketingError || (BucketingError = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var ConversionSettingKey;
(function (ConversionSettingKey) {
    ConversionSettingKey["FORCE_MULTIPLE_TRANSACTIONS"] = "forceMultipleTransactions";
})(ConversionSettingKey || (ConversionSettingKey = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
const MESSAGES = {
    CONFIG_DATA_UPDATED: 'Config Data updated',
    CORE_CONSTRUCTOR: 'Core Manager constructor has been called',
    CORE_INITIALIZED: 'Core Manager has been initialized',
    EXPERIENCE_CONSTRUCTOR: 'Experience Manager constructor has been called',
    EXPERIENCE_NOT_FOUND: 'Experience not found',
    EXPERIENCE_ARCHIVED: 'Experience archived',
    EXPERIENCE_ENVIRONMENT_NOT_MATCH: 'Experience environment does not match',
    EXPERIENCE_RULES_MATCHED: 'Experience rules matched',
    VARIATIONS_NOT_FOUND: 'Variations not found',
    VARIATION_CHANGE_NOT_SUPPORTED: 'Variation change not supported',
    FEATURE_CONSTRUCTOR: 'Feature Manager constructor has been called',
    FEATURE_NOT_FOUND: 'Fullstack Feature not found',
    FEATURE_VARIABLES_NOT_FOUND: 'Fullstack Feature Variables not found',
    FEATURE_VARIABLES_TYPE_NOT_FOUND: 'Fullstack Feature Variables Type not found',
    BUCKETING_CONSTRUCTOR: 'Bucketing Manager constructor has been called',
    DATA_CONSTRUCTOR: 'Data Manager constructor has been called',
    RULE_CONSTRUCTOR: 'Rule Manager constructor has been called',
    PROCESSING_ENTITY: 'Processing #',
    LOCATION_MATCH: 'Location # rule matched',
    LOCATION_NOT_MATCH: 'Location does not match',
    LOCATION_NOT_RESTRICTED: 'Location not restricted',
    AUDIENCE_MATCH: 'Audience # rule matched',
    AUDIENCE_NOT_MATCH: 'Audience does not match',
    NON_PERMANENT_AUDIENCE_NOT_RESTRICTED: 'Non-Permanent Audience not restricted',
    AUDIENCE_NOT_RESTRICTED: 'Audience not restricted',
    SEGMENTATION_MATCH: 'Segmentation # rule matched',
    SEGMENTATION_NOT_RESTRICTED: 'Segmentation not restricted',
    RULE_NOT_MATCH: 'Rule does not match',
    RULE_MATCH: 'Found matched rule at OR block #',
    RULE_MATCH_AND: 'AND block rule macthed',
    RULE_MATCH_START: 'About to evaluate rule #',
    LOCATION_ACTIVATED: 'Location # activated',
    LOCATION_DEACTIVATED: 'Location # deactivated',
    BUCKETED_VISITOR_FOUND: 'Visitor is already bucketed for variation #',
    BUCKETED_VISITOR_FORCED: 'Forcing variation #',
    BUCKETED_VISITOR: 'Visitor is bucketed for variation #',
    GOAL_NOT_FOUND: 'Goal not found',
    GOAL_RULE_NOT_MATCH: 'Goal rule do not match',
    GOAL_FOUND: 'Goal # already triggered',
    SEGMENTS_NOT_FOUND: 'Segments not found',
    SEGMENTS_RULE_NOT_MATCH: 'Segments rule do not match',
    CUSTOM_SEGMENTS_KEY_FOUND: 'Custom segments key already set',
    SEND_BEACON_SUCCESS: 'The user agent successfully queued the data for transfer',
    RELEASING_QUEUE: 'Releasing event queue...'
};

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var DoNotTrack;
(function (DoNotTrack) {
    DoNotTrack["OFF"] = "OFF";
    DoNotTrack["EU_ONLY"] = "EU ONLY";
    DoNotTrack["EEA_ONLY"] = "EEA ONLY";
    DoNotTrack["WORLDWIDE"] = "Worldwide";
})(DoNotTrack || (DoNotTrack = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var EntityType;
(function (EntityType) {
    EntityType["AUDIENCE"] = "audience";
    EntityType["LOCATION"] = "location";
    EntityType["SEGMENT"] = "segment";
    EntityType["FEATURE"] = "feature";
    EntityType["GOAL"] = "goal";
    EntityType["EXPERIENCE"] = "experience";
    EntityType["VARIATION"] = "variation";
})(EntityType || (EntityType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var FeatureStatus;
(function (FeatureStatus) {
    FeatureStatus["ENABLED"] = "enabled";
    FeatureStatus["DISABLED"] = "disabled";
})(FeatureStatus || (FeatureStatus = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var GoalDataKey;
(function (GoalDataKey) {
    GoalDataKey["AMOUNT"] = "amount";
    GoalDataKey["PRODUCTS_COUNT"] = "productsCount";
    GoalDataKey["TRANSACTION_ID"] = "transactionId";
})(GoalDataKey || (GoalDataKey = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["TRACE"] = 0] = "TRACE";
    LogLevel[LogLevel["DEBUG"] = 1] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
    LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var LogMethod;
(function (LogMethod) {
    LogMethod["LOG"] = "log";
    LogMethod["TRACE"] = "trace";
    LogMethod["DEBUG"] = "debug";
    LogMethod["INFO"] = "info";
    LogMethod["WARN"] = "warn";
    LogMethod["ERROR"] = "error";
})(LogMethod || (LogMethod = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var ProjectType;
(function (ProjectType) {
    ProjectType["WEB"] = "web";
    ProjectType["FULLSTACK"] = "fullstack";
})(ProjectType || (ProjectType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var RuleError;
(function (RuleError) {
    RuleError["NO_DATA_FOUND"] = "convert.com_no_data_found";
    RuleError["NEED_MORE_DATA"] = "convert.com_need_more_data";
})(RuleError || (RuleError = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * SDK system events. Possible values: 'ready' | 'queue-released'
 * or custom visitor's event
 */
var SystemEvents;
(function (SystemEvents) {
    SystemEvents["READY"] = "ready";
    SystemEvents["CONFIG_UPDATED"] = "config.updated";
    SystemEvents["API_QUEUE_RELEASED"] = "api.queue.released";
    SystemEvents["BUCKETING"] = "bucketing";
    SystemEvents["CONVERSION"] = "conversion";
    SystemEvents["SEGMENTS"] = "segments";
    SystemEvents["LOCATION_ACTIVATED"] = "location.activated";
    SystemEvents["LOCATION_DEACTIVATED"] = "location.deactivated";
    SystemEvents["AUDIENCES"] = "audiences";
    SystemEvents["DATA_STORE_QUEUE_RELEASED"] = "datastore.queue.released";
})(SystemEvents || (SystemEvents = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var VariationChangeType;
(function (VariationChangeType) {
    VariationChangeType["RICH_STRUCTURE"] = "richStructure";
    VariationChangeType["CUSTOM_CODE"] = "customCode";
    VariationChangeType["DEFAULT_CODE"] = "defaultCode";
    VariationChangeType["DEFAULT_CODE_MULTIPAGE"] = "defaultCodeMultipage";
    VariationChangeType["DEFAULT_REDIRECT"] = "defaultRedirect";
    VariationChangeType["FULLSTACK_FEATURE"] = "fullStackFeature";
})(VariationChangeType || (VariationChangeType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var BrowserType;
(function (BrowserType) {
    BrowserType["IE"] = "IE";
    BrowserType["CH"] = "CH";
    BrowserType["FF"] = "FF";
    BrowserType["OP"] = "OP";
    BrowserType["SF"] = "SF";
    BrowserType["EDG"] = "EDG";
    BrowserType["MO"] = "MO";
    BrowserType["NS"] = "NS";
    BrowserType["OTH"] = "OTH";
})(BrowserType || (BrowserType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var DeviceType;
(function (DeviceType) {
    DeviceType["ALLPH"] = "ALLPH";
    DeviceType["IPH"] = "IPH";
    DeviceType["OTHPH"] = "OTHPH";
    DeviceType["ALLTAB"] = "ALLTAB";
    DeviceType["IPAD"] = "IPAD";
    DeviceType["OTHTAB"] = "OTHTAB";
    DeviceType["DESK"] = "DESK";
    DeviceType["OTHDEV"] = "OTHDEV";
})(DeviceType || (DeviceType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var SegmentsKeys;
(function (SegmentsKeys) {
    SegmentsKeys["COUNTRY"] = "country";
    SegmentsKeys["BROWSER"] = "browser";
    SegmentsKeys["DEVICES"] = "devices";
    SegmentsKeys["SOURCE"] = "source";
    SegmentsKeys["CAMPAIGN"] = "campaign";
    SegmentsKeys["VISITOR_TYPE"] = "visitorType";
    SegmentsKeys["CUSTOM_SEGMENTS"] = "customSegments";
})(SegmentsKeys || (SegmentsKeys = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var SourceType;
(function (SourceType) {
    SourceType["CAMPAIGN"] = "campaign";
    SourceType["SEARCH"] = "search";
    SourceType["REFERRAL"] = "referral";
    SourceType["DIRECT"] = "direct";
})(SourceType || (SourceType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var VisitorType;
(function (VisitorType) {
    VisitorType["NEW"] = "new";
    VisitorType["RETURNING"] = "returning";
})(VisitorType || (VisitorType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * Returns the value at path of object
 * TODO: get this utility to work with the optional mapper() helper from config
 * @param {Record<string, any>} object
 * @param {string} path
 * @param {any=} defaultValue
 * @param {boolean=} truthy Should Number 0 number and Boolean false be considered as normal value
 * @return {any}
 */
function objectDeepValue(object, path, defaultValue, truthy = false) {
    try {
        if (typeof object === 'object') {
            const v = path.split('.').reduce((a, v) => a[v], object);
            if (v || (truthy && (v === false || v === 0))) {
                return v;
            }
        }
        // eslint-disable-next-line no-empty
    }
    catch (e) { }
    {
        return null;
    }
}
/**
 * Validates variable is object and not empty
 * @param object
 */
function objectNotEmpty(object) {
    return (typeof object === 'object' &&
        object !== null &&
        Object.keys(object).length > 0);
}

var murmurhash = {exports: {}};

(function (module) {
  (function () {
    const createBuffer = val => new TextEncoder().encode(val);

    /**
     * JS Implementation of MurmurHash2
     *
     * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
     * @see http://github.com/garycourt/murmurhash-js
     * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
     * @see http://sites.google.com/site/murmurhash/
     *
     * @param {Uint8Array | string} str ASCII only
     * @param {number} seed Positive integer only
     * @return {number} 32-bit positive integer hash
     */
    function MurmurHashV2(str, seed) {
      if (typeof str === 'string') str = createBuffer(str);
      let l = str.length,
        h = seed ^ l,
        i = 0,
        k;
      while (l >= 4) {
        k = str[i] & 0xff | (str[++i] & 0xff) << 8 | (str[++i] & 0xff) << 16 | (str[++i] & 0xff) << 24;
        k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
        k ^= k >>> 24;
        k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
        h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16) ^ k;
        l -= 4;
        ++i;
      }
      switch (l) {
        case 3:
          h ^= (str[i + 2] & 0xff) << 16;
        case 2:
          h ^= (str[i + 1] & 0xff) << 8;
        case 1:
          h ^= str[i] & 0xff;
          h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
      }
      h ^= h >>> 13;
      h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
      h ^= h >>> 15;
      return h >>> 0;
    }

    /*
     * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)
     *
     * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
     * @see http://github.com/garycourt/murmurhash-js
     * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
     * @see http://sites.google.com/site/murmurhash/
     *
     * @param {Uint8Array | string} key ASCII only
     * @param {number} seed Positive integer only
     * @return {number} 32-bit positive integer hash
     */
    function MurmurHashV3(key, seed) {
      if (typeof key === 'string') key = createBuffer(key);
      let remainder, bytes, h1, h1b, c1, c2, k1, i;
      remainder = key.length & 3; // key.length % 4
      bytes = key.length - remainder;
      h1 = seed;
      c1 = 0xcc9e2d51;
      c2 = 0x1b873593;
      i = 0;
      while (i < bytes) {
        k1 = key[i] & 0xff | (key[++i] & 0xff) << 8 | (key[++i] & 0xff) << 16 | (key[++i] & 0xff) << 24;
        ++i;
        k1 = (k1 & 0xffff) * c1 + (((k1 >>> 16) * c1 & 0xffff) << 16) & 0xffffffff;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = (k1 & 0xffff) * c2 + (((k1 >>> 16) * c2 & 0xffff) << 16) & 0xffffffff;
        h1 ^= k1;
        h1 = h1 << 13 | h1 >>> 19;
        h1b = (h1 & 0xffff) * 5 + (((h1 >>> 16) * 5 & 0xffff) << 16) & 0xffffffff;
        h1 = (h1b & 0xffff) + 0x6b64 + (((h1b >>> 16) + 0xe654 & 0xffff) << 16);
      }
      k1 = 0;
      switch (remainder) {
        case 3:
          k1 ^= (key[i + 2] & 0xff) << 16;
        case 2:
          k1 ^= (key[i + 1] & 0xff) << 8;
        case 1:
          k1 ^= key[i] & 0xff;
          k1 = (k1 & 0xffff) * c1 + (((k1 >>> 16) * c1 & 0xffff) << 16) & 0xffffffff;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = (k1 & 0xffff) * c2 + (((k1 >>> 16) * c2 & 0xffff) << 16) & 0xffffffff;
          h1 ^= k1;
      }
      h1 ^= key.length;
      h1 ^= h1 >>> 16;
      h1 = (h1 & 0xffff) * 0x85ebca6b + (((h1 >>> 16) * 0x85ebca6b & 0xffff) << 16) & 0xffffffff;
      h1 ^= h1 >>> 13;
      h1 = (h1 & 0xffff) * 0xc2b2ae35 + (((h1 >>> 16) * 0xc2b2ae35 & 0xffff) << 16) & 0xffffffff;
      h1 ^= h1 >>> 16;
      return h1 >>> 0;
    }
    const murmur = MurmurHashV3;
    murmur.v2 = MurmurHashV2;
    murmur.v3 = MurmurHashV3;
    {
      module.exports = murmur;
    }
  })();
})(murmurhash);

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * Check if a value is numeric
 * @param {string | number} value
 * @returns {boolean}
 */
function isNumeric(value) {
    if (typeof value === 'number') {
        return true;
    }
    const number = parseFloat(String(value));
    return Number.isFinite(number) && !isNaN(number);
}
/**
 * Convert a string to a number
 * @param {string | number} value
 * @returns {number}
 */
function toNumber(value) {
    if (typeof value === 'number') {
        return value;
    }
    const parts = String(value).split(',');
    return parseFloat(parts[0] == '0'
        ? String(value).replace(/,/g, '.')
        : String(value).replace(/,/g, ''));
}

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var _a;
/**
 * Comparison Processor. Provides comparison methods for rules validation
 */
class Comparisons {
    static equals(value, testAgainst, negation) {
        if (Array.isArray(value))
            return this._returnNegationCheck(value.indexOf(testAgainst) !== -1, negation);
        if (objectNotEmpty(value))
            return this._returnNegationCheck(Object.keys(value).indexOf(String(testAgainst)) !== -1, negation);
        value = String(value);
        testAgainst = String(testAgainst);
        value = value.valueOf().toLowerCase();
        testAgainst = testAgainst.valueOf().toLowerCase();
        return this._returnNegationCheck(value === testAgainst, negation);
    }
    static less(value, testAgainst, negation) {
        value = isNumeric(value) ? toNumber(value) : value;
        testAgainst = isNumeric(testAgainst) ? toNumber(testAgainst) : testAgainst;
        if (typeof value !== typeof testAgainst) {
            return false;
        }
        return this._returnNegationCheck(value < testAgainst, negation);
    }
    static lessEqual(value, testAgainst, negation) {
        value = isNumeric(value) ? toNumber(value) : value;
        testAgainst = isNumeric(testAgainst) ? toNumber(testAgainst) : testAgainst;
        if (typeof value !== typeof testAgainst) {
            return false;
        }
        return this._returnNegationCheck(value <= testAgainst, negation);
    }
    static contains(value, testAgainst, negation) {
        value = String(value);
        testAgainst = String(testAgainst);
        value = value.valueOf().toLowerCase();
        testAgainst = testAgainst.valueOf().toLowerCase();
        if (testAgainst.replace(/^([\s]*)|([\s]*)$/g, '').length === 0) {
            return this._returnNegationCheck(true, negation);
        }
        return this._returnNegationCheck(value.indexOf(testAgainst) !== -1, negation);
    }
    static isIn(values, testAgainst, negation = false, splitter = '|') {
        const matchedValuesArray = String(values)
            .split(splitter)
            .map((item) => {
            return String(item);
        });
        if (typeof testAgainst === 'string') {
            testAgainst = testAgainst.split(splitter);
        }
        if (!Array.isArray(testAgainst)) {
            testAgainst = [];
        }
        testAgainst = testAgainst.map((item) => {
            return String(item).valueOf().toLowerCase();
        });
        for (let i = 0; i < matchedValuesArray.length; i++) {
            if (testAgainst.indexOf(matchedValuesArray[i]) !== -1) {
                return this._returnNegationCheck(true, negation);
            }
        }
        return this._returnNegationCheck(false, negation);
    }
    static startsWith(value, testAgainst, negation) {
        value = String(value).valueOf().toLowerCase();
        testAgainst = String(testAgainst).valueOf().toLowerCase();
        return this._returnNegationCheck(value.indexOf(testAgainst) === 0, negation);
    }
    static endsWith(value, testAgainst, negation) {
        value = String(value).valueOf().toLowerCase();
        testAgainst = String(testAgainst).valueOf().toLowerCase();
        return this._returnNegationCheck(value.indexOf(testAgainst, value.length - testAgainst.length) !== -1, negation);
    }
    static regexMatches(value, testAgainst, negation) {
        value = String(value).valueOf().toLowerCase();
        testAgainst = String(testAgainst).valueOf();
        const regExp = new RegExp(testAgainst, 'i');
        return this._returnNegationCheck(regExp.test(value), negation);
    }
    static _returnNegationCheck(value, negation = false) {
        if (negation) {
            return !value;
        }
        else {
            return value;
        }
    }
}
_a = Comparisons;
Comparisons.equalsNumber = _a.equals;
Comparisons.matches = _a.equals;

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var HttpStatusCode;
(function (HttpStatusCode) {
    HttpStatusCode[HttpStatusCode["Continue"] = 100] = "Continue";
    HttpStatusCode[HttpStatusCode["SwitchingProtocols"] = 101] = "SwitchingProtocols";
    HttpStatusCode[HttpStatusCode["Processing"] = 102] = "Processing";
    HttpStatusCode[HttpStatusCode["EarlyHints"] = 103] = "EarlyHints";
    HttpStatusCode[HttpStatusCode["Ok"] = 200] = "Ok";
    HttpStatusCode[HttpStatusCode["Created"] = 201] = "Created";
    HttpStatusCode[HttpStatusCode["Accepted"] = 202] = "Accepted";
    HttpStatusCode[HttpStatusCode["NonAuthoritativeInformation"] = 203] = "NonAuthoritativeInformation";
    HttpStatusCode[HttpStatusCode["NoContent"] = 204] = "NoContent";
    HttpStatusCode[HttpStatusCode["ResetContent"] = 205] = "ResetContent";
    HttpStatusCode[HttpStatusCode["PartialContent"] = 206] = "PartialContent";
    HttpStatusCode[HttpStatusCode["MultiStatus"] = 207] = "MultiStatus";
    HttpStatusCode[HttpStatusCode["AlreadyReported"] = 208] = "AlreadyReported";
    HttpStatusCode[HttpStatusCode["ImUsed"] = 226] = "ImUsed";
    HttpStatusCode[HttpStatusCode["MultipleChoices"] = 300] = "MultipleChoices";
    HttpStatusCode[HttpStatusCode["MovedPermanently"] = 301] = "MovedPermanently";
    HttpStatusCode[HttpStatusCode["Found"] = 302] = "Found";
    HttpStatusCode[HttpStatusCode["SeeOther"] = 303] = "SeeOther";
    HttpStatusCode[HttpStatusCode["NotModified"] = 304] = "NotModified";
    HttpStatusCode[HttpStatusCode["UseProxy"] = 305] = "UseProxy";
    HttpStatusCode[HttpStatusCode["Unused"] = 306] = "Unused";
    HttpStatusCode[HttpStatusCode["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpStatusCode[HttpStatusCode["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpStatusCode[HttpStatusCode["BadRequest"] = 400] = "BadRequest";
    HttpStatusCode[HttpStatusCode["Unauthorized"] = 401] = "Unauthorized";
    HttpStatusCode[HttpStatusCode["PaymentRequired"] = 402] = "PaymentRequired";
    HttpStatusCode[HttpStatusCode["Forbidden"] = 403] = "Forbidden";
    HttpStatusCode[HttpStatusCode["NotFound"] = 404] = "NotFound";
    HttpStatusCode[HttpStatusCode["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpStatusCode[HttpStatusCode["NotAcceptable"] = 406] = "NotAcceptable";
    HttpStatusCode[HttpStatusCode["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpStatusCode[HttpStatusCode["RequestTimeout"] = 408] = "RequestTimeout";
    HttpStatusCode[HttpStatusCode["Conflict"] = 409] = "Conflict";
    HttpStatusCode[HttpStatusCode["Gone"] = 410] = "Gone";
    HttpStatusCode[HttpStatusCode["LengthRequired"] = 411] = "LengthRequired";
    HttpStatusCode[HttpStatusCode["PreconditionFailed"] = 412] = "PreconditionFailed";
    HttpStatusCode[HttpStatusCode["PayloadTooLarge"] = 413] = "PayloadTooLarge";
    HttpStatusCode[HttpStatusCode["UriTooLong"] = 414] = "UriTooLong";
    HttpStatusCode[HttpStatusCode["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
    HttpStatusCode[HttpStatusCode["RangeNotSatisfiable"] = 416] = "RangeNotSatisfiable";
    HttpStatusCode[HttpStatusCode["ExpectationFailed"] = 417] = "ExpectationFailed";
    HttpStatusCode[HttpStatusCode["ImATeapot"] = 418] = "ImATeapot";
    HttpStatusCode[HttpStatusCode["MisdirectedRequest"] = 421] = "MisdirectedRequest";
    HttpStatusCode[HttpStatusCode["UnprocessableEntity"] = 422] = "UnprocessableEntity";
    HttpStatusCode[HttpStatusCode["Locked"] = 423] = "Locked";
    HttpStatusCode[HttpStatusCode["FailedDependency"] = 424] = "FailedDependency";
    HttpStatusCode[HttpStatusCode["TooEarly"] = 425] = "TooEarly";
    HttpStatusCode[HttpStatusCode["UpgradeRequired"] = 426] = "UpgradeRequired";
    HttpStatusCode[HttpStatusCode["PreconditionRequired"] = 428] = "PreconditionRequired";
    HttpStatusCode[HttpStatusCode["TooManyRequests"] = 429] = "TooManyRequests";
    HttpStatusCode[HttpStatusCode["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
    HttpStatusCode[HttpStatusCode["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
    HttpStatusCode[HttpStatusCode["InternalServerError"] = 500] = "InternalServerError";
    HttpStatusCode[HttpStatusCode["NotImplemented"] = 501] = "NotImplemented";
    HttpStatusCode[HttpStatusCode["BadGateway"] = 502] = "BadGateway";
    HttpStatusCode[HttpStatusCode["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpStatusCode[HttpStatusCode["GatewayTimeout"] = 504] = "GatewayTimeout";
    HttpStatusCode[HttpStatusCode["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
    HttpStatusCode[HttpStatusCode["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
    HttpStatusCode[HttpStatusCode["InsufficientStorage"] = 507] = "InsufficientStorage";
    HttpStatusCode[HttpStatusCode["LoopDetected"] = 508] = "LoopDetected";
    HttpStatusCode[HttpStatusCode["NotExtended"] = 510] = "NotExtended";
    HttpStatusCode[HttpStatusCode["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
})(HttpStatusCode || (HttpStatusCode = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * Provides segments specific logic
 * @category Modules
 * @constructor
 * @implements {SegmentsManagerInterface}
 */
class SegmentsManager {
    /**
     * @param {Config} config
     * @param {Object} dependencies
     * @param {DataManagerInterface=} dependencies.dataManager
     * @param {RuleManagerInterface=} dependencies.ruleManager
     * @param {LogManagerInterface=} dependencies.loggerManager
     */
    constructor(config, { dataManager, ruleManager, loggerManager }) {
        this._dataManager = dataManager;
        this._ruleManager = ruleManager;
        this._loggerManager = loggerManager;
        this._data = objectDeepValue(config, 'data');
    }
    /**
     * Get segments in DataStore
     * @param {string} visitorId
     * @returns {VisitorSegments}
     */
    getSegments(visitorId) {
        const storeData = this._dataManager.getData(visitorId) || {};
        const { segments } = this._dataManager.filterReportSegments(storeData === null || storeData === void 0 ? void 0 : storeData.segments);
        return segments;
    }
    /**
     * Update segments in DataStore
     * @param {string} visitorId
     * @param {VisitorSegments} segments
     */
    putSegments(visitorId, segments) {
        const { segments: reportSegments } = this._dataManager.filterReportSegments(segments);
        if (reportSegments) {
            // Store the data
            this._dataManager.putData(visitorId, { segments: reportSegments });
        }
    }
    setCustomSegments(visitorId, segments, segmentRule) {
        var _a, _b, _c, _d, _e;
        const storeData = this._dataManager.getData(visitorId) || {};
        // Get custom segments ID from DataStore
        const { segments: { [SegmentsKeys.CUSTOM_SEGMENTS]: customSegments = [] } = {} } = storeData;
        const segmentIds = [];
        let segmentsMatched = false;
        for (const segment of segments) {
            if (segmentRule && !segmentsMatched) {
                segmentsMatched = this._ruleManager.isRuleMatched(segmentRule, segment === null || segment === void 0 ? void 0 : segment.rules, `ConfigSegment #${segment === null || segment === void 0 ? void 0 : segment.id}`);
                // Return rule errors if present
                if (Object.values(RuleError).includes(segmentsMatched))
                    return segmentsMatched;
            }
            if (!segmentRule || segmentsMatched) {
                const segmentId = (_a = segment === null || segment === void 0 ? void 0 : segment.id) === null || _a === void 0 ? void 0 : _a.toString();
                if (customSegments.includes(segmentId)) {
                    (_c = (_b = this._loggerManager) === null || _b === void 0 ? void 0 : _b.warn) === null || _c === void 0 ? void 0 : _c.call(_b, 'SegmentsManager.setCustomSegments()', MESSAGES.CUSTOM_SEGMENTS_KEY_FOUND);
                }
                else {
                    segmentIds.push(segmentId);
                }
            }
        }
        let segmentsData;
        if (segmentIds.length) {
            segmentsData = Object.assign(Object.assign({}, (storeData.segments || {})), { [SegmentsKeys.CUSTOM_SEGMENTS]: [...customSegments, ...segmentIds] });
            // Merge custom segments ID into DataStore
            this.putSegments(visitorId, segmentsData);
        }
        else {
            (_e = (_d = this._loggerManager) === null || _d === void 0 ? void 0 : _d.warn) === null || _e === void 0 ? void 0 : _e.call(_d, 'SegmentsManager.setCustomSegments()', MESSAGES.SEGMENTS_NOT_FOUND);
        }
        return segmentsData;
    }
    /**
     * Update custom segments for specific visitor
     * @param {string} visitorId
     * @param {Array<string>} segmentKeys A list of segment keys
     * @param {Record<string, any>=} segmentRule An object of key-value pairs that are used for segments matching
     * @param {string=} environment
     * @return {VisitorSegments | RuleError}
     */
    selectCustomSegments(visitorId, segmentKeys, segmentRule) {
        const segments = this._dataManager.getEntities(segmentKeys, 'segments');
        return this.setCustomSegments(visitorId, segments, segmentRule);
    }
    /**
     * Update custom segments for specific visitor
     * @param {string} visitorId
     * @param {Array<string>} segmentIds A list of segment ids
     * @param {Record<string, any>=} segmentRule An object of key-value pairs that are used for segments matching
     * @param {string=} environment
     * @return {VisitorSegments | RuleError}
     */
    selectCustomSegmentsByIds(visitorId, segmentIds, segmentRule) {
        const segments = this._dataManager.getEntitiesByIds(segmentIds, 'segments');
        return this.setCustomSegments(visitorId, segments, segmentRule);
    }
}

exports.SegmentsManager = SegmentsManager;
//# sourceMappingURL=index.js.map
