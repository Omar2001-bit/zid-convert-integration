/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var BucketingError;
(function (BucketingError) {
    BucketingError["VARIAION_NOT_DECIDED"] = "convert.com_variation_not_decided";
})(BucketingError || (BucketingError = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var ConversionSettingKey;
(function (ConversionSettingKey) {
    ConversionSettingKey["FORCE_MULTIPLE_TRANSACTIONS"] = "forceMultipleTransactions";
})(ConversionSettingKey || (ConversionSettingKey = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
const DATA_ENTITIES = [
    'events',
    'goals',
    'audiences',
    'locations',
    'segments',
    'experiences',
    'archived_experiences',
    'experiences.variations',
    'features',
    'features.variables'
];
const DATA_ENTITIES_MAP = {
    goal: 'goals',
    audience: 'audiences',
    location: 'locations',
    segment: 'segments',
    experience: 'experiences',
    variation: 'experiences.variations',
    feature: 'features'
};

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
const ERROR_MESSAGES = {
    SDK_KEY_MISSING: 'SDK key is missing',
    DATA_OBJECT_MISSING: 'Data object is missing',
    CONFIG_DATA_NOT_VALID: 'Config Data is not valid',
    SDK_OR_DATA_OBJECT_REQUIRED: 'SDK key or Data object should be provided',
    RULE_NOT_VALID: 'Provided rule is not valid',
    RULE_DATA_NOT_VALID: 'Provided rule data is not valid',
    RULE_MATCH_TYPE_NOT_SUPPORTED: 'Provided rule matching type "#" is not supported',
    RULE_ERROR: 'Rule error',
    DATA_STORE_NOT_VALID: 'DataStore object is not valid. It should contain get and set methods',
    VISITOR_ID_REQUIRED: 'Visitor string string is not present',
    GOAL_DATA_NOT_VALID: 'GoalData object is not valid',
    UNABLE_TO_SELECT_BUCKET_FOR_VISITOR: 'Unable to bucket visitor',
    UNABLE_TO_PERFORM_NETWORK_REQUEST: 'Unable to perform network request',
    UNSUPPORTED_RESPONSE_TYPE: 'Unsupported response type'
};
const MESSAGES = {
    CONFIG_DATA_UPDATED: 'Config Data updated',
    CORE_CONSTRUCTOR: 'Core Manager constructor has been called',
    CORE_INITIALIZED: 'Core Manager has been initialized',
    EXPERIENCE_CONSTRUCTOR: 'Experience Manager constructor has been called',
    EXPERIENCE_NOT_FOUND: 'Experience not found',
    EXPERIENCE_ARCHIVED: 'Experience archived',
    EXPERIENCE_ENVIRONMENT_NOT_MATCH: 'Experience environment does not match',
    EXPERIENCE_RULES_MATCHED: 'Experience rules matched',
    VARIATIONS_NOT_FOUND: 'Variations not found',
    VARIATION_CHANGE_NOT_SUPPORTED: 'Variation change not supported',
    FEATURE_CONSTRUCTOR: 'Feature Manager constructor has been called',
    FEATURE_NOT_FOUND: 'Fullstack Feature not found',
    FEATURE_VARIABLES_NOT_FOUND: 'Fullstack Feature Variables not found',
    FEATURE_VARIABLES_TYPE_NOT_FOUND: 'Fullstack Feature Variables Type not found',
    BUCKETING_CONSTRUCTOR: 'Bucketing Manager constructor has been called',
    DATA_CONSTRUCTOR: 'Data Manager constructor has been called',
    RULE_CONSTRUCTOR: 'Rule Manager constructor has been called',
    PROCESSING_ENTITY: 'Processing #',
    LOCATION_MATCH: 'Location # rule matched',
    LOCATION_NOT_MATCH: 'Location does not match',
    LOCATION_NOT_RESTRICTED: 'Location not restricted',
    AUDIENCE_MATCH: 'Audience # rule matched',
    AUDIENCE_NOT_MATCH: 'Audience does not match',
    NON_PERMANENT_AUDIENCE_NOT_RESTRICTED: 'Non-Permanent Audience not restricted',
    AUDIENCE_NOT_RESTRICTED: 'Audience not restricted',
    SEGMENTATION_MATCH: 'Segmentation # rule matched',
    SEGMENTATION_NOT_RESTRICTED: 'Segmentation not restricted',
    RULE_NOT_MATCH: 'Rule does not match',
    RULE_MATCH: 'Found matched rule at OR block #',
    RULE_MATCH_AND: 'AND block rule macthed',
    RULE_MATCH_START: 'About to evaluate rule #',
    LOCATION_ACTIVATED: 'Location # activated',
    LOCATION_DEACTIVATED: 'Location # deactivated',
    BUCKETED_VISITOR_FOUND: 'Visitor is already bucketed for variation #',
    BUCKETED_VISITOR_FORCED: 'Forcing variation #',
    BUCKETED_VISITOR: 'Visitor is bucketed for variation #',
    GOAL_NOT_FOUND: 'Goal not found',
    GOAL_RULE_NOT_MATCH: 'Goal rule do not match',
    GOAL_FOUND: 'Goal # already triggered',
    SEGMENTS_NOT_FOUND: 'Segments not found',
    SEGMENTS_RULE_NOT_MATCH: 'Segments rule do not match',
    CUSTOM_SEGMENTS_KEY_FOUND: 'Custom segments key already set',
    SEND_BEACON_SUCCESS: 'The user agent successfully queued the data for transfer',
    RELEASING_QUEUE: 'Releasing event queue...'
};

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var DoNotTrack;
(function (DoNotTrack) {
    DoNotTrack["OFF"] = "OFF";
    DoNotTrack["EU_ONLY"] = "EU ONLY";
    DoNotTrack["EEA_ONLY"] = "EEA ONLY";
    DoNotTrack["WORLDWIDE"] = "Worldwide";
})(DoNotTrack || (DoNotTrack = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var EntityType;
(function (EntityType) {
    EntityType["AUDIENCE"] = "audience";
    EntityType["LOCATION"] = "location";
    EntityType["SEGMENT"] = "segment";
    EntityType["FEATURE"] = "feature";
    EntityType["GOAL"] = "goal";
    EntityType["EXPERIENCE"] = "experience";
    EntityType["VARIATION"] = "variation";
})(EntityType || (EntityType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var FeatureStatus;
(function (FeatureStatus) {
    FeatureStatus["ENABLED"] = "enabled";
    FeatureStatus["DISABLED"] = "disabled";
})(FeatureStatus || (FeatureStatus = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var GoalDataKey;
(function (GoalDataKey) {
    GoalDataKey["AMOUNT"] = "amount";
    GoalDataKey["PRODUCTS_COUNT"] = "productsCount";
    GoalDataKey["TRANSACTION_ID"] = "transactionId";
})(GoalDataKey || (GoalDataKey = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["TRACE"] = 0] = "TRACE";
    LogLevel[LogLevel["DEBUG"] = 1] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
    LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var LogMethod;
(function (LogMethod) {
    LogMethod["LOG"] = "log";
    LogMethod["TRACE"] = "trace";
    LogMethod["DEBUG"] = "debug";
    LogMethod["INFO"] = "info";
    LogMethod["WARN"] = "warn";
    LogMethod["ERROR"] = "error";
})(LogMethod || (LogMethod = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var ProjectType;
(function (ProjectType) {
    ProjectType["WEB"] = "web";
    ProjectType["FULLSTACK"] = "fullstack";
})(ProjectType || (ProjectType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var RuleError;
(function (RuleError) {
    RuleError["NO_DATA_FOUND"] = "convert.com_no_data_found";
    RuleError["NEED_MORE_DATA"] = "convert.com_need_more_data";
})(RuleError || (RuleError = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * SDK system events. Possible values: 'ready' | 'queue-released'
 * or custom visitor's event
 */
var SystemEvents;
(function (SystemEvents) {
    SystemEvents["READY"] = "ready";
    SystemEvents["CONFIG_UPDATED"] = "config.updated";
    SystemEvents["API_QUEUE_RELEASED"] = "api.queue.released";
    SystemEvents["BUCKETING"] = "bucketing";
    SystemEvents["CONVERSION"] = "conversion";
    SystemEvents["SEGMENTS"] = "segments";
    SystemEvents["LOCATION_ACTIVATED"] = "location.activated";
    SystemEvents["LOCATION_DEACTIVATED"] = "location.deactivated";
    SystemEvents["AUDIENCES"] = "audiences";
    SystemEvents["DATA_STORE_QUEUE_RELEASED"] = "datastore.queue.released";
})(SystemEvents || (SystemEvents = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var VariationChangeType;
(function (VariationChangeType) {
    VariationChangeType["RICH_STRUCTURE"] = "richStructure";
    VariationChangeType["CUSTOM_CODE"] = "customCode";
    VariationChangeType["DEFAULT_CODE"] = "defaultCode";
    VariationChangeType["DEFAULT_CODE_MULTIPAGE"] = "defaultCodeMultipage";
    VariationChangeType["DEFAULT_REDIRECT"] = "defaultRedirect";
    VariationChangeType["FULLSTACK_FEATURE"] = "fullStackFeature";
})(VariationChangeType || (VariationChangeType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var BrowserType;
(function (BrowserType) {
    BrowserType["IE"] = "IE";
    BrowserType["CH"] = "CH";
    BrowserType["FF"] = "FF";
    BrowserType["OP"] = "OP";
    BrowserType["SF"] = "SF";
    BrowserType["EDG"] = "EDG";
    BrowserType["MO"] = "MO";
    BrowserType["NS"] = "NS";
    BrowserType["OTH"] = "OTH";
})(BrowserType || (BrowserType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var DeviceType;
(function (DeviceType) {
    DeviceType["ALLPH"] = "ALLPH";
    DeviceType["IPH"] = "IPH";
    DeviceType["OTHPH"] = "OTHPH";
    DeviceType["ALLTAB"] = "ALLTAB";
    DeviceType["IPAD"] = "IPAD";
    DeviceType["OTHTAB"] = "OTHTAB";
    DeviceType["DESK"] = "DESK";
    DeviceType["OTHDEV"] = "OTHDEV";
})(DeviceType || (DeviceType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var SegmentsKeys;
(function (SegmentsKeys) {
    SegmentsKeys["COUNTRY"] = "country";
    SegmentsKeys["BROWSER"] = "browser";
    SegmentsKeys["DEVICES"] = "devices";
    SegmentsKeys["SOURCE"] = "source";
    SegmentsKeys["CAMPAIGN"] = "campaign";
    SegmentsKeys["VISITOR_TYPE"] = "visitorType";
    SegmentsKeys["CUSTOM_SEGMENTS"] = "customSegments";
})(SegmentsKeys || (SegmentsKeys = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var SourceType;
(function (SourceType) {
    SourceType["CAMPAIGN"] = "campaign";
    SourceType["SEARCH"] = "search";
    SourceType["REFERRAL"] = "referral";
    SourceType["DIRECT"] = "direct";
})(SourceType || (SourceType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var VisitorType;
(function (VisitorType) {
    VisitorType["NEW"] = "new";
    VisitorType["RETURNING"] = "returning";
})(VisitorType || (VisitorType = {}));

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * Validates variable is array and not empty
 * @param array
 */
function arrayNotEmpty(array) {
    return Array.isArray(array) && array.length > 0;
}

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * Returns the value at path of object
 * TODO: get this utility to work with the optional mapper() helper from config
 * @param {Record<string, any>} object
 * @param {string} path
 * @param {any=} defaultValue
 * @param {boolean=} truthy Should Number 0 number and Boolean false be considered as normal value
 * @return {any}
 */
function objectDeepValue(object, path, defaultValue, truthy = false) {
    try {
        if (typeof object === 'object') {
            const v = path.split('.').reduce((a, v) => a[v], object);
            if (v || (truthy && (v === false || v === 0))) {
                return v;
            }
        }
        // eslint-disable-next-line no-empty
    }
    catch (e) { }
    {
        return null;
    }
}
/**
 * Deep merge objects and their keys and nested objects
 * Accepts arrays
 *
 * @param {...Record<any, any>} objects Objects to merge
 * @return {Record<any, any>}
 */
function objectDeepMerge(...objects) {
    const isObject = (obj) => obj && typeof obj === 'object';
    return objects.reduce((prev, obj) => {
        Object.keys(obj).forEach((key) => {
            const pVal = prev[key];
            const oVal = obj[key];
            if (Array.isArray(pVal) && Array.isArray(oVal)) {
                prev[key] = [...new Set([...oVal, ...pVal])];
            }
            else if (isObject(pVal) && isObject(oVal)) {
                prev[key] = objectDeepMerge(pVal, oVal);
            }
            else {
                prev[key] = oVal;
            }
        });
        return prev;
    }, {});
}
/**
 * Validates variable is object and not empty
 * @param object
 */
function objectNotEmpty(object) {
    return (typeof object === 'object' &&
        object !== null &&
        Object.keys(object).length > 0);
}
/**
 * Compare two objects
 * @param a
 * @param b
 */
const objectDeepEqual = (a, b) => {
    if (a === b)
        return true;
    if (typeof a != 'object' || typeof b != 'object' || a == null || b == null)
        return false;
    const keysA = Object.keys(a), keysB = Object.keys(b);
    if (keysA.length != keysB.length)
        return false;
    for (const key of keysA) {
        if (!keysB.includes(key))
            return false;
        if (typeof a[key] === 'function' || typeof b[key] === 'function') {
            if (a[key].toString() != b[key].toString())
                return false;
        }
        else {
            if (!objectDeepEqual(a[key], b[key]))
                return false;
        }
    }
    return true;
};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var murmurhash = {exports: {}};

(function (module) {
	(function(){

	  const createBuffer = (val) => new TextEncoder().encode(val);

	  /**
	   * JS Implementation of MurmurHash2
	   *
	   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
	   * @see http://github.com/garycourt/murmurhash-js
	   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
	   * @see http://sites.google.com/site/murmurhash/
	   *
	   * @param {Uint8Array | string} str ASCII only
	   * @param {number} seed Positive integer only
	   * @return {number} 32-bit positive integer hash
	   */
	  function MurmurHashV2(str, seed) {
	    if (typeof str === 'string') str = createBuffer(str);
	    let
	      l = str.length,
	      h = seed ^ l,
	      i = 0,
	      k;

	    while (l >= 4) {
	      k =
	        ((str[i] & 0xff)) |
	        ((str[++i] & 0xff) << 8) |
	        ((str[++i] & 0xff) << 16) |
	        ((str[++i] & 0xff) << 24);

	      k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));
	      k ^= k >>> 24;
	      k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));

	    h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)) ^ k;

	      l -= 4;
	      ++i;
	    }

	    switch (l) {
	    case 3: h ^= (str[i + 2] & 0xff) << 16;
	    case 2: h ^= (str[i + 1] & 0xff) << 8;
	    case 1: h ^= (str[i] & 0xff);
	            h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));
	    }

	    h ^= h >>> 13;
	    h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));
	    h ^= h >>> 15;

	    return h >>> 0;
	  }
	  /*
	   * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)
	   *
	   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
	   * @see http://github.com/garycourt/murmurhash-js
	   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
	   * @see http://sites.google.com/site/murmurhash/
	   *
	   * @param {Uint8Array | string} key ASCII only
	   * @param {number} seed Positive integer only
	   * @return {number} 32-bit positive integer hash
	   */
	  function MurmurHashV3(key, seed) {
	    if (typeof key === 'string') key = createBuffer(key);

	    let remainder, bytes, h1, h1b, c1, c2, k1, i;

	    remainder = key.length & 3; // key.length % 4
	    bytes = key.length - remainder;
	    h1 = seed;
	    c1 = 0xcc9e2d51;
	    c2 = 0x1b873593;
	    i = 0;

	    while (i < bytes) {
	        k1 =
	          ((key[i] & 0xff)) |
	          ((key[++i] & 0xff) << 8) |
	          ((key[++i] & 0xff) << 16) |
	          ((key[++i] & 0xff) << 24);
	      ++i;

	      k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
	      k1 = (k1 << 15) | (k1 >>> 17);
	      k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

	      h1 ^= k1;
	          h1 = (h1 << 13) | (h1 >>> 19);
	      h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
	      h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
	    }

	    k1 = 0;

	    switch (remainder) {
	      case 3: k1 ^= (key[i + 2] & 0xff) << 16;
	      case 2: k1 ^= (key[i + 1] & 0xff) << 8;
	      case 1: k1 ^= (key[i] & 0xff);

	      k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
	      k1 = (k1 << 15) | (k1 >>> 17);
	      k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
	      h1 ^= k1;
	    }

	    h1 ^= key.length;

	    h1 ^= h1 >>> 16;
	    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
	    h1 ^= h1 >>> 13;
	    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
	    h1 ^= h1 >>> 16;

	    return h1 >>> 0;
	  }

	  const murmur = MurmurHashV3;
	  murmur.v2 = MurmurHashV2;
	  murmur.v3 = MurmurHashV3;

	  {
	    module.exports = murmur;
	  }
	}()); 
} (murmurhash));

var murmurhashExports = murmurhash.exports;
var Murmurhash = /*@__PURE__*/getDefaultExportFromCjs(murmurhashExports);

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * String formatter tool. Transforms a space-separated string into camelCase
 * @param {string} input
 * @return {string}
 */
function camelCase(input) {
    return input
        .replace(/(?:^\w|[A-Z]|\b\w)/g, function (word, index) {
        return index === 0 ? word.toLowerCase() : word.toUpperCase();
    })
        .replace(/\s+/g, '');
}
/**
 * Generate numeric hash based on seed
 * @param {string} value
 * @param {number=} seed
 * @return {number}
 */
function generateHash(value, seed = 9999) {
    return Murmurhash.v3(String(value), seed);
}
/**
 * Check if a value is numeric
 * @param {string | number} value
 * @returns {boolean}
 */
function isNumeric(value) {
    if (typeof value === 'number') {
        return true;
    }
    const number = parseFloat(String(value));
    return Number.isFinite(number) && !isNaN(number);
}
/**
 * Convert a string to a number
 * @param {string | number} value
 * @returns {number}
 */
function toNumber(value) {
    if (typeof value === 'number') {
        return value;
    }
    const parts = String(value).split(',');
    return parseFloat(parts[0] == '0'
        ? String(value).replace(/,/g, '.')
        : String(value).replace(/,/g, ''));
}

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var _a;
/**
 * Comparison Processor. Provides comparison methods for rules validation
 */
class Comparisons {
    static equals(value, testAgainst, negation) {
        if (Array.isArray(value))
            return this._returnNegationCheck(value.indexOf(testAgainst) !== -1, negation);
        if (objectNotEmpty(value))
            return this._returnNegationCheck(Object.keys(value).indexOf(String(testAgainst)) !== -1, negation);
        value = String(value);
        testAgainst = String(testAgainst);
        value = value.valueOf().toLowerCase();
        testAgainst = testAgainst.valueOf().toLowerCase();
        return this._returnNegationCheck(value === testAgainst, negation);
    }
    static less(value, testAgainst, negation) {
        value = isNumeric(value) ? toNumber(value) : value;
        testAgainst = isNumeric(testAgainst) ? toNumber(testAgainst) : testAgainst;
        if (typeof value !== typeof testAgainst) {
            return false;
        }
        return this._returnNegationCheck(value < testAgainst, negation);
    }
    static lessEqual(value, testAgainst, negation) {
        value = isNumeric(value) ? toNumber(value) : value;
        testAgainst = isNumeric(testAgainst) ? toNumber(testAgainst) : testAgainst;
        if (typeof value !== typeof testAgainst) {
            return false;
        }
        return this._returnNegationCheck(value <= testAgainst, negation);
    }
    static contains(value, testAgainst, negation) {
        value = String(value);
        testAgainst = String(testAgainst);
        value = value.valueOf().toLowerCase();
        testAgainst = testAgainst.valueOf().toLowerCase();
        if (testAgainst.replace(/^([\s]*)|([\s]*)$/g, '').length === 0) {
            return this._returnNegationCheck(true, negation);
        }
        return this._returnNegationCheck(value.indexOf(testAgainst) !== -1, negation);
    }
    static isIn(values, testAgainst, negation = false, splitter = '|') {
        const matchedValuesArray = String(values)
            .split(splitter)
            .map((item) => {
            return String(item);
        });
        if (typeof testAgainst === 'string') {
            testAgainst = testAgainst.split(splitter);
        }
        if (!Array.isArray(testAgainst)) {
            testAgainst = [];
        }
        testAgainst = testAgainst.map((item) => {
            return String(item).valueOf().toLowerCase();
        });
        for (let i = 0; i < matchedValuesArray.length; i++) {
            if (testAgainst.indexOf(matchedValuesArray[i]) !== -1) {
                return this._returnNegationCheck(true, negation);
            }
        }
        return this._returnNegationCheck(false, negation);
    }
    static startsWith(value, testAgainst, negation) {
        value = String(value).valueOf().toLowerCase();
        testAgainst = String(testAgainst).valueOf().toLowerCase();
        return this._returnNegationCheck(value.indexOf(testAgainst) === 0, negation);
    }
    static endsWith(value, testAgainst, negation) {
        value = String(value).valueOf().toLowerCase();
        testAgainst = String(testAgainst).valueOf().toLowerCase();
        return this._returnNegationCheck(value.indexOf(testAgainst, value.length - testAgainst.length) !== -1, negation);
    }
    static regexMatches(value, testAgainst, negation) {
        value = String(value).valueOf().toLowerCase();
        testAgainst = String(testAgainst).valueOf();
        const regExp = new RegExp(testAgainst, 'i');
        return this._returnNegationCheck(regExp.test(value), negation);
    }
    static _returnNegationCheck(value, negation = false) {
        if (negation) {
            return !value;
        }
        else {
            return value;
        }
    }
}
_a = Comparisons;
Comparisons.equalsNumber = _a.equals;
Comparisons.matches = _a.equals;

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * Example of Data Store implementation with simple database Based JSON file.
 * It's not recommended to use it in production as it can be memory and CPU intensive.
 * @param {string} file
 * @param {module} fs
 */
class DataStore {
    /**
     * @param {string} file
     * @param {module} fs
     */
    constructor(file, fs) {
        var _a, _b, _c, _d;
        this._file = file;
        this._fs = fs;
        try {
            if (!((_b = (_a = this._fs) === null || _a === void 0 ? void 0 : _a.existsSync) === null || _b === void 0 ? void 0 : _b.call(_a, this._file))) {
                (_d = (_c = this._fs) === null || _c === void 0 ? void 0 : _c.writeFileSync) === null || _d === void 0 ? void 0 : _d.call(_c, this._file, '{}');
            }
        }
        catch (error) {
            console.error(error);
        }
    }
    /**
     * Get value by key
     * @param {string} key
     * @return {any}
     */
    get(key) {
        var _a, _b;
        try {
            const data = JSON.parse((_b = (_a = this._fs) === null || _a === void 0 ? void 0 : _a.readFileSync) === null || _b === void 0 ? void 0 : _b.call(_a, this._file));
            return data[key];
        }
        catch (error) {
            console.error(error);
        }
    }
    /**
     * Store value by key
     * @param {string} key
     * @param {any} value
     */
    set(key, value) {
        var _a, _b, _c, _d;
        try {
            const data = JSON.parse((_b = (_a = this._fs) === null || _a === void 0 ? void 0 : _a.readFileSync) === null || _b === void 0 ? void 0 : _b.call(_a, this._file));
            data[key] = value;
            (_d = (_c = this._fs) === null || _c === void 0 ? void 0 : _c.writeFileSync) === null || _d === void 0 ? void 0 : _d.call(_c, this._file, JSON.stringify(data));
        }
        catch (error) {
            console.error(error);
        }
    }
    /**
     * Delete value by key
     * @param {string} key
     */
    delete(key) {
        var _a, _b, _c, _d;
        try {
            const data = JSON.parse((_b = (_a = this._fs) === null || _a === void 0 ? void 0 : _a.readFileSync) === null || _b === void 0 ? void 0 : _b.call(_a, this._file));
            delete data[key];
            (_d = (_c = this._fs) === null || _c === void 0 ? void 0 : _c.writeFileSync) === null || _d === void 0 ? void 0 : _d.call(_c, this._file, JSON.stringify(data));
        }
        catch (error) {
            console.error(error);
        }
    }
}

/**
 * @param {string} file
 * @param {module} fs
 * @param {string=} appendMethod Defaults to 'appendFileSync'
 * @example new FileLogger('./convert.log', require('fs'), 'appendFileSync')
 * @constructor
 */
class FileLogger {
    /**
     * @param {string} file
     * @param {module} fs
     * @param {string=} appendMethod
     */
    constructor(file, fs, appendMethod = 'appendFileSync') {
        this._file = file;
        this._fs = fs;
        this._appendMethod = appendMethod;
    }
    _write(method, ...args) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const prefix = `${new Date().toISOString()} [${method.toUpperCase()}]`;
            const output = `${prefix} ${args
                .map(JSON.stringify)
                .join(`\n${prefix} `)}\n`;
            try {
                (_b = (_a = this._fs) === null || _a === void 0 ? void 0 : _a[this._appendMethod]) === null || _b === void 0 ? void 0 : _b.call(_a, this._file, output);
            }
            catch (error) {
                console.warn(error);
            }
        });
    }
    /**
     * @param {Array<any>} args
     */
    log(...args) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._write(LogMethod.LOG, ...args);
        });
    }
    /**
     * @param {Array<any>} args
     */
    info(...args) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._write(LogMethod.INFO, ...args);
        });
    }
    /**
     * @param {Array<any>} args
     */
    debug(...args) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._write(LogMethod.DEBUG, ...args);
        });
    }
    /**
     * @param {Array<any>} args
     */
    warn(...args) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._write(LogMethod.WARN, ...args);
        });
    }
    /**
     * @param {Array<any>} args
     */
    error(...args) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._write(LogMethod.ERROR, ...args);
        });
    }
}

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
var HttpStatusCode;
(function (HttpStatusCode) {
    HttpStatusCode[HttpStatusCode["Continue"] = 100] = "Continue";
    HttpStatusCode[HttpStatusCode["SwitchingProtocols"] = 101] = "SwitchingProtocols";
    HttpStatusCode[HttpStatusCode["Processing"] = 102] = "Processing";
    HttpStatusCode[HttpStatusCode["EarlyHints"] = 103] = "EarlyHints";
    HttpStatusCode[HttpStatusCode["Ok"] = 200] = "Ok";
    HttpStatusCode[HttpStatusCode["Created"] = 201] = "Created";
    HttpStatusCode[HttpStatusCode["Accepted"] = 202] = "Accepted";
    HttpStatusCode[HttpStatusCode["NonAuthoritativeInformation"] = 203] = "NonAuthoritativeInformation";
    HttpStatusCode[HttpStatusCode["NoContent"] = 204] = "NoContent";
    HttpStatusCode[HttpStatusCode["ResetContent"] = 205] = "ResetContent";
    HttpStatusCode[HttpStatusCode["PartialContent"] = 206] = "PartialContent";
    HttpStatusCode[HttpStatusCode["MultiStatus"] = 207] = "MultiStatus";
    HttpStatusCode[HttpStatusCode["AlreadyReported"] = 208] = "AlreadyReported";
    HttpStatusCode[HttpStatusCode["ImUsed"] = 226] = "ImUsed";
    HttpStatusCode[HttpStatusCode["MultipleChoices"] = 300] = "MultipleChoices";
    HttpStatusCode[HttpStatusCode["MovedPermanently"] = 301] = "MovedPermanently";
    HttpStatusCode[HttpStatusCode["Found"] = 302] = "Found";
    HttpStatusCode[HttpStatusCode["SeeOther"] = 303] = "SeeOther";
    HttpStatusCode[HttpStatusCode["NotModified"] = 304] = "NotModified";
    HttpStatusCode[HttpStatusCode["UseProxy"] = 305] = "UseProxy";
    HttpStatusCode[HttpStatusCode["Unused"] = 306] = "Unused";
    HttpStatusCode[HttpStatusCode["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpStatusCode[HttpStatusCode["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpStatusCode[HttpStatusCode["BadRequest"] = 400] = "BadRequest";
    HttpStatusCode[HttpStatusCode["Unauthorized"] = 401] = "Unauthorized";
    HttpStatusCode[HttpStatusCode["PaymentRequired"] = 402] = "PaymentRequired";
    HttpStatusCode[HttpStatusCode["Forbidden"] = 403] = "Forbidden";
    HttpStatusCode[HttpStatusCode["NotFound"] = 404] = "NotFound";
    HttpStatusCode[HttpStatusCode["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpStatusCode[HttpStatusCode["NotAcceptable"] = 406] = "NotAcceptable";
    HttpStatusCode[HttpStatusCode["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpStatusCode[HttpStatusCode["RequestTimeout"] = 408] = "RequestTimeout";
    HttpStatusCode[HttpStatusCode["Conflict"] = 409] = "Conflict";
    HttpStatusCode[HttpStatusCode["Gone"] = 410] = "Gone";
    HttpStatusCode[HttpStatusCode["LengthRequired"] = 411] = "LengthRequired";
    HttpStatusCode[HttpStatusCode["PreconditionFailed"] = 412] = "PreconditionFailed";
    HttpStatusCode[HttpStatusCode["PayloadTooLarge"] = 413] = "PayloadTooLarge";
    HttpStatusCode[HttpStatusCode["UriTooLong"] = 414] = "UriTooLong";
    HttpStatusCode[HttpStatusCode["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
    HttpStatusCode[HttpStatusCode["RangeNotSatisfiable"] = 416] = "RangeNotSatisfiable";
    HttpStatusCode[HttpStatusCode["ExpectationFailed"] = 417] = "ExpectationFailed";
    HttpStatusCode[HttpStatusCode["ImATeapot"] = 418] = "ImATeapot";
    HttpStatusCode[HttpStatusCode["MisdirectedRequest"] = 421] = "MisdirectedRequest";
    HttpStatusCode[HttpStatusCode["UnprocessableEntity"] = 422] = "UnprocessableEntity";
    HttpStatusCode[HttpStatusCode["Locked"] = 423] = "Locked";
    HttpStatusCode[HttpStatusCode["FailedDependency"] = 424] = "FailedDependency";
    HttpStatusCode[HttpStatusCode["TooEarly"] = 425] = "TooEarly";
    HttpStatusCode[HttpStatusCode["UpgradeRequired"] = 426] = "UpgradeRequired";
    HttpStatusCode[HttpStatusCode["PreconditionRequired"] = 428] = "PreconditionRequired";
    HttpStatusCode[HttpStatusCode["TooManyRequests"] = 429] = "TooManyRequests";
    HttpStatusCode[HttpStatusCode["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
    HttpStatusCode[HttpStatusCode["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
    HttpStatusCode[HttpStatusCode["InternalServerError"] = 500] = "InternalServerError";
    HttpStatusCode[HttpStatusCode["NotImplemented"] = 501] = "NotImplemented";
    HttpStatusCode[HttpStatusCode["BadGateway"] = 502] = "BadGateway";
    HttpStatusCode[HttpStatusCode["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpStatusCode[HttpStatusCode["GatewayTimeout"] = 504] = "GatewayTimeout";
    HttpStatusCode[HttpStatusCode["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
    HttpStatusCode[HttpStatusCode["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
    HttpStatusCode[HttpStatusCode["InsufficientStorage"] = 507] = "InsufficientStorage";
    HttpStatusCode[HttpStatusCode["LoopDetected"] = 508] = "LoopDetected";
    HttpStatusCode[HttpStatusCode["NotExtended"] = 510] = "NotExtended";
    HttpStatusCode[HttpStatusCode["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
})(HttpStatusCode || (HttpStatusCode = {}));
const determineRuntime = () => {
    // if window is available, we're in a browser
    if (typeof window !== 'undefined') {
        return { runtime: 'browser' };
    }
    // if window is not available, but fetch is, then we're on a server that has the fetch API available
    if (typeof fetch === 'function') {
        return { runtime: 'server-with-fetch' };
    }
    // if node.js builtins are available, we're on nodejs
    try {
        // Gracefully attempt to NodeJS builtins, to prevent throwing exceptions in browsers
        const url = require('url');
        const http = require('http');
        const https = require('https');
        const queryString = require('querystring');
        return { runtime: 'old-nodejs', url, http, https, queryString };
    }
    catch (err) {
        // not nodejs
    }
    // otherwise, this is some unknown runtime
    return { runtime: 'unknown' };
};
const supportsRequestBody = (method) => !['GET', 'HEAD', 'DELETE', 'TRACE', 'OPTIONS'].includes(method.toUpperCase());
const serialize = (params, method, runtimeResult) => {
    let query = '';
    if (objectNotEmpty(params) && !supportsRequestBody(method)) {
        if (runtimeResult.runtime !== 'old-nodejs') {
            query = Object.keys(params)
                .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`)
                .join('&');
        }
        else {
            query = runtimeResult.queryString.stringify(params);
        }
    }
    return query ? `?${query}` : query;
};
/**
 * Provide http client for newtork requests
 * @param {HttpRequest}
 * @returns {HttpClient}
 */
const HttpClient = {
    request(config) {
        var _a;
        const method = ((_a = config === null || config === void 0 ? void 0 : config.method) === null || _a === void 0 ? void 0 : _a.toUpperCase()) || 'GET';
        const path = (config === null || config === void 0 ? void 0 : config.path)
            ? !config.path.startsWith('/')
                ? `/${config.path}`
                : config.path
            : '';
        const baseURL = config.baseURL.endsWith('/')
            ? config.baseURL.slice(0, -1)
            : config.baseURL;
        const responseType = (config === null || config === void 0 ? void 0 : config.responseType) || 'json';
        const runtimeResult = determineRuntime();
        return new Promise((resolve, reject) => {
            if (runtimeResult.runtime === 'browser' ||
                runtimeResult.runtime === 'server-with-fetch') {
                const options = {
                    method,
                    keepalive: true // to allow the request to complete even if the page unloads
                };
                if (config === null || config === void 0 ? void 0 : config.headers)
                    options.headers = config.headers;
                if ((config === null || config === void 0 ? void 0 : config.data) && supportsRequestBody(method)) {
                    options.body = JSON.stringify(config.data);
                }
                const url = `${baseURL}${path}${serialize(config === null || config === void 0 ? void 0 : config.data, method, runtimeResult)}`;
                if (method.toLowerCase() === 'post' &&
                    typeof navigator !== 'undefined' &&
                    (navigator === null || navigator === void 0 ? void 0 : navigator.sendBeacon)) {
                    /**
                     * navigator.sendBeacon method is intended for analytics
                     * and diagnostics code to send data to a server,
                     * given that analytics data are often sent to different
                     * subdomains or even different domains:
                     * 1. The browser drops CORS restraints resulted in omitting
                     * the OPTIONS request and allowing relevant cookies to be sent.
                     * 2. The browser will not abort the requests upon page unload,
                     * instead completes them in the background while the next page
                     * requests was already being processed.
                     * 3. The browser cannot decide whether the request has failed,
                     * the function only returns a boolean.
                     * 4. The specification does not define body size limitations,
                     * vendors may choose to limit the size of the request.
                     * 5. Only supports requests with POST method.
                     * 6. The following browsers cannot send Blob data: Chrome, Chrome Android, Opera, Opera Android, and WebView Android.
                     */
                    if (navigator.sendBeacon(url, options.body)) {
                        resolve({
                            data: true,
                            status: HttpStatusCode.Ok,
                            statusText: MESSAGES.SEND_BEACON_SUCCESS
                        });
                    }
                    else {
                        reject({
                            message: ERROR_MESSAGES.UNSUPPORTED_RESPONSE_TYPE
                        });
                    }
                }
                else {
                    fetch(url, options)
                        .then((res) => __awaiter(this, void 0, void 0, function* () {
                        if (res.status === HttpStatusCode.Ok) {
                            const output = {
                                status: res.status,
                                statusText: res.statusText,
                                headers: res.headers,
                                data: null
                            };
                            switch (responseType) {
                                case 'json':
                                    output.data = yield res.json();
                                    break;
                                case 'arraybuffer':
                                    output.data = yield res.arrayBuffer();
                                    break;
                                case 'text':
                                    output.data = res;
                                    break;
                                default:
                                    reject({
                                        message: ERROR_MESSAGES.UNSUPPORTED_RESPONSE_TYPE
                                    });
                                    return;
                            }
                            resolve(output);
                        }
                        else {
                            reject({
                                message: res.statusText,
                                status: res.status
                            });
                        }
                    }))
                        .catch((err) => {
                        reject({
                            message: err === null || err === void 0 ? void 0 : err.message,
                            status: err === null || err === void 0 ? void 0 : err.status,
                            statusText: err === null || err === void 0 ? void 0 : err.statusText
                        });
                    });
                }
            }
            else if (runtimeResult.runtime === 'old-nodejs') {
                // Fallback to CommonJS if not targeting a browser
                const parsedBaseUrl = runtimeResult.url.parse(baseURL);
                if (!parsedBaseUrl.port) {
                    parsedBaseUrl.port =
                        parsedBaseUrl.protocol === 'https:' ? '443' : '80';
                }
                const pathPrefix = parsedBaseUrl.path.endsWith('/')
                    ? parsedBaseUrl.path.slice(0, -1)
                    : parsedBaseUrl.path;
                const client = parsedBaseUrl.protocol === 'https:'
                    ? runtimeResult.https
                    : runtimeResult.http;
                const body = [];
                const options = {
                    hostname: parsedBaseUrl.hostname,
                    path: `${pathPrefix}${path}${serialize(config === null || config === void 0 ? void 0 : config.data, method, runtimeResult)}`,
                    port: parsedBaseUrl.port,
                    method
                };
                const postData = (config === null || config === void 0 ? void 0 : config.data) && supportsRequestBody(method)
                    ? JSON.stringify(config.data)
                    : null;
                if (config === null || config === void 0 ? void 0 : config.headers)
                    options.headers = config.headers;
                if (postData) {
                    if (!options.headers)
                        options.headers = {};
                    options.headers['Content-Length'] = Buffer.byteLength(postData);
                }
                const req = client.request(options, (res) => {
                    res.on('data', (chunk) => body.push(chunk));
                    res.on('end', () => {
                        if (res.statusCode === HttpStatusCode.Ok) {
                            const buffer = Buffer.concat(body);
                            const data = buffer.toString();
                            const output = {
                                status: res.statusCode,
                                statusText: res.statusMessage,
                                headers: res.headers,
                                data: null
                            };
                            switch (responseType) {
                                case 'json':
                                    output.data = data ? JSON.parse(data) : '';
                                    break;
                                case 'arraybuffer':
                                    output.data = buffer === null || buffer === void 0 ? void 0 : buffer.buffer;
                                    break;
                                case 'text':
                                    output.data = res;
                                    break;
                                default:
                                    reject({
                                        message: ERROR_MESSAGES.UNSUPPORTED_RESPONSE_TYPE
                                    });
                                    return;
                            }
                            resolve(output);
                        }
                        else {
                            reject({
                                message: res.statusMessage,
                                status: res.statusCode
                            });
                        }
                    });
                });
                req.on('error', (err) => {
                    const e = err;
                    reject({
                        message: e === null || e === void 0 ? void 0 : e.message,
                        status: e === null || e === void 0 ? void 0 : e.code,
                        statusText: e === null || e === void 0 ? void 0 : e.statusText
                    });
                });
                if (postData)
                    req.write(postData);
                req.end();
            }
            else {
                reject({
                    message: ERROR_MESSAGES.UNABLE_TO_PERFORM_NETWORK_REQUEST
                });
            }
        });
    }
};

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * Transform value type. Does not do any JSON validation
 * @param value
 * @param type
 */
function castType(value, type) {
    switch (type) {
        case 'boolean':
            if (value === 'true') {
                return true;
            }
            if (value === 'false') {
                return false;
            }
            return !!value;
        case 'float':
            if (value === true) {
                return 1;
            }
            if (value === false) {
                return 0;
            }
            return parseFloat(value);
        case 'json':
            if (typeof value === 'object') {
                return value;
            }
            else {
                try {
                    return JSON.parse(value);
                }
                catch (err) {
                    return String(value);
                }
            }
        case 'string':
            return String(value);
        case 'integer':
            if (value === true) {
                return 1;
            }
            if (value === false) {
                return 0;
            }
            return parseInt(value);
        default:
            return value;
    }
}

const DEFAULT_HEADERS = {
    'Content-Type': 'application/json'
};
const DEFAULT_BATCH_SIZE$1 = 10;
const DEFAULT_RELEASE_INTERVAL$1 = 10000;
const DEFAULT_CONFIG_ENDPOINT = 'https://cdn-4.convertexperiments.com/api/v1/';
const DEFAULT_TRACK_ENDPOINT = 'https://[project_id].metrics.convertexperiments.com/v1/';
/**
 * Provides logic for network requests. Reads remote configuration and sends tracking events to Convert server.
 * @category Modules
 * @constructor
 * @implements {ApiManagerInterface}
 */
class ApiManager {
    /**
     * @param {Config=} config
     * @param {Object=} dependencies
     * @param {EventManagerInterface=} dependencies.eventManager
     * @param {LogManagerInterface=} dependencies.loggerManager
     */
    constructor(config, { eventManager, loggerManager } = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        this._configEndpoint = DEFAULT_CONFIG_ENDPOINT;
        this._trackEndpoint = DEFAULT_TRACK_ENDPOINT;
        this._defaultHeaders = DEFAULT_HEADERS;
        this.batchSize = DEFAULT_BATCH_SIZE$1;
        this.releaseInterval = DEFAULT_RELEASE_INTERVAL$1;
        this._loggerManager = loggerManager;
        this._eventManager = eventManager;
        this._configEndpoint =
            ((_b = (_a = config === null || config === void 0 ? void 0 : config.api) === null || _a === void 0 ? void 0 : _a.endpoint) === null || _b === void 0 ? void 0 : _b.config) || DEFAULT_CONFIG_ENDPOINT;
        this._trackEndpoint =
            ((_d = (_c = config === null || config === void 0 ? void 0 : config.api) === null || _c === void 0 ? void 0 : _c.endpoint) === null || _d === void 0 ? void 0 : _d.track) || DEFAULT_TRACK_ENDPOINT;
        this._data = objectDeepValue(config, 'data');
        this._enrichData = !objectDeepValue(config, 'dataStore');
        this._environment = config === null || config === void 0 ? void 0 : config.environment;
        this._mapper = (config === null || config === void 0 ? void 0 : config.mapper) || ((value) => value);
        this.batchSize = Number((_e = config === null || config === void 0 ? void 0 : config.events) === null || _e === void 0 ? void 0 : _e.batch_size) || DEFAULT_BATCH_SIZE$1;
        this.releaseInterval =
            Number((_f = config === null || config === void 0 ? void 0 : config.events) === null || _f === void 0 ? void 0 : _f.release_interval) || DEFAULT_RELEASE_INTERVAL$1;
        this._accountId = (_g = this._data) === null || _g === void 0 ? void 0 : _g.account_id;
        this._projectId = (_j = (_h = this._data) === null || _h === void 0 ? void 0 : _h.project) === null || _j === void 0 ? void 0 : _j.id;
        this._sdkKey = (config === null || config === void 0 ? void 0 : config.sdkKey) || `${this._accountId}/${this._projectId}`;
        if (config === null || config === void 0 ? void 0 : config.sdkKeySecret)
            this._defaultHeaders['Authorization'] = `Bearer ${config === null || config === void 0 ? void 0 : config.sdkKeySecret}`;
        this._trackingEvent = {
            enrichData: this._enrichData,
            accountId: this._accountId,
            projectId: this._projectId,
            visitors: []
        };
        this._trackingEnabled = (_k = config === null || config === void 0 ? void 0 : config.network) === null || _k === void 0 ? void 0 : _k.tracking;
        this._trackingSource = ((_l = config === null || config === void 0 ? void 0 : config.network) === null || _l === void 0 ? void 0 : _l.source) || 'js-sdk';
        this._cacheLevel = (_m = config === null || config === void 0 ? void 0 : config.network) === null || _m === void 0 ? void 0 : _m.cacheLevel;
        this._requestsQueue = {
            length: 0,
            items: [],
            push(visitorId, eventRequest, segments) {
                const visitorIndex = this.items.findIndex((event) => event.visitorId === visitorId);
                if (visitorIndex !== -1) {
                    this.items[visitorIndex].events.push(eventRequest);
                }
                else {
                    const visitor = {
                        visitorId,
                        events: [eventRequest]
                    };
                    if (segments)
                        visitor.segments = segments;
                    this.items.push(visitor);
                }
                this.length++;
            },
            reset() {
                this.items = [];
                this.length = 0;
            }
        };
    }
    /**
     * Send request to api server
     * @param method
     * @param path
     * @param data
     * @param headers
     * @return {Promise<HttpResponse>}
     */
    request(method_1, path_1) {
        return __awaiter(this, arguments, void 0, function* (method, path, data = {}, headers = {}) {
            const requestHeaders = Object.assign(Object.assign({}, this._defaultHeaders), headers);
            const requestConfig = {
                method: method,
                path: path.route,
                baseURL: path.base,
                headers: requestHeaders,
                data: data,
                responseType: 'json'
            };
            return HttpClient.request(requestConfig);
        });
    }
    /**
     * Add request to queue for sending to server
     * @param {string} visitorId
     * @param {VisitorTrackingEvents} eventRequest
     * @param {VisitorSegments} segments
     */
    enqueue(visitorId, eventRequest, segments) {
        var _a, _b;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'ApiManager.enqueue()', this._mapper({
            eventRequest: eventRequest
        }));
        this._requestsQueue.push(visitorId, eventRequest, segments);
        if (this._trackingEnabled) {
            if (this._requestsQueue.length === 1) {
                this.startQueue();
            }
            else if (this._requestsQueue.length === this.batchSize) {
                this.releaseQueue('size').then();
            }
        }
    }
    /**
     * Send queue to server
     * @param {string=} reason
     * @return {Promise<any>}
     */
    releaseQueue(reason) {
        var _a, _b, _c, _d;
        if (!this._requestsQueue.length)
            return;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.info) === null || _b === void 0 ? void 0 : _b.call(_a, 'ApiManager.releaseQueue()', MESSAGES.RELEASING_QUEUE);
        (_d = (_c = this._loggerManager) === null || _c === void 0 ? void 0 : _c.trace) === null || _d === void 0 ? void 0 : _d.call(_c, 'ApiManager.releaseQueue()', {
            reason: reason || ''
        });
        this.stopQueue();
        const payload = this._trackingEvent;
        payload.visitors = this._requestsQueue.items.slice();
        payload.source = this._trackingSource;
        return this.request('post', {
            base: this._trackEndpoint.replace('[project_id]', this._projectId.toString()),
            route: `/track/${this._sdkKey}`
        }, this._mapper(payload))
            .then((result) => {
            var _a, _b;
            this._requestsQueue.reset();
            (_b = (_a = this._eventManager) === null || _a === void 0 ? void 0 : _a.fire) === null || _b === void 0 ? void 0 : _b.call(_a, SystemEvents.API_QUEUE_RELEASED, {
                reason: reason,
                result: result,
                visitors: payload.visitors
            });
        })
            .catch((error) => {
            var _a, _b, _c, _d;
            // TODO: set an exponential backoff
            (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, 'ApiManager.releaseQueue()', {
                error: error.message
            });
            this.startQueue();
            (_d = (_c = this._eventManager) === null || _c === void 0 ? void 0 : _c.fire) === null || _d === void 0 ? void 0 : _d.call(_c, SystemEvents.API_QUEUE_RELEASED, { reason: reason }, error);
        });
    }
    /**
     * Stop queue timer
     */
    stopQueue() {
        clearTimeout(this._requestsQueueTimerID);
    }
    /**
     * Start queue timer
     */
    startQueue() {
        this._requestsQueueTimerID = setTimeout(() => {
            this.releaseQueue('timeout');
        }, this.releaseInterval);
    }
    /**
     * Enable tracking
     */
    enableTracking() {
        this._trackingEnabled = true;
        this.releaseQueue('trackingEnabled');
    }
    /**
     * Disable tracking
     */
    disableTracking() {
        this._trackingEnabled = false;
    }
    /**
     * Set data
     */
    setData(data) {
        var _a;
        this._data = data;
        this._accountId = data === null || data === void 0 ? void 0 : data.account_id;
        this._projectId = (_a = data === null || data === void 0 ? void 0 : data.project) === null || _a === void 0 ? void 0 : _a.id;
        this._trackingEvent.accountId = this._accountId;
        this._trackingEvent.projectId = this._projectId;
    }
    /**
     * Get config data
     * @return {Promise<ConfigResponseData>}
     */
    getConfig() {
        var _a, _b;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'ApiManager.getConfig()');
        let query = this._cacheLevel === 'low' || this._environment ? '?' : '';
        if (this._environment)
            query += `environment=${this._environment}`;
        if (this._cacheLevel === 'low')
            query += '_conv_low_cache=1';
        return new Promise((resolve, reject) => {
            this.request('get', {
                base: this._configEndpoint,
                route: `/config/${this._sdkKey}${query}`
            })
                .then(({ data }) => resolve(data))
                .catch(reject);
        });
    }
}

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
//default hash seed
const DEFAULT_HASH_SEED = 9999;
const DEFAULT_MAX_TRAFFIC = 10000;
const DEFAULT_MAX_HASH = 4294967296;
/**
 * Provides logic for bucketing for specific visitor (by visitorId) or randomly
 * @category Modules
 * @constructor
 * @implements {BucketingManagerInterface}
 */
class BucketingManager {
    /**
     * @param {Config=} config
     * @param {Object=} dependencies
     * @param {LogManagerInterface=} dependencies.loggerManager
     */
    constructor(config, { loggerManager } = {}) {
        var _a, _b, _c, _d;
        this._max_traffic = DEFAULT_MAX_TRAFFIC;
        this._hash_seed = DEFAULT_HASH_SEED;
        this._loggerManager = loggerManager;
        this._max_traffic = ((_a = config === null || config === void 0 ? void 0 : config.bucketing) === null || _a === void 0 ? void 0 : _a.max_traffic) || DEFAULT_MAX_TRAFFIC;
        this._hash_seed = ((_b = config === null || config === void 0 ? void 0 : config.bucketing) === null || _b === void 0 ? void 0 : _b.hash_seed) || DEFAULT_HASH_SEED;
        (_d = (_c = this._loggerManager) === null || _c === void 0 ? void 0 : _c.trace) === null || _d === void 0 ? void 0 : _d.call(_c, 'BucketingManager()', MESSAGES.BUCKETING_CONSTRUCTOR, this);
    }
    /**
     * Select variation based on its percentages and value provided
     * @param {object} buckets Key-value object with variations IDs as keys and percentages as values
     * @param {number} value A bucket value
     * @param {number=} redistribute Defaults to '0'
     * @return {string | null}
     */
    selectBucket(buckets, value, redistribute = 0) {
        var _a, _b;
        let variation = null;
        let prev = 0;
        Object.keys(buckets).some((id) => {
            prev += buckets[id] * 100 + redistribute;
            if (value < prev) {
                variation = id;
                return true;
            }
            return false;
        });
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, 'BucketingManager.selectBucket()', {
            buckets: buckets,
            value: value,
            redistribute: redistribute
        }, { variation: variation });
        return variation || null;
    }
    /**
     * Get a value based on hash from Visitor id to use for bucket selecting
     * @param {string} visitorId
     * @param {BucketingHash=} options
     * @param {number=} [options.seed=]
     * @param {string=} [options.experienceId=]
     * @return {number}
     */
    getValueVisitorBased(visitorId, options) {
        var _a, _b;
        const { seed = this._hash_seed, experienceId = '' } = options || {};
        const hash = generateHash(experienceId + String(visitorId), seed);
        const val = (hash / DEFAULT_MAX_HASH) * this._max_traffic;
        const result = parseInt(String(val), 10);
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, 'BucketingManager.getValueVisitorBased()', {
            visitorId: visitorId,
            seed: seed,
            experienceId: experienceId,
            val: val,
            result: result
        });
        return result;
    }
    /**
     * Get a bucket for the visitor
     * @param {object} buckets Key-value object with variations IDs as keys and percentages as values
     * @param {string} visitorId
     * @param {BucketingHash=} options
     * @param {number=} [options.redistribute=0]
     * @param {number=} [options.seed=]
     * @param {string=} [options.experienceId=]
     * @return {BucketingAllocation | null}
     */
    getBucketForVisitor(buckets, visitorId, options) {
        const value = this.getValueVisitorBased(visitorId, options);
        const selectedBucket = this.selectBucket(buckets, value, options === null || options === void 0 ? void 0 : options.redistribute);
        if (!selectedBucket)
            return null;
        return {
            variationId: selectedBucket,
            bucketingAllocation: value
        };
    }
}

/**
 * Provides visitor context
 * @category Main
 * @constructor
 * @implements {ContextInterface}
 */
class Context {
    /**
     * @param {Config} config
     * @param {Object} dependencies
     * @param {ApiManagerInterface} dependencies.apiManager
     * @param {EventManagerInterface} dependencies.eventManager
     * @param {ExperienceManagerInterface} dependencies.experienceManager
     * @param {FeatureManagerInterface} dependencies.featureManager
     * @param {DataManagerInterface} dependencies.dataManager
     * @param {ApiManagerInterface} dependencies.apiManager
     * @param {LogManagerInterface} dependencies.loggerManager
     */
    constructor(config, visitorId, { eventManager, experienceManager, featureManager, segmentsManager, dataManager, apiManager, loggerManager }, visitorProperties) {
        this._environment = config === null || config === void 0 ? void 0 : config.environment;
        this._visitorId = visitorId;
        this._config = config;
        this._eventManager = eventManager;
        this._experienceManager = experienceManager;
        this._featureManager = featureManager;
        this._dataManager = dataManager;
        this._segmentsManager = segmentsManager;
        this._apiManager = apiManager;
        this._loggerManager = loggerManager;
        if (objectNotEmpty(visitorProperties)) {
            const { properties } = this._dataManager.filterReportSegments(visitorProperties);
            if (properties)
                this._visitorProperties = properties;
            segmentsManager.putSegments(visitorId, visitorProperties);
        }
    }
    /**
     * Get variation from specific experience
     * @param {string} experienceKey An experience's key that should be activated
     * @param {BucketingAttributes=} attributes An object that specifies attributes for the visitor
     * @param {Record<any, any>=} attributes.locationProperties An object of key-value pairs that are used for location matching
     * @param {Record<any, any>=} attributes.visitorProperties An object of key-value pairs that are used for audience targeting
     * @param {boolean=} attributes.updateVisitorProperties Decide whether to update visitor properties upon bucketing
     * @param {string=} attributes.environment Overwrite the environment
     * @return {BucketedVariation | RuleError | BucketingError}
     */
    runExperience(experienceKey, attributes) {
        var _a, _b;
        if (!this._visitorId) {
            (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, 'Context.runExperience()', ERROR_MESSAGES.VISITOR_ID_REQUIRED);
            return;
        }
        const visitorProperties = this.getVisitorProperties(attributes === null || attributes === void 0 ? void 0 : attributes.visitorProperties);
        const bucketedVariation = this._experienceManager.selectVariation(this._visitorId, experienceKey, {
            visitorProperties, // represents audiences
            locationProperties: attributes === null || attributes === void 0 ? void 0 : attributes.locationProperties, // represents site_area/locations
            updateVisitorProperties: attributes === null || attributes === void 0 ? void 0 : attributes.updateVisitorProperties,
            environment: (attributes === null || attributes === void 0 ? void 0 : attributes.environment) || this._environment
        });
        if (Object.values(RuleError).includes(bucketedVariation))
            return bucketedVariation;
        if (Object.values(BucketingError).includes(bucketedVariation))
            return bucketedVariation;
        if (bucketedVariation) {
            this._eventManager.fire(SystemEvents.BUCKETING, {
                visitorId: this._visitorId,
                experienceKey,
                variationKey: bucketedVariation.key
            }, null, true);
        }
        return bucketedVariation;
    }
    /**
     * Get variations across all experiences
     * @param {BucketingAttributes=} attributes An object that specifies attributes for the visitor
     * @param {string=} attributes.locationProperties An object of key-value pairs that are used for location matching
     * @param {Record<any, any>=} attributes.visitorProperties An object of key-value pairs that are used for audience targeting
     * @param {boolean=} attributes.updateVisitorProperties Decide whether to update visitor properties upon bucketing
     * @param {string=} attributes.environment Overwrite the environment
     * @return {Array<BucketedVariatio | RuleError | BucketingError>}
     */
    runExperiences(attributes) {
        var _a, _b;
        if (!this._visitorId) {
            (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, 'Context.runExperiences()', ERROR_MESSAGES.VISITOR_ID_REQUIRED);
            return;
        }
        const visitorProperties = this.getVisitorProperties(attributes === null || attributes === void 0 ? void 0 : attributes.visitorProperties);
        const bucketedVariations = this._experienceManager.selectVariations(this._visitorId, {
            visitorProperties, // represents audiences
            locationProperties: attributes === null || attributes === void 0 ? void 0 : attributes.locationProperties, // represents site_area/locations
            updateVisitorProperties: attributes === null || attributes === void 0 ? void 0 : attributes.updateVisitorProperties,
            environment: (attributes === null || attributes === void 0 ? void 0 : attributes.environment) || this._environment
        });
        // Return rule errors if present
        const matchedRuleErrors = bucketedVariations.filter((match) => Object.values(RuleError).includes(match));
        if (matchedRuleErrors.length)
            return matchedRuleErrors;
        // Return bucketing errors if present
        const matchedBucketingErrors = bucketedVariations.filter((match) => Object.values(BucketingError).includes(match));
        if (matchedBucketingErrors.length)
            return matchedBucketingErrors;
        bucketedVariations.forEach(({ experienceKey, key }) => {
            this._eventManager.fire(SystemEvents.BUCKETING, {
                visitorId: this._visitorId,
                experienceKey,
                variationKey: key
            }, null, true);
        });
        return bucketedVariations;
    }
    /**
     * Get feature and its status
     * @param {string} key A feature key
     * @param {BucketingAttributes=} attributes An object that specifies attributes for the visitor
     * @param {string=} attributes.locationProperties An object of key-value pairs that are used for location matching
     * @param {Record<any, any>=} attributes.visitorProperties An object of key-value pairs that are used for audience targeting
     * @param {boolean=} attributes.updateVisitorProperties Decide whether to update visitor properties upon bucketing
     * @param {string=} attributes.environment Overwrite the environment
     * @param {boolean=} attributes.typeCasting Control automatic type conversion to the variable's defined type. Does not do any JSON validation. Defaults to `true`
     * @param {Array<string>=} attributes.experienceKeys Use only specific experiences
     * @return {BucketedFeature | RuleError | Array<BucketedFeature | RuleError>}
     */
    runFeature(key, attributes) {
        var _a, _b;
        if (!this._visitorId) {
            (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, 'Context.runFeature()', ERROR_MESSAGES.VISITOR_ID_REQUIRED);
            return;
        }
        const visitorProperties = this.getVisitorProperties(attributes === null || attributes === void 0 ? void 0 : attributes.visitorProperties);
        const bucketedFeature = this._featureManager.runFeature(this._visitorId, key, {
            visitorProperties,
            locationProperties: attributes === null || attributes === void 0 ? void 0 : attributes.locationProperties,
            updateVisitorProperties: attributes === null || attributes === void 0 ? void 0 : attributes.updateVisitorProperties,
            typeCasting: Object.prototype.hasOwnProperty.call(attributes || {}, 'typeCasting')
                ? attributes.typeCasting
                : true,
            environment: (attributes === null || attributes === void 0 ? void 0 : attributes.environment) || this._environment
        }, attributes === null || attributes === void 0 ? void 0 : attributes.experienceKeys);
        if (Array.isArray(bucketedFeature)) {
            // Return rule errors if present
            const matchedErrors = bucketedFeature.filter((match) => Object.values(RuleError).includes(match));
            if (matchedErrors.length)
                return matchedErrors;
            bucketedFeature.forEach(({ experienceKey, status }) => {
                this._eventManager.fire(SystemEvents.BUCKETING, {
                    visitorId: this._visitorId,
                    experienceKey,
                    featureKey: key,
                    status
                }, null, true);
            });
        }
        else {
            if (Object.values(RuleError).includes(bucketedFeature))
                return bucketedFeature;
            if (bucketedFeature) {
                this._eventManager.fire(SystemEvents.BUCKETING, {
                    visitorId: this._visitorId,
                    experienceKey: bucketedFeature.experienceKey,
                    featureKey: key,
                    status: bucketedFeature.status
                }, null, true);
            }
        }
        return bucketedFeature;
    }
    /**
     * Get features and their statuses
     * @param {BucketingAttributes=} attributes An object that specifies attributes for the visitor
     * @param {string=} attributes.locationProperties An object of key-value pairs that are used for location matching
     * @param {Record<any, any>=} attributes.visitorProperties An object of key-value pairs that are used for audience targeting
     * @param {boolean=} attributes.updateVisitorProperties Decide whether to update visitor properties upon bucketing
     * @param {string=} attributes.environment Overwrite the environment
     * @param {boolean=} attributes.typeCasting Control automatic type conversion to the variable's defined type. Does not do any JSON validation. Defaults to `true`
     * @return {Array<BucketedFeature | RuleError>}
     */
    runFeatures(attributes) {
        var _a, _b;
        if (!this._visitorId) {
            (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, 'Context.runFeatures()', ERROR_MESSAGES.VISITOR_ID_REQUIRED);
            return;
        }
        const visitorProperties = this.getVisitorProperties(attributes === null || attributes === void 0 ? void 0 : attributes.visitorProperties);
        const bucketedFeatures = this._featureManager.runFeatures(this._visitorId, {
            visitorProperties,
            locationProperties: attributes === null || attributes === void 0 ? void 0 : attributes.locationProperties,
            updateVisitorProperties: attributes === null || attributes === void 0 ? void 0 : attributes.updateVisitorProperties,
            typeCasting: Object.prototype.hasOwnProperty.call(attributes || {}, 'typeCasting')
                ? attributes.typeCasting
                : true,
            environment: (attributes === null || attributes === void 0 ? void 0 : attributes.environment) || this._environment
        });
        // Return rule errors if present
        const matchedErrors = bucketedFeatures.filter((match) => Object.values(RuleError).includes(match));
        if (matchedErrors.length)
            return matchedErrors;
        bucketedFeatures.forEach(({ experienceKey, key, status }) => {
            this._eventManager.fire(SystemEvents.BUCKETING, {
                visitorId: this._visitorId,
                experienceKey,
                featureKey: key,
                status
            }, null, true);
        });
        return bucketedFeatures;
    }
    /**
     * Trigger Conversion
     * @param {string} goalKey A goal key
     * @param {ConversionAttributes=} attributes An object that specifies attributes for the visitor
     * @param {Record<string, any>=} attributes.ruleData An object of key-value pairs that are used for goal matching
     * @param {Array<GoalData>=} attributes.conversionData An array of key-value pairs that are used for transaction data
     * @param {Record<ConversionSettingKey, number | string | boolean>} attributes.conversionSetting An object of key-value pairs that are used for tracking settings
     * @return {RuleError}
     */
    trackConversion(goalKey, attributes) {
        var _a, _b, _c, _d;
        if (!this._visitorId) {
            (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, 'Context.trackConversion()', ERROR_MESSAGES.VISITOR_ID_REQUIRED);
            return;
        }
        const goalRule = attributes === null || attributes === void 0 ? void 0 : attributes.ruleData;
        const goalData = attributes === null || attributes === void 0 ? void 0 : attributes.conversionData;
        if (goalData) {
            if (!Array.isArray(goalData)) {
                (_d = (_c = this._loggerManager) === null || _c === void 0 ? void 0 : _c.error) === null || _d === void 0 ? void 0 : _d.call(_c, 'Context.trackConversion()', ERROR_MESSAGES.GOAL_DATA_NOT_VALID);
                return;
            }
        }
        const segments = this._segmentsManager.getSegments(this._visitorId);
        const triggred = this._dataManager.convert(this._visitorId, goalKey, goalRule, goalData, segments, attributes === null || attributes === void 0 ? void 0 : attributes.conversionSetting);
        if (Object.values(RuleError).includes(triggred))
            return triggred;
        if (triggred) {
            this._eventManager.fire(SystemEvents.CONVERSION, {
                visitorId: this._visitorId,
                goalKey
            }, null, true);
        }
        return;
    }
    /**
     * Set default segments for reports
     * @param {VisitorSegments} segments A segment key
     */
    setDefaultSegments(segments) {
        this._segmentsManager.putSegments(this._visitorId, segments);
    }
    /**
     * To be deprecated
     */
    setCustomSegments(segmentKeys, attributes) {
        return this.runCustomSegments(segmentKeys, attributes);
    }
    /**
     * Match Custom segments
     * @param {Array<string>} segmentKeys A list of segment keys
     * @param {SegmentsAttributes=} attributes An object that specifies attributes for the visitor
     * @param {Record<string, any>=} attributes.ruleData An object of key-value pairs that are used for segments matching
     * @return {RuleError}
     */
    runCustomSegments(segmentKeys, attributes) {
        var _a, _b;
        if (!this._visitorId) {
            (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, 'Context.runCustomSegments()', ERROR_MESSAGES.VISITOR_ID_REQUIRED);
            return;
        }
        const segmentsRule = this.getVisitorProperties(attributes === null || attributes === void 0 ? void 0 : attributes.ruleData);
        const error = this._segmentsManager.selectCustomSegments(this._visitorId, segmentKeys, segmentsRule);
        if (error)
            return error;
        return;
    }
    /**
     * Update visitor properties in memory
     * @param {string} visitorId
     * @param {Record<string, any>} visitorProperties
     */
    updateVisitorProperties(visitorId, visitorProperties) {
        this._dataManager.putData(visitorId, { segments: visitorProperties });
    }
    /**
     * get Config Entity
     * @param {string} key
     * @param {EntityType} entityType
     * @return {Entity}
     */
    getConfigEntity(key, entityType) {
        if (entityType === EntityType.VARIATION) {
            const experiences = this._dataManager.getEntitiesList(EntityType.EXPERIENCE);
            for (const { key: experienceKey } of experiences) {
                const variation = this._dataManager.getSubItem('experiences', experienceKey, 'variations', key, 'key', 'key');
                if (variation) {
                    return variation;
                }
            }
        }
        return this._dataManager.getEntity(key, entityType);
    }
    /**
     * get Config Entity by string
     * @param {string} id
     * @param {EntityType} entityType
     * @return {Entity}
     */
    getConfigEntityById(id, entityType) {
        if (entityType === EntityType.VARIATION) {
            const experiences = this._dataManager.getEntitiesList(EntityType.EXPERIENCE);
            for (const { id: experienceId } of experiences) {
                const variation = this._dataManager.getSubItem('experiences', experienceId, 'variations', id, 'id', 'id');
                if (variation) {
                    return variation;
                }
            }
        }
        return this._dataManager.getEntityById(id, entityType);
    }
    /**
     * Get visitor data
     * @returns {StoreData}
     */
    getVisitorData() {
        return this._dataManager.getData(this._visitorId) || {};
    }
    /**
     * Send pending API/DataStore queues to server
     * @param {string=} reason
     * @return {Promise<any>}
     */
    releaseQueues(reason) {
        if (this._dataManager.dataStoreManager)
            this._dataManager.dataStoreManager.releaseQueue(reason);
        return this._apiManager.releaseQueue(reason);
    }
    /**
     * Get visitor properties
     * @param {Record<string, any>=} attributes An object of key-value pairs that are used for audience targeting
     * @return {Record<string, any>}
     */
    getVisitorProperties(attributes) {
        const { segments } = this._dataManager.getData(this._visitorId) || {};
        const visitorProperties = attributes
            ? objectDeepMerge(this._visitorProperties || {}, attributes)
            : this._visitorProperties;
        return objectDeepMerge(segments || {}, visitorProperties || {});
    }
}

const DEFAULT_DATA_REFRESH_INTERVAL = 300000; // in milliseconds (5 minutes)
/**
 * Core
 * @category Main
 * @constructor
 * @implements {CoreInterface}
 */
class Core {
    /**
     * @param {Config} config
     * @param {DataManagerInterface} dependencies.dataManager
     * @param {EventManagerInterface} dependencies.eventManager
     * @param {ExperienceManagerInterface} dependencies.experienceManager
     * @param {FeatureManagerInterface} dependencies.featureManager
     * @param {SegmentsManagerInterface} dependencies.segmentsManager
     * @param {ApiManagerInterface} dependencies.apiManager
     * @param {LogManagerInterface} dependencies.loggerManager
     */
    constructor(config, { dataManager, eventManager, experienceManager, featureManager, segmentsManager, apiManager, loggerManager }) {
        var _a, _b;
        this._initialized = false;
        this._environment = config === null || config === void 0 ? void 0 : config.environment;
        this._dataManager = dataManager;
        this._eventManager = eventManager;
        this._experienceManager = experienceManager;
        this._featureManager = featureManager;
        this._loggerManager = loggerManager;
        this._segmentsManager = segmentsManager;
        this._dataManager = dataManager;
        this._eventManager = eventManager;
        this._apiManager = apiManager;
        this._loggerManager = loggerManager;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'Core()', MESSAGES.CORE_CONSTRUCTOR, this);
        this.initialize(config);
    }
    /**
     * Initialize credentials, configData etc..
     * @param config
     */
    initialize(config) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!config)
            return;
        this._config = config;
        if (Object.prototype.hasOwnProperty.call(config, 'sdkKey') &&
            ((_a = config.sdkKey) === null || _a === void 0 ? void 0 : _a.length)) {
            // Get data by sdk key
            this.fetchConfig();
        }
        else if (Object.prototype.hasOwnProperty.call(config, 'data')) {
            this.data = config.data;
            this._dataManager.data = config.data;
            if (config.data['error']) {
                (_c = (_b = this._loggerManager) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.call(_b, 'Core.initialize()', {
                    error: config.data['error']
                });
            }
            else {
                this._eventManager.fire(SystemEvents.READY, null, null, true);
                (_e = (_d = this._loggerManager) === null || _d === void 0 ? void 0 : _d.trace) === null || _e === void 0 ? void 0 : _e.call(_d, 'Core.initialize()', MESSAGES.CORE_INITIALIZED);
                this._initialized = true;
            }
        }
        else {
            (_g = (_f = this._loggerManager) === null || _f === void 0 ? void 0 : _f.error) === null || _g === void 0 ? void 0 : _g.call(_f, 'Core.initialize()', ERROR_MESSAGES.SDK_OR_DATA_OBJECT_REQUIRED);
            this._eventManager.fire(SystemEvents.READY, {}, new Error(ERROR_MESSAGES.SDK_OR_DATA_OBJECT_REQUIRED), true);
        }
    }
    /**
     * Create visitor context
     * @param {string} visitorId A visitor id
     * @param {Record<string, any>=} visitorAttributes An object of key-value pairs that are used for audience and/or segments targeting
     * @return {ContextInterface | null}
     */
    createContext(visitorId, visitorAttributes) {
        if (!this._initialized)
            return null;
        return new Context(this._config, visitorId, {
            eventManager: this._eventManager,
            experienceManager: this._experienceManager,
            featureManager: this._featureManager,
            segmentsManager: this._segmentsManager,
            apiManager: this._apiManager,
            dataManager: this._dataManager,
            loggerManager: this._loggerManager
        }, visitorAttributes);
    }
    /**
     * Add event handler to event
     * @param {SystemEvents} event Event name
     * @param {function(args, err): void} fn A callback function which will be fired
     */
    on(event, fn) {
        this._eventManager.on(event, fn);
    }
    /**
     * Promisified ready event
     * @return {Promise<void>}
     */
    onReady() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._promise;
            return new Promise((resolve, reject) => {
                if (objectNotEmpty(this._dataManager.data)) {
                    resolve();
                }
                else {
                    reject(new Error(ERROR_MESSAGES.DATA_OBJECT_MISSING));
                }
            });
        });
    }
    /**
     * Fetch remote config data
     * @return {Promise<void>}
     */
    fetchConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
            this._promise = this._apiManager.getConfig();
            try {
                const data = yield this._promise;
                if (data['error']) {
                    this._dataManager.data = data;
                    (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, 'Core.fetchConfig()', {
                        error: data['error']
                    });
                }
                else {
                    (_d = (_c = this._loggerManager) === null || _c === void 0 ? void 0 : _c.trace) === null || _d === void 0 ? void 0 : _d.call(_c, 'Core.fetchConfig()', {
                        data
                    });
                    this._eventManager.fire(objectNotEmpty(this._dataManager.data)
                        ? SystemEvents.CONFIG_UPDATED
                        : SystemEvents.READY, null, null, true);
                    if (objectNotEmpty(this._dataManager.data)) {
                        (_f = (_e = this._loggerManager) === null || _e === void 0 ? void 0 : _e.trace) === null || _f === void 0 ? void 0 : _f.call(_e, 'Core.fetchConfig()', MESSAGES.CONFIG_DATA_UPDATED);
                    }
                    else {
                        (_h = (_g = this._loggerManager) === null || _g === void 0 ? void 0 : _g.trace) === null || _h === void 0 ? void 0 : _h.call(_g, 'Core.fetchConfig()', MESSAGES.CORE_INITIALIZED);
                        this._initialized = true;
                    }
                    this.data = data;
                    this._dataManager.data = data;
                    this._apiManager.setData(data);
                }
                // Update data periodically in background
                if (this._fetchConfigTimerID) {
                    clearTimeout(this._fetchConfigTimerID);
                }
                this._fetchConfigTimerID = setTimeout(() => this.fetchConfig(), ((_j = this._config) === null || _j === void 0 ? void 0 : _j.dataRefreshInterval) || DEFAULT_DATA_REFRESH_INTERVAL);
            }
            catch (error) {
                (_l = (_k = this._loggerManager) === null || _k === void 0 ? void 0 : _k.error) === null || _l === void 0 ? void 0 : _l.call(_k, 'Core.fetchConfig()', {
                    error: error.message
                });
            }
        });
    }
}

// This file is auto-generated by @hey-api/openapi-ts
/**
 * Type of the Audience. Can be one of the following: `permanent`, `transient`. For full-stack projects, `transient` is the only valid option, the rest will be ignored.
 * * **permanent** - A permanent audience is one that is checked only at the time the user is being bucketed into the experience
 * * **transient** - A transient audience is one that is checked every time the user is being bucketed into the experience
 *
 */
const ConfigAudienceTypes = {
    PERMANENT: 'permanent',
    TRANSIENT: 'transient'
};
/**
 * The way the list is processed. `any` means at least one element in the list is matched.
 * `all` means all elements in the list are matched. Default is any.
 *
 */
const GenericListMatchingOptions = {
    ANY: 'any',
    ALL: 'all'
};
/**
 * Variation status
 */
const VariationStatuses = {
    STOPPED: 'stopped',
    RUNNING: 'running'
};
/**
 * Type of the event. It can be a bucketing or a conversion event
 */
const eventType = {
    BUCKETING: 'bucketing',
    CONVERSION: 'conversion'
};

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
const DEFAULT_BATCH_SIZE = 1;
const DEFAULT_RELEASE_INTERVAL = 5000;
/**
 * Data Store wrapper
 * @category Modules
 * @constructor
 * @implements {DataStoreManagerInterface}
 */
class DataStoreManager {
    /**
     * @param {Config=} config
     * @param {Object=} dependencies
     * @param {Object=} dependencies.dataStore
     * @param {EventManagerInterface=} dependencies.eventManager
     * @param {LogManagerInterface=} dependencies.loggerManager
     */
    constructor(config, { dataStore, eventManager, loggerManager } = {}) {
        var _a, _b;
        this.batchSize = DEFAULT_BATCH_SIZE;
        this.releaseInterval = DEFAULT_RELEASE_INTERVAL;
        this._loggerManager = loggerManager;
        this._eventManager = eventManager;
        this.batchSize = Number((_a = config === null || config === void 0 ? void 0 : config.events) === null || _a === void 0 ? void 0 : _a.batch_size) || DEFAULT_BATCH_SIZE;
        this.releaseInterval =
            Number((_b = config === null || config === void 0 ? void 0 : config.events) === null || _b === void 0 ? void 0 : _b.release_interval) || DEFAULT_RELEASE_INTERVAL;
        this.dataStore = dataStore;
        this._mapper = (config === null || config === void 0 ? void 0 : config.mapper) || ((value) => value);
        this._requestsQueue = {};
    }
    set(key, data) {
        var _a, _b, _c, _d;
        try {
            (_b = (_a = this.dataStore) === null || _a === void 0 ? void 0 : _a.set) === null || _b === void 0 ? void 0 : _b.call(_a, key, data);
        }
        catch (error) {
            (_d = (_c = this._loggerManager) === null || _c === void 0 ? void 0 : _c.error) === null || _d === void 0 ? void 0 : _d.call(_c, 'DataStoreManager.set()', {
                error: error.message
            });
        }
    }
    get(key) {
        var _a, _b, _c, _d;
        try {
            return (_b = (_a = this.dataStore) === null || _a === void 0 ? void 0 : _a.get) === null || _b === void 0 ? void 0 : _b.call(_a, key);
        }
        catch (error) {
            (_d = (_c = this._loggerManager) === null || _c === void 0 ? void 0 : _c.error) === null || _d === void 0 ? void 0 : _d.call(_c, 'DataStoreManager.get()', {
                error: error.message
            });
        }
        return null;
    }
    enqueue(key, data) {
        var _a, _b;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataStoreManager.enqueue()', this._mapper({
            key: key,
            data: data
        }));
        const addData = {};
        addData[key] = data;
        this._requestsQueue = objectDeepMerge(this._requestsQueue, addData);
        if (Object.keys(this._requestsQueue).length >= this.batchSize) {
            this.releaseQueue('size');
        }
        else {
            if (Object.keys(this._requestsQueue).length === 1) {
                this.startQueue();
            }
        }
    }
    releaseQueue(reason) {
        var _a, _b, _c, _d;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.info) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataStoreManager.releaseQueue()', {
            reason: reason || ''
        });
        this.stopQueue();
        for (const key in this._requestsQueue) {
            this.set(key, this._requestsQueue[key]);
        }
        (_d = (_c = this._eventManager) === null || _c === void 0 ? void 0 : _c.fire) === null || _d === void 0 ? void 0 : _d.call(_c, SystemEvents.DATA_STORE_QUEUE_RELEASED, {
            reason: reason || ''
        });
    }
    stopQueue() {
        clearTimeout(this._requestsQueueTimerID);
    }
    startQueue() {
        this._requestsQueueTimerID = setTimeout(() => {
            this.releaseQueue('timeout');
        }, this.releaseInterval);
    }
    /**
     * dataStore setter
     * @param {any=} dataStore
     */
    set dataStore(dataStore) {
        var _a, _b;
        if (dataStore) {
            if (this.isValidDataStore(dataStore)) {
                this._dataStore = dataStore;
            }
            else {
                (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataStoreManager.dataStore.set()', ERROR_MESSAGES.DATA_STORE_NOT_VALID);
            }
        }
    }
    /**
     * dataStore getter
     */
    get dataStore() {
        return this._dataStore;
    }
    /**
     * Validates dataStore object
     * @param {any=} dataStore
     * @return {boolean}
     */
    isValidDataStore(dataStore) {
        return (typeof dataStore === 'object' &&
            typeof dataStore['get'] === 'function' &&
            typeof dataStore['set'] === 'function');
    }
}

const LOCAL_STORE_LIMIT = 10000;
/**
 * Provides logic for data. Stores bucket with help of dataStore if it's provided
 * @category Modules
 * @constructor
 * @implements {DataManagerInterface}
 */
class DataManager {
    /**
     * @param {Config} config
     * @param {Object} dependencies
     * @param {ApiManagerInterface} dependencies.apiManager
     * @param {BucketingManagerInterface} dependencies.bucketingManager
     * @param {RuleManagerInterface} dependencies.ruleManager
     * @param {LogManagerInterface} dependencies.loggerManager
     */
    constructor(config, { bucketingManager, ruleManager, eventManager, apiManager, loggerManager }, { asyncStorage = true } = {}) {
        var _a, _b, _c, _d, _e;
        this._dataEntities = DATA_ENTITIES;
        this._localStoreLimit = LOCAL_STORE_LIMIT;
        this._bucketedVisitors = new Map();
        this._environment = config === null || config === void 0 ? void 0 : config.environment;
        this._apiManager = apiManager;
        this._bucketingManager = bucketingManager;
        this._ruleManager = ruleManager;
        this._loggerManager = loggerManager;
        this._eventManager = eventManager;
        this._config = config;
        this._mapper = (config === null || config === void 0 ? void 0 : config.mapper) || ((value) => value);
        this._asyncStorage = asyncStorage;
        this._data = objectDeepValue(config, 'data');
        this._accountId = (_a = this._data) === null || _a === void 0 ? void 0 : _a.account_id;
        this._projectId = (_c = (_b = this._data) === null || _b === void 0 ? void 0 : _b.project) === null || _c === void 0 ? void 0 : _c.id;
        this.dataStoreManager = config === null || config === void 0 ? void 0 : config.dataStore;
        (_e = (_d = this._loggerManager) === null || _d === void 0 ? void 0 : _d.trace) === null || _e === void 0 ? void 0 : _e.call(_d, 'DataManager()', MESSAGES.DATA_CONSTRUCTOR, this);
    }
    set data(data) {
        var _a, _b, _c;
        if (this.isValidConfigData(data)) {
            this._data = data;
            this._accountId = data === null || data === void 0 ? void 0 : data.account_id;
            this._projectId = (_a = data === null || data === void 0 ? void 0 : data.project) === null || _a === void 0 ? void 0 : _a.id;
        }
        else {
            (_c = (_b = this._loggerManager) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.call(_b, 'DataManager.data.set()', ERROR_MESSAGES.CONFIG_DATA_NOT_VALID);
        }
    }
    /**
     * data getter
     */
    get data() {
        return this._data;
    }
    /**
     * dataStoreManager setter
     * @param {any=} dataStore
     */
    set dataStoreManager(dataStore) {
        this._dataStoreManager = null;
        if (dataStore) {
            this._dataStoreManager = new DataStoreManager(this._config, {
                dataStore: dataStore,
                eventManager: this._eventManager,
                loggerManager: this._loggerManager
            });
        }
    }
    /**
     * dataStoreManager getter
     */
    get dataStoreManager() {
        return this._dataStoreManager;
    }
    /**
     * Set dataStoreManager at run-time
     */
    setDataStore(dataStore) {
        this._dataStoreManager = null;
        if (dataStore) {
            this._dataStoreManager = new DataStoreManager(this._config, {
                dataStore: dataStore,
                eventManager: this._eventManager,
                loggerManager: this._loggerManager
            });
        }
    }
    /**
     * Validate locationProperties against locations rules and visitorProperties against audiences rules
     * @param {string} visitorId
     * @param {string} identity Value of the field which name is provided in identityField
     * @param {IdentityField=} identityField Defaults to 'key'
     * @param {BucketingAttributes} attributes
     * @param {Record<any, any>} attributes.locationProperties
     * @param {Record<any, any>} attributes.visitorProperties
     * @param {string=} attributes.environment
     * @return {ConfigExperience | RuleError}
     */
    matchRulesByField(visitorId, identity, identityField = 'key', attributes) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4;
        const { visitorProperties, locationProperties, ignoreLocationProperties, environment = this._environment } = attributes;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager.matchRulesByField()', this._mapper({
            visitorId: visitorId,
            identity: identity,
            identityField: identityField,
            visitorProperties: visitorProperties,
            locationProperties: locationProperties,
            ignoreLocationProperties: ignoreLocationProperties,
            environment: environment
        }));
        // Retrieve the experience
        const experience = this._getEntityByField(identity, 'experiences', identityField);
        // Check experience
        if (!experience) {
            (_d = (_c = this._loggerManager) === null || _c === void 0 ? void 0 : _c.debug) === null || _d === void 0 ? void 0 : _d.call(_c, 'DataManager.matchRulesByField()', MESSAGES.EXPERIENCE_NOT_FOUND, this._mapper({
                identity: identity,
                identityField: identityField
            }));
            return null;
        }
        // Retrieve archived experiences
        const archivedExperiences = this.getEntitiesList('archived_experiences');
        // Check whether the experience is archived
        const isArchivedExperience = !!archivedExperiences.find((id) => String(experience === null || experience === void 0 ? void 0 : experience.id) === String(id));
        if (isArchivedExperience) {
            (_f = (_e = this._loggerManager) === null || _e === void 0 ? void 0 : _e.debug) === null || _f === void 0 ? void 0 : _f.call(_e, 'DataManager.matchRulesByField()', MESSAGES.EXPERIENCE_ARCHIVED, this._mapper({
                identity: identity,
                identityField: identityField
            }));
            return null;
        }
        // Check environment
        const isEnvironmentMatch = (experience === null || experience === void 0 ? void 0 : experience.environment)
            ? experience.environment === environment
            : true; // skip if no environment
        if (!isEnvironmentMatch) {
            (_h = (_g = this._loggerManager) === null || _g === void 0 ? void 0 : _g.debug) === null || _h === void 0 ? void 0 : _h.call(_g, 'DataManager.matchRulesByField()', MESSAGES.EXPERIENCE_ENVIRONMENT_NOT_MATCH, this._mapper({
                identity: identity,
                identityField: identityField
            }));
            return null;
        }
        let matchedErrors = [];
        // Check that visitor id already bucketed and stored and skip bucketing logic
        const { bucketing } = this.getData(visitorId) || {};
        const { [experience.id.toString()]: variationId } = bucketing || {};
        let isBucketed = false;
        if (variationId &&
            this.retrieveVariation(experience.id, String(variationId))) {
            isBucketed = true;
        }
        // Check location rules against locationProperties
        let locationMatched = ignoreLocationProperties === true;
        if (!locationMatched && locationProperties) {
            if (Array.isArray(experience === null || experience === void 0 ? void 0 : experience.locations) && experience.locations.length) {
                let matchedLocations = [];
                // Get attached locations
                const locations = this.getItemsByIds(experience.locations, 'locations');
                if (locations.length) {
                    // Validate locationProperties against locations rules
                    // and trigger activated/deactivated events
                    matchedLocations = this.selectLocations(visitorId, locations, {
                        locationProperties,
                        identityField
                    });
                    // Return rule errors if present
                    matchedErrors = matchedLocations.filter((match) => Object.values(RuleError).includes(match));
                    if (matchedErrors.length)
                        return matchedErrors[0];
                }
                // If there are some matched locations
                locationMatched = Boolean(matchedLocations.length);
            }
            else if (experience === null || experience === void 0 ? void 0 : experience.site_area) {
                // Validate locationProperties against site area rules
                locationMatched = this._ruleManager.isRuleMatched(locationProperties, experience.site_area, 'SiteArea');
                // Return rule errors if present
                if (Object.values(RuleError).includes(locationMatched))
                    return locationMatched;
            }
            else {
                locationMatched = true; // Empty experience locations list means no restrictions
                (_k = (_j = this._loggerManager) === null || _j === void 0 ? void 0 : _j.info) === null || _k === void 0 ? void 0 : _k.call(_j, 'DataManager.matchRulesByField()', MESSAGES.LOCATION_NOT_RESTRICTED);
            }
        }
        if (!locationMatched) {
            (_m = (_l = this._loggerManager) === null || _l === void 0 ? void 0 : _l.debug) === null || _m === void 0 ? void 0 : _m.call(_l, 'DataManager.matchRulesByField()', MESSAGES.LOCATION_NOT_MATCH, this._mapper({
                locationProperties: locationProperties,
                [(experience === null || experience === void 0 ? void 0 : experience.locations)
                    ? 'experiences[].variations[].locations'
                    : 'experiences[].variations[].site_area']: (experience === null || experience === void 0 ? void 0 : experience.locations) || (experience === null || experience === void 0 ? void 0 : experience.site_area) || ''
            }));
            return null;
        }
        // Check audience rules against visitorProperties
        let audiences = [], segments = [], matchedAudiences = [], matchedSegments = [], audiencesToCheck = [], audiencesMatched = false, segmentsMatched = false;
        if (visitorProperties) {
            if (Array.isArray(experience === null || experience === void 0 ? void 0 : experience.audiences) && experience.audiences.length) {
                // Get attached transient and/or permnent audiences
                audiences = this.getItemsByIds(experience.audiences, 'audiences');
                // If visitor already bucketed into this experience, check only audiences of type transient
                audiencesToCheck = audiences.filter((audience) => !(isBucketed && audience.type === ConfigAudienceTypes.PERMANENT));
                if (audiencesToCheck.length) {
                    // Validate visitorProperties against audiences rules
                    matchedAudiences = this.filterMatchedRecordsWithRule(audiencesToCheck, visitorProperties, 'audience', identityField);
                    // Return rule errors if present
                    matchedErrors = matchedAudiences.filter((match) => Object.values(RuleError).includes(match));
                    if (matchedErrors.length)
                        return matchedErrors[0];
                    if (matchedAudiences.length) {
                        for (const item of matchedAudiences) {
                            (_p = (_o = this._loggerManager) === null || _o === void 0 ? void 0 : _o.info) === null || _p === void 0 ? void 0 : _p.call(_o, 'DataManager.matchRulesByField()', MESSAGES.AUDIENCE_MATCH.replace('#', item === null || item === void 0 ? void 0 : item[identityField]));
                        }
                    }
                    if (experience.settings.matching_options.audiences ===
                        GenericListMatchingOptions.ALL) {
                        audiencesMatched = Boolean(matchedAudiences.length === audiencesToCheck.length);
                    }
                    else {
                        audiencesMatched = Boolean(matchedAudiences.length);
                    }
                }
                else {
                    audiencesMatched = true; // Empty non-permanent experience audiences list means no restrictions
                    (_r = (_q = this._loggerManager) === null || _q === void 0 ? void 0 : _q.info) === null || _r === void 0 ? void 0 : _r.call(_q, 'DataManager.matchRulesByField()', MESSAGES.NON_PERMANENT_AUDIENCE_NOT_RESTRICTED);
                }
            }
            else {
                audiencesMatched = true; // Empty experience audiences list means no restrictions
                (_t = (_s = this._loggerManager) === null || _s === void 0 ? void 0 : _s.info) === null || _t === void 0 ? void 0 : _t.call(_s, 'DataManager.matchRulesByField()', MESSAGES.AUDIENCE_NOT_RESTRICTED);
            }
        }
        // Get attached segmentation audiences
        segments = this.getItemsByIds(experience.audiences, 'segments');
        if (segments.length) {
            // Validate custom segments against segmentations
            matchedSegments = this.filterMatchedCustomSegments(segments, visitorId);
            if (matchedSegments.length) {
                for (const item of matchedSegments) {
                    (_v = (_u = this._loggerManager) === null || _u === void 0 ? void 0 : _u.info) === null || _v === void 0 ? void 0 : _v.call(_u, 'DataManager.matchRulesByField()', MESSAGES.SEGMENTATION_MATCH.replace('#', item === null || item === void 0 ? void 0 : item[identityField]));
                }
            }
            segmentsMatched = Boolean(matchedSegments.length);
        }
        else {
            segmentsMatched = true; // Empty experience segmentation list means no restrictions
            (_x = (_w = this._loggerManager) === null || _w === void 0 ? void 0 : _w.info) === null || _x === void 0 ? void 0 : _x.call(_w, 'DataManager.matchRulesByField()', MESSAGES.SEGMENTATION_NOT_RESTRICTED);
        }
        // If there are some matched audiences
        if (audiencesMatched && segmentsMatched) {
            // And experience has variations
            if ((experience === null || experience === void 0 ? void 0 : experience.variations) && ((_y = experience === null || experience === void 0 ? void 0 : experience.variations) === null || _y === void 0 ? void 0 : _y.length)) {
                (_0 = (_z = this._loggerManager) === null || _z === void 0 ? void 0 : _z.info) === null || _0 === void 0 ? void 0 : _0.call(_z, 'DataManager.matchRulesByField()', MESSAGES.EXPERIENCE_RULES_MATCHED);
                return experience;
            }
            else {
                (_2 = (_1 = this._loggerManager) === null || _1 === void 0 ? void 0 : _1.debug) === null || _2 === void 0 ? void 0 : _2.call(_1, 'DataManager.matchRulesByField()', MESSAGES.VARIATIONS_NOT_FOUND, this._mapper({
                    visitorProperties: visitorProperties,
                    audiences: audiences
                }));
            }
        }
        else {
            (_4 = (_3 = this._loggerManager) === null || _3 === void 0 ? void 0 : _3.debug) === null || _4 === void 0 ? void 0 : _4.call(_3, 'DataManager.matchRulesByField()', MESSAGES.AUDIENCE_NOT_MATCH, this._mapper({
                visitorProperties: visitorProperties,
                audiences: audiences
            }));
        }
        return null;
    }
    /**
     * Retrieve variation for visitor
     * @param {string} visitorId
     * @param {string} identity Value of the field which name is provided in identityField
     * @param {IdentityField=} identityField Defaults to 'key'
     * @param {BucketingAttributes} attributes
     * @param {Record<any, any>} attributes.locationProperties
     * @param {Record<any, any>} attributes.visitorProperties
     * @param {boolean=} attributes.updateVisitorProperties
     * @param {string=} attributes.forceVariationId
     * @param {boolean=} attributes.enableTracking Defaults to `true`
     * @param {boolean=} attributes.asyncStorage Defaults to `true`
     * @param {string=} attributes.environment
     * @return {BucketedVariation | RuleError | BucketingError}
     * @private
     */
    _getBucketingByField(visitorId, identity, identityField = 'key', attributes) {
        var _a, _b;
        const { visitorProperties, locationProperties, updateVisitorProperties, forceVariationId, enableTracking = true, ignoreLocationProperties, environment = this._environment } = attributes;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager._getBucketingByField()', this._mapper({
            visitorId: visitorId,
            identity: identity,
            identityField: identityField,
            visitorProperties: visitorProperties,
            locationProperties: locationProperties,
            forceVariationId: forceVariationId,
            enableTracking: enableTracking,
            ignoreLocationProperties: ignoreLocationProperties,
            environment: environment
        }));
        // Retrieve the experience
        const experience = this.matchRulesByField(visitorId, identity, identityField, {
            visitorProperties,
            locationProperties,
            ignoreLocationProperties,
            environment
        });
        if (experience) {
            if (Object.values(RuleError).includes(experience)) {
                return experience;
            }
            return this._retrieveBucketing(visitorId, visitorProperties, updateVisitorProperties, experience, forceVariationId, enableTracking);
        }
        return null;
    }
    /**
     * Retrieve bucketing for Visitor
     * @param {string} visitorId
     * @param {Record<string, any> | null} visitorProperties
     * @param {boolean} updateVisitorProperties
     * @param {ConfigExperience} experience
     * @param {string=} forceVariationId
     * @param {boolean=} enableTracking Defaults to `true`
     * @return {BucketedVariation | BucketingError}
     * @private
     */
    _retrieveBucketing(visitorId, visitorProperties, updateVisitorProperties, experience, forceVariationId, enableTracking = true) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
        if (!visitorId || !experience)
            return null;
        if (!(experience === null || experience === void 0 ? void 0 : experience.id))
            return null;
        let variation = null, variationId, bucketedVariation = null, bucketingAllocation;
        const storeKey = this.getStoreKey(visitorId);
        if (forceVariationId &&
            (variation = this.retrieveVariation(experience.id, String(forceVariationId)))) {
            variationId = forceVariationId;
            // If it's found log debug info. The return value will be formed next step
            (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.info) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager._retrieveBucketing()', MESSAGES.BUCKETED_VISITOR_FORCED.replace('#', `#${forceVariationId}`));
            (_d = (_c = this._loggerManager) === null || _c === void 0 ? void 0 : _c.debug) === null || _d === void 0 ? void 0 : _d.call(_c, 'DataManager._retrieveBucketing()', this._mapper({
                storeKey: storeKey,
                visitorId: visitorId,
                variationId: forceVariationId
            }));
        }
        // Check that visitor id already bucketed and stored and skip bucketing logic
        const { bucketing, segments } = this.getData(visitorId) || {};
        const { [experience.id.toString()]: storedVariationId } = bucketing || {};
        if (storedVariationId &&
            (!variationId || String(variationId) === String(storedVariationId)) && // variation might be forced but already bucketed before
            (variation = this.retrieveVariation(experience.id, String(storedVariationId)))) {
            variationId = storedVariationId;
            // If it's found log debug info. The return value will be formed next step
            (_f = (_e = this._loggerManager) === null || _e === void 0 ? void 0 : _e.info) === null || _f === void 0 ? void 0 : _f.call(_e, 'DataManager._retrieveBucketing()', MESSAGES.BUCKETED_VISITOR_FOUND.replace('#', `#${variationId}`));
            (_h = (_g = this._loggerManager) === null || _g === void 0 ? void 0 : _g.debug) === null || _h === void 0 ? void 0 : _h.call(_g, 'DataManager._retrieveBucketing()', this._mapper({
                storeKey: storeKey,
                visitorId: visitorId,
                variationId: variationId
            }));
        }
        else {
            // Build buckets where key is variation id and value is traffic distribution
            const buckets = experience.variations
                .filter((variation) => (variation === null || variation === void 0 ? void 0 : variation.status)
                ? variation.status === VariationStatuses.RUNNING
                : true)
                .filter((variation) => (variation === null || variation === void 0 ? void 0 : variation.traffic_allocation) > 0 || // zero-traffic means stopped variation
                isNaN(variation === null || variation === void 0 ? void 0 : variation.traffic_allocation) // no allocation means 100% traffic
            )
                .reduce((bucket, variation) => {
                if (variation === null || variation === void 0 ? void 0 : variation.id)
                    bucket[variation.id] = (variation === null || variation === void 0 ? void 0 : variation.traffic_allocation) || 100.0;
                return bucket;
            }, {});
            // Select bucket based for provided visitor id
            const bucketing = this._bucketingManager.getBucketForVisitor(buckets, visitorId, ((_k = (_j = this._config) === null || _j === void 0 ? void 0 : _j.bucketing) === null || _k === void 0 ? void 0 : _k.excludeExperienceIdHash)
                ? null
                : { experienceId: experience.id.toString() });
            variationId = variationId || (bucketing === null || bucketing === void 0 ? void 0 : bucketing.variationId); // variation might be forced
            bucketingAllocation = bucketing === null || bucketing === void 0 ? void 0 : bucketing.bucketingAllocation;
            // Return bucketing errors if present
            if (!variationId) {
                (_m = (_l = this._loggerManager) === null || _l === void 0 ? void 0 : _l.debug) === null || _m === void 0 ? void 0 : _m.call(_l, 'DataManager._retrieveBucketing()', ERROR_MESSAGES.UNABLE_TO_SELECT_BUCKET_FOR_VISITOR, this._mapper({
                    visitorId: visitorId,
                    experience: experience,
                    buckets: buckets,
                    bucketing: bucketing
                }));
                return BucketingError.VARIAION_NOT_DECIDED;
            }
            (_p = (_o = this._loggerManager) === null || _o === void 0 ? void 0 : _o.info) === null || _p === void 0 ? void 0 : _p.call(_o, 'DataManager._retrieveBucketing()', MESSAGES.BUCKETED_VISITOR.replace('#', `#${variationId}`));
            // Store the data
            if (updateVisitorProperties) {
                this.putData(visitorId, Object.assign({ bucketing: {
                        [experience.id.toString()]: variationId
                    } }, (visitorProperties ? { segments: visitorProperties } : {})));
            }
            else {
                this.putData(visitorId, {
                    bucketing: { [experience.id.toString()]: variationId }
                });
            }
            if (enableTracking) {
                // Enqueue bucketing event to api
                const bucketingEvent = {
                    experienceId: experience.id.toString(),
                    variationId: variationId.toString()
                };
                const visitorEvent = {
                    eventType: eventType.BUCKETING,
                    data: bucketingEvent
                };
                const visitorSegments = this._ruleManager.isUsingCustomInterface(visitorProperties)
                    ? ((_q = visitorProperties === null || visitorProperties === void 0 ? void 0 : visitorProperties.get) === null || _q === void 0 ? void 0 : _q.call(visitorProperties)) || {}
                    : segments;
                this._apiManager.enqueue(visitorId, visitorEvent, visitorSegments);
                (_s = (_r = this._loggerManager) === null || _r === void 0 ? void 0 : _r.trace) === null || _s === void 0 ? void 0 : _s.call(_r, 'DataManager._retrieveBucketing()', this._mapper({
                    visitorEvent
                }));
            }
            // Retrieve and return variation
            variation = this.retrieveVariation(experience.id, String(variationId));
        }
        // Build the response as bucketed variation object
        if (variation) {
            bucketedVariation = Object.assign(Object.assign({
                experienceId: experience === null || experience === void 0 ? void 0 : experience.id,
                experienceName: experience === null || experience === void 0 ? void 0 : experience.name,
                experienceKey: experience === null || experience === void 0 ? void 0 : experience.key
            }, { bucketingAllocation }), variation);
        }
        return bucketedVariation;
    }
    /**
     * @param {string} experienceId
     * @param {string} variationId
     * @return {ExperienceVariationConfig}
     * @private
     */
    retrieveVariation(experienceId, variationId) {
        return this.getSubItem('experiences', experienceId, 'variations', variationId, 'id', 'id');
    }
    reset() {
        this._bucketedVisitors = new Map();
    }
    /**
     * @param {string} visitorId
     * @param {StoreData} newData
     * @private
     */
    putData(visitorId, newData = {}) {
        const storeKey = this.getStoreKey(visitorId);
        const storeData = this.getData(visitorId) || {};
        const isChanged = !objectDeepEqual(storeData, newData);
        if (isChanged) {
            const updatedData = objectDeepMerge(storeData, newData);
            this._bucketedVisitors.set(storeKey, updatedData);
            if (this._bucketedVisitors.size > this._localStoreLimit) {
                // Delete one of the oldest record
                for (const [key] of this._bucketedVisitors) {
                    this._bucketedVisitors.delete(key);
                    break;
                }
            }
            if (this.dataStoreManager) {
                const { segments: storedSegments = {} } = storeData, data = __rest(storeData, ["segments"]);
                const { segments: reportSegments = {} } = this.filterReportSegments(storedSegments);
                const { segments: newSegments } = this.filterReportSegments((newData === null || newData === void 0 ? void 0 : newData.segments) || {});
                if (newSegments) {
                    if (this._asyncStorage) {
                        // Enqueue to store in dataStore
                        this.dataStoreManager.enqueue(storeKey, objectDeepMerge(data, {
                            segments: Object.assign(Object.assign({}, reportSegments), newSegments)
                        }));
                    }
                    else {
                        // Save now to store in dataStore
                        this.dataStoreManager.set(storeKey, objectDeepMerge(data, {
                            segments: Object.assign(Object.assign({}, reportSegments), newSegments)
                        }));
                    }
                }
                else {
                    if (this._asyncStorage) {
                        // Enqueue to store in dataStore
                        this.dataStoreManager.enqueue(storeKey, updatedData);
                    }
                    else {
                        // Save now to store in dataStore
                        this.dataStoreManager.set(storeKey, updatedData);
                    }
                }
            }
        }
    }
    /**
     * @param {string} visitorId
     * @return {StoreData} variation id
     * @private
     */
    getData(visitorId) {
        const storeKey = this.getStoreKey(visitorId);
        const memoryData = this._bucketedVisitors.get(storeKey) || null;
        if (this.dataStoreManager) {
            return objectDeepMerge(memoryData || {}, this.dataStoreManager.get(storeKey) || {});
        }
        return memoryData;
    }
    /**
     * @param {string} visitorId
     * @return {string} storeKey
     * @private
     */
    getStoreKey(visitorId) {
        return `${this._accountId}-${this._projectId}-${visitorId}`;
    }
    /**
     *
     * @param {string} visitorId
     * @param {Array<Record<string, any>>} items
     * @param {Record<string, any>} attributes.locationProperties
     * @param {IdentityField=} attributes.identityField
     * @param {boolean=} attributes.forceEvent
     * @returns {Array<Record<string, any> | RuleError>}
     */
    selectLocations(visitorId, items, attributes) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
        const { locationProperties, identityField = 'key', forceEvent } = attributes;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager.selectLocations()', this._mapper({
            items: items,
            locationProperties: locationProperties
        }));
        // Get locations from DataStore
        const { locations = [] } = this.getData(visitorId) || {};
        const matchedRecords = [];
        let match;
        if (arrayNotEmpty(items)) {
            for (let i = 0, length = items.length; i < length; i++) {
                if (!((_c = items === null || items === void 0 ? void 0 : items[i]) === null || _c === void 0 ? void 0 : _c.rules))
                    continue;
                match = this._ruleManager.isRuleMatched(locationProperties, items[i].rules, `ConfigLocation #${items[i][identityField]}`);
                const identity = (_f = (_e = (_d = items === null || items === void 0 ? void 0 : items[i]) === null || _d === void 0 ? void 0 : _d[identityField]) === null || _e === void 0 ? void 0 : _e.toString) === null || _f === void 0 ? void 0 : _f.call(_e);
                if (match === true) {
                    (_h = (_g = this._loggerManager) === null || _g === void 0 ? void 0 : _g.info) === null || _h === void 0 ? void 0 : _h.call(_g, 'DataManager.selectLocations()', MESSAGES.LOCATION_MATCH.replace('#', `#${identity}`));
                    if (!locations.includes(identity) || forceEvent) {
                        this._eventManager.fire(SystemEvents.LOCATION_ACTIVATED, {
                            visitorId,
                            location: {
                                id: (_j = items === null || items === void 0 ? void 0 : items[i]) === null || _j === void 0 ? void 0 : _j.id,
                                key: (_k = items === null || items === void 0 ? void 0 : items[i]) === null || _k === void 0 ? void 0 : _k.key,
                                name: (_l = items === null || items === void 0 ? void 0 : items[i]) === null || _l === void 0 ? void 0 : _l.name
                            }
                        }, null, true);
                        (_o = (_m = this._loggerManager) === null || _m === void 0 ? void 0 : _m.info) === null || _o === void 0 ? void 0 : _o.call(_m, 'DataManager.selectLocations()', MESSAGES.LOCATION_ACTIVATED.replace('#', `#${identity}`));
                    }
                    if (!locations.includes(identity))
                        locations.push(identity);
                    matchedRecords.push(items[i]);
                }
                else if (match !== false) {
                    // catch rule errors
                    matchedRecords.push(match);
                }
                else if (match === false && locations.includes(identity)) {
                    this._eventManager.fire(SystemEvents.LOCATION_DEACTIVATED, {
                        visitorId,
                        location: {
                            id: (_p = items === null || items === void 0 ? void 0 : items[i]) === null || _p === void 0 ? void 0 : _p.id,
                            key: (_q = items === null || items === void 0 ? void 0 : items[i]) === null || _q === void 0 ? void 0 : _q.key,
                            name: (_r = items === null || items === void 0 ? void 0 : items[i]) === null || _r === void 0 ? void 0 : _r.name
                        }
                    }, null, true);
                    const locationIndex = locations.findIndex((location) => location === identity);
                    locations.splice(locationIndex, 1);
                    (_t = (_s = this._loggerManager) === null || _s === void 0 ? void 0 : _s.info) === null || _t === void 0 ? void 0 : _t.call(_s, 'DataManager.selectLocations()', MESSAGES.LOCATION_DEACTIVATED.replace('#', `#${identity}`));
                }
            }
        }
        // Store the data
        this.putData(visitorId, {
            locations
        });
        (_v = (_u = this._loggerManager) === null || _u === void 0 ? void 0 : _u.debug) === null || _v === void 0 ? void 0 : _v.call(_u, 'DataManager.selectLocations()', this._mapper({
            matchedRecords: matchedRecords
        }));
        return matchedRecords;
    }
    /**
     * Retrieve variation for visitor
     * @param {string} visitorId
     * @param {string} key
     * @param {BucketingAttributes} attributes
     * @param {Record<any, any>} attributes.locationProperties
     * @param {Record<any, any>} attributes.visitorProperties
     * @param {boolean=} attributes.updateVisitorProperties
     * @param {boolean=} attributes.enableTracking
     * @param {string=} attributes.environment
     * @return {BucketedVariation | RuleError}
     */
    getBucketing(visitorId, key, attributes) {
        return this._getBucketingByField(visitorId, key, 'key', attributes);
    }
    /**
     * Retrieve variation for Visitor
     * @param {string} visitorId
     * @param {string} id
     * @param {BucketingAttributes} attributes
     * @param {Record<any, any>} attributes.locationProperties
     * @param {Record<any, any>} attributes.visitorProperties
     * @param {boolean=} attributes.updateVisitorProperties
     * @param {boolean=} attributes.enableTracking
     * @param {string=} attributes.environment
     * @return {BucketedVariation | RuleError}
     */
    getBucketingById(visitorId, id, attributes) {
        return this._getBucketingByField(visitorId, id, 'id', attributes);
    }
    /**
     * Process conversion event
     * @param {string} visitorId
     * @param {string} goalId
     * @param {Record<string, any>=} goalRule An object of key-value pairs that are used for goal matching
     * @param {Array<GoalData>} goalData An array of object of key-value pairs
     * @param {VisitorSegments} segments
     * @param {Record<ConversionSettingKey, number | string | boolean>} conversionSetting An object of key-value pairs that are used for tracking settings
     */
    convert(visitorId, goalId, goalRule, goalData, segments, conversionSetting) {
        var _a, _b, _c, _d, _e, _f;
        const goal = typeof goalId === 'string'
            ? this.getEntity(goalId, 'goals')
            : this.getEntityById(goalId, 'goals');
        if (!(goal === null || goal === void 0 ? void 0 : goal.id)) {
            (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager.convert()', MESSAGES.GOAL_NOT_FOUND);
            return;
        }
        if (goalRule) {
            if (!(goal === null || goal === void 0 ? void 0 : goal.rules))
                return;
            const ruleMatched = this._ruleManager.isRuleMatched(goalRule, goal.rules, `ConfigGoal #${goalId}`);
            // Return rule errors if present
            if (Object.values(RuleError).includes(ruleMatched))
                return ruleMatched;
            if (!ruleMatched) {
                (_d = (_c = this._loggerManager) === null || _c === void 0 ? void 0 : _c.error) === null || _d === void 0 ? void 0 : _d.call(_c, 'DataManager.convert()', MESSAGES.GOAL_RULE_NOT_MATCH);
                return;
            }
        }
        const forceMultipleTransactions = conversionSetting === null || conversionSetting === void 0 ? void 0 : conversionSetting[ConversionSettingKey.FORCE_MULTIPLE_TRANSACTIONS];
        // Check that goal id already triggred and stored and skip tracking conversion event
        const { bucketing: bucketingData, goals: { [goalId.toString()]: goalTriggered } = {} } = this.getData(visitorId) || {};
        if (goalTriggered) {
            (_f = (_e = this._loggerManager) === null || _e === void 0 ? void 0 : _e.debug) === null || _f === void 0 ? void 0 : _f.call(_e, 'DataManager.convert()', MESSAGES.GOAL_FOUND.replace('#', goalId.toString()), this._mapper({
                visitorId: visitorId,
                goalId: goalId
            }));
            if (!forceMultipleTransactions)
                return;
        }
        // Store the data
        this.putData(visitorId, {
            goals: { [goalId.toString()]: true }
        });
        // Send conversion event
        if (!goalTriggered)
            sendConversion.call(this);
        // Send transaction event
        if (goalData && (!goalTriggered || forceMultipleTransactions))
            sendTransaction.call(this);
        function sendConversion() {
            var _a, _b;
            const data = {
                goalId: goal.id
            };
            if (bucketingData)
                data.bucketingData = bucketingData;
            const event = {
                eventType: eventType.CONVERSION,
                data
            };
            this._apiManager.enqueue(visitorId, event, segments);
            (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager.convert()', this._mapper({
                event
            }));
        }
        function sendTransaction() {
            var _a, _b;
            const data = {
                goalId: goal.id,
                goalData
            };
            if (bucketingData)
                data.bucketingData = bucketingData;
            const event = {
                eventType: eventType.CONVERSION,
                data
            };
            this._apiManager.enqueue(visitorId, event, segments);
            (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager.convert()', this._mapper({
                event
            }));
        }
        return true;
    }
    /**
     * Get audiences that meet the visitorProperties
     * @param {Array<Record<any, any>>} items
     * @param {Record<string, any>} visitorProperties
     * @return {Array<Record<string, any> | RuleError>}
     */
    filterMatchedRecordsWithRule(items, visitorProperties, entityType, field = 'id') {
        var _a, _b, _c, _d, _e;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager.filterMatchedRecordsWithRule()', this._mapper({
            items: items,
            visitorProperties: visitorProperties
        }));
        const matchedRecords = [];
        let match;
        if (arrayNotEmpty(items)) {
            for (let i = 0, length = items.length; i < length; i++) {
                if (!((_c = items === null || items === void 0 ? void 0 : items[i]) === null || _c === void 0 ? void 0 : _c.rules))
                    continue;
                match = this._ruleManager.isRuleMatched(visitorProperties, items[i].rules, `${camelCase(entityType)} #${items[i][field]}`);
                if (match === true) {
                    matchedRecords.push(items[i]);
                }
                else if (match !== false) {
                    // catch rule errors
                    matchedRecords.push(match);
                }
            }
        }
        (_e = (_d = this._loggerManager) === null || _d === void 0 ? void 0 : _d.debug) === null || _e === void 0 ? void 0 : _e.call(_d, 'DataManager.filterMatchedRecordsWithRule()', this._mapper({
            matchedRecords: matchedRecords
        }));
        return matchedRecords;
    }
    /**
     * Get audiences that meet the custom segments
     * @param {Array<Record<any, any>>} items
     * @param {string} visitorId
     * @return {Array<Record<string, any>>}
     */
    filterMatchedCustomSegments(items, visitorId) {
        var _a, _b, _c, _d, _e;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager.filterMatchedCustomSegments()', this._mapper({
            items: items,
            visitorId: visitorId
        }));
        // Get custom segments ID from DataStore
        const { segments: { [SegmentsKeys.CUSTOM_SEGMENTS]: customSegments = [] } = {} } = this.getData(visitorId) || {};
        const matchedRecords = [];
        if (arrayNotEmpty(items)) {
            for (let i = 0, length = items.length; i < length; i++) {
                if (!((_c = items === null || items === void 0 ? void 0 : items[i]) === null || _c === void 0 ? void 0 : _c.id))
                    continue;
                if (customSegments.includes(items[i].id)) {
                    matchedRecords.push(items[i]);
                }
            }
        }
        (_e = (_d = this._loggerManager) === null || _d === void 0 ? void 0 : _d.debug) === null || _e === void 0 ? void 0 : _e.call(_d, 'DataManager.filterMatchedCustomSegments()', this._mapper({
            matchedRecords: matchedRecords
        }));
        return matchedRecords;
    }
    /**
     * Extract report segments from other attribues in Visitor properties
     * @param {Record<string, any>=} visitorProperties An object of key-value pairs that are used for audience targeting
     * @return {Record<string, any>}
     */
    filterReportSegments(visitorProperties) {
        const segmentsKeys = Object.values(SegmentsKeys).map((key) => key);
        const segments = {};
        const properties = {};
        for (const key in visitorProperties) {
            if (segmentsKeys.includes(key)) {
                segments[key] = visitorProperties[key];
            }
            else {
                properties[key] = visitorProperties[key];
            }
        }
        return {
            properties: Object.keys(properties).length ? properties : null,
            segments: Object.keys(segments).length ? segments : null
        };
    }
    /**
     * Get list of data entities
     * @param {string} entityType
     * @return {Array<Entity | string>}
     */
    getEntitiesList(entityType) {
        var _a, _b;
        let list = [];
        const mappedEntityType = DATA_ENTITIES_MAP[entityType] || entityType;
        if (this._dataEntities.indexOf(mappedEntityType) !== -1) {
            list = objectDeepValue(this._data, mappedEntityType) || [];
        }
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager.getEntitiesList()', this._mapper({
            entityType: mappedEntityType,
            list: list
        }));
        return list;
    }
    /**
     * Get list of data entities grouped by field
     * @param {string} entityType
     * @param {IdentityField=} field
     * @return {Record<string, Entity>}
     */
    getEntitiesListObject(entityType, field = 'id') {
        return this.getEntitiesList(entityType).reduce((target, entity) => {
            target[entity[field]] = entity;
            return target;
        }, {});
    }
    /**
     *
     * @param {string} identity Value of the field which name is provided in identityField
     * @param {string} entityType
     * @param {IdentityField=} identityField Defaults to 'key'
     * @return {Entity}
     * @private
     */
    _getEntityByField(identity, entityType, identityField = 'key') {
        var _a, _b, _c;
        const mappedEntityType = DATA_ENTITIES_MAP[entityType] || entityType;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager._getEntityByField()', this._mapper({
            identity: identity,
            entityType: mappedEntityType,
            identityField: identityField
        }));
        const list = this.getEntitiesList(mappedEntityType);
        if (arrayNotEmpty(list)) {
            for (let i = 0, length = list.length; i < length; i++) {
                if (list[i] && String((_c = list[i]) === null || _c === void 0 ? void 0 : _c[identityField]) === String(identity)) {
                    return list[i];
                }
            }
        }
        return null;
    }
    /**
     * Find the entity in list by id
     * @param {string} key
     * @param {string} entityType
     * @return {Entity}
     */
    getEntity(key, entityType) {
        return this._getEntityByField(key, entityType, 'key');
    }
    /**
     * Find the entity in list by keys
     * @param {Array<string>} keys
     * @param {string} entityType
     * @return {Array<Entity>}
     */
    getEntities(keys, entityType) {
        return this.getItemsByKeys(keys, entityType);
    }
    /**
     * Find the entity in list by id
     * @param {string} id
     * @param {string} entityType
     * @return {Entity}
     */
    getEntityById(id, entityType) {
        return this._getEntityByField(id, entityType, 'id');
    }
    /**
     * Find the entity in list by ids
     * @param {Array<string>} ids
     * @param {string} entityType
     * @return {Array<Entity>}
     */
    getEntitiesByIds(ids, entityType) {
        return this.getItemsByIds(ids, entityType);
    }
    /**
     * Find the items in list by  keys
     * @param {Array<string>} keys
     * @param {string} path
     * @return {Array<Record<string, any>>}
     */
    getItemsByKeys(keys, path) {
        var _a;
        const list = this.getEntitiesList(path);
        const items = [];
        if (arrayNotEmpty(list)) {
            for (let i = 0, length = list.length; i < length; i++) {
                if (keys.indexOf((_a = list[i]) === null || _a === void 0 ? void 0 : _a.key) !== -1) {
                    items.push(list[i]);
                }
            }
        }
        return items;
    }
    /**
     * Find the items in list by ids
     * @param {Array<string>} ids
     * @param {String} path
     * @return {Array<Record<string, any>>}
     */
    getItemsByIds(ids, path) {
        var _a, _b, _c;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'DataManager.getItemsByIds()', this._mapper({
            ids: ids,
            path: path
        }));
        const items = [];
        if (arrayNotEmpty(ids)) {
            const list = this.getEntitiesList(path);
            if (arrayNotEmpty(list)) {
                for (let i = 0, length = list.length; i < length; i++) {
                    if (ids.indexOf((_c = list[i]) === null || _c === void 0 ? void 0 : _c.id) !== -1) {
                        items.push(list[i]);
                    }
                }
            }
        }
        return items;
    }
    /**
     * Find nested item
     * @param {string} entityType
     * @param {string|number} entityIdentity
     * @param {string} subEntityType
     * @param {string|number} subEntityIdentity
     * @param {IdentityField} identityField
     * @param {IdentityField} subIdentityField
     * @return {Record<any, any>}
     */
    getSubItem(entityType, entityIdentity, subEntityType, subEntityIdentity, identityField, subIdentityField) {
        const entity = this._getEntityByField(entityIdentity, entityType, identityField);
        for (const subEntity of entity[subEntityType]) {
            if (subEntity[subIdentityField] === subEntityIdentity) {
                return subEntity;
            }
        }
        return null;
    }
    /**
     * Validates data object
     * @param data
     * @return {boolean}
     */
    isValidConfigData(data) {
        var _a;
        return (objectNotEmpty(data) &&
            ((!!(data === null || data === void 0 ? void 0 : data.account_id) && !!((_a = data === null || data === void 0 ? void 0 : data.project) === null || _a === void 0 ? void 0 : _a.id)) || Boolean(data['error'])));
    }
}

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * Event wrapper
 * @category Modules
 * @constructor
 * @implements {EventManagerInterface}
 */
class EventManager {
    /**
     * @param {Config} config
     * @param {Object} dependencies
     * @param {LogManagerInterface=} dependencies.loggerManager
     */
    constructor(config, { loggerManager } = {}) {
        this._listeners = {};
        this._deferred = {};
        this._loggerManager = loggerManager;
        this._mapper = (config === null || config === void 0 ? void 0 : config.mapper) || ((value) => value);
    }
    /**
     * Add listener for event
     * @param {SystemEvents | string} event Event name
     * @param {function} fn Callback function
     */
    on(event, fn) {
        var _a, _b;
        (this._listeners[event] = this._listeners[event] || []).push(fn);
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'EventManager.on()', { event: event });
        if (Object.hasOwnProperty.call(this._deferred, event)) {
            this.fire(event, this._deferred[event].args, this._deferred[event].err);
        }
    }
    /**
     * Remove all listeners from event
     * @param event
     */
    removeListeners(event) {
        if (Object.hasOwnProperty.call(this._listeners, event)) {
            delete this._listeners[event];
        }
        if (Object.hasOwnProperty.call(this._deferred, event)) {
            delete this._deferred[event];
        }
    }
    /**
     * Fire event with provided arguments and/or errors
     * @param {SystemEvents | string} event Event name
     * @param {Object=} args
     * @param {Error=} err
     * @param {boolean=} deferred Allows to fire listeners which were subscribed after event is fired
     */
    fire(event, args = null, err = null, deferred = false) {
        var _a, _b, _c, _d;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, 'EventManager.fire()', this._mapper({
            event: event,
            args: args,
            err: err,
            deferred: deferred
        }));
        for (const fn of this._listeners[event] || []) {
            if (Object.hasOwnProperty.call(this._listeners, event) &&
                typeof fn === 'function') {
                try {
                    fn.apply(null, [this._mapper(args), err]);
                }
                catch (error) {
                    (_d = (_c = this._loggerManager) === null || _c === void 0 ? void 0 : _c.error) === null || _d === void 0 ? void 0 : _d.call(_c, 'EventManager.fire()', error);
                }
            }
        }
        if (deferred && !Object.hasOwnProperty.call(this._deferred, event)) {
            this._deferred[event] = { args, err };
        }
    }
}

/**
 * Provides experiences specific logic
 * @category Modules
 * @constructor
 * @implements {ExperienceManagerInterface}
 */
class ExperienceManager {
    /**
     * @param config
     * @param {Record<string, any>} dependencies
     * @param {DataManagerInterface} dependencies.dataManager
     * @param {LogManagerInterface=} dependencies.loggerManager
     */
    constructor(config, { dataManager, loggerManager }) {
        var _a, _b;
        this._dataManager = dataManager;
        this._loggerManager = loggerManager;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'ExperienceManager()', MESSAGES.EXPERIENCE_CONSTRUCTOR);
    }
    /**
     * Get a list of all entities
     * @return {Array<ConfigExperience>} Experiences list
     */
    getList() {
        return this._dataManager.getEntitiesList('experiences');
    }
    /**
     * Get the entity by key
     * @param {string} key
     * @return {ConfigExperience} An experience
     */
    getExperience(key) {
        return this._dataManager.getEntity(key, 'experiences');
    }
    /**
     * Get the entity by id
     * @param {string} id
     * @return {ConfigExperience} Get single experience
     */
    getExperienceById(id) {
        return this._dataManager.getEntityById(id, 'experiences');
    }
    /**
     * Get specific entities by array of keys
     * @param {Array<string>} keys
     * @return {Array<ConfigExperience>}
     */
    getExperiences(keys) {
        return this._dataManager.getItemsByKeys(keys, 'experiences');
    }
    /**
     * Select variation for specific visitor
     * @param {string} visitorId
     * @param {string} experienceKey
     * @param {BucketingAttributes} attributes
     * @param {Record<any, any>} attributes.locationProperties
     * @param {Record<any, any>} attributes.visitorProperties
     * @param {boolean=} attributes.updateVisitorProperties
     * @param {string=} attributes.forceVariationId
     * @param {boolean=} attributes.enableTracking
     * @param {string=} attributes.environment
     * @return {BucketedVariation | RuleError | BucketingError}
     */
    selectVariation(visitorId, experienceKey, attributes) {
        return this._dataManager.getBucketing(visitorId, experienceKey, attributes);
    }
    /**
     * Select variation for specific visitor
     * @param {string} visitorId
     * @param {string} experienceId
     * @param {BucketingAttributes} attributes
     * @param {Record<any, any>} attributes.locationProperties
     * @param {Record<any, any>} attributes.visitorProperties
     * @param {boolean=} attributes.updateVisitorProperties
     * @param {string=} attributes.forceVariationId
     * @param {boolean=} attributes.enableTracking
     * @param {string=} attributes.environment
     * @return {BucketedVariation | RuleError | BucketingError}
     */
    selectVariationById(visitorId, experienceId, attributes) {
        return this._dataManager.getBucketingById(visitorId, experienceId, attributes);
    }
    /**
     * Select all variations across all experiences for specific visitor
     * @param {string} visitorId
     * @param {BucketingAttributes} attributes
     * @param {Record<any, any>} attributes.locationProperties
     * @param {Record<any, any>} attributes.visitorProperties
     * @param {boolean=} attributes.updateVisitorProperties
     * @param {string=} attributes.forceVariationId
     * @param {boolean=} attributes.enableTracking
     * @param {string=} attributes.environment
     * @return {Array<BucketedVariation | RuleError | BucketingError>}
     */
    selectVariations(visitorId, attributes) {
        return this.getList()
            .map((experience) => {
            return this.selectVariation(visitorId, experience === null || experience === void 0 ? void 0 : experience.key, attributes);
        })
            .filter((variation) => variation &&
            !Object.values(RuleError).includes(variation) &&
            !Object.values(BucketingError).includes(variation));
    }
    /**
     * Get experience's variation by key
     * @param {string} experienceKey
     * @param {string}variationKey
     */
    getVariation(experienceKey, variationKey) {
        return this._dataManager.getSubItem('experiences', experienceKey, 'variations', variationKey, 'key', 'key');
    }
    /**
     * Get experience's variation by id
     * @param experienceId
     * @param variationId
     */
    getVariationById(experienceId, variationId) {
        return this._dataManager.getSubItem('experiences', experienceId, 'variations', variationId, 'id', 'id');
    }
}

/**
 * Provides features specific logic
 * @category Modules
 * @constructor
 * @implements {FeatureManagerInterface}
 */
class FeatureManager {
    /**
     * @param config
     * @param {Object} dependencies
     * @param {DataManagerInterface} dependencies.dataManager
     * @param {LogManagerInterface=} dependencies.loggerManager
     */
    constructor(config, { dataManager, loggerManager }) {
        var _a, _b;
        this._dataManager = dataManager;
        this._loggerManager = loggerManager;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'FeatureManager()', MESSAGES.FEATURE_CONSTRUCTOR);
    }
    /**
     * Get a list of all entities
     * @return {Array<ConfigFeature>} Features list
     */
    getList() {
        return this._dataManager.getEntitiesList('features');
    }
    /**
     * Get a list of all entities as object of entities grouped by identity field
     * @param {IdentityField=} field A field to group entities defaults to `id`
     * @return {Record<string, ConfigFeature>} Features list
     */
    getListAsObject(field = 'id') {
        return this._dataManager.getEntitiesListObject('features', field);
    }
    /**
     * Get the entity by key
     * @param {string} key
     * @return {ConfigFeature}
     */
    getFeature(key) {
        return this._dataManager.getEntity(key, 'features');
    }
    /**
     * Get the entity by id
     * @param {string} id
     * @return {ConfigFeature}
     */
    getFeatureById(id) {
        return this._dataManager.getEntityById(id, 'features');
    }
    /**
     * Get specific entities by array of keys
     * @param {Array<string>} keys
     * @return {Array<ConfigFeature>}
     */
    getFeatures(keys) {
        return this._dataManager.getItemsByKeys(keys, 'features');
    }
    /**
     * Get a specific variable type defined in a specific feature
     * @param {string} key A feature's key
     * @param {string} variableName
     * @return {string|null}
     */
    getFeatureVariableType(key, variableName) {
        const feature = this.getFeature(key);
        if (Object.prototype.hasOwnProperty.call(feature, 'variables')) {
            const variable = feature.variables.find((variable) => {
                return variable.key === variableName;
            });
            return (variable === null || variable === void 0 ? void 0 : variable.type) || null;
        }
        return null;
    }
    /**
     * Get a specific variable type defined in a specific feature by id
     * @param {string} id A feature's id
     * @param {string} variableName
     * @return {string|null}
     */
    getFeatureVariableTypeById(id, variableName) {
        const feature = this.getFeatureById(id);
        if (Object.prototype.hasOwnProperty.call(feature, 'variables')) {
            const variable = feature.variables.find((variable) => {
                return variable.key === variableName;
            });
            return (variable === null || variable === void 0 ? void 0 : variable.type) || null;
        }
        return null;
    }
    /**
     * Check that feature is declared
     * @param {string} key ConfigFeature key
     * @return {boolean}
     */
    isFeatureDeclared(key) {
        const declaredFeature = this._dataManager.getEntity(key, 'features');
        return !!declaredFeature;
    }
    /**
     * Get feature and its status
     * @param {string} visitorId
     * @param {string} featureKey
     * @param {BucketingAttributes} attributes
     * @param {Record<any, any>} attributes.locationProperties
     * @param {Record<any, any>} attributes.visitorProperties
     * @param {boolean=} attributes.updateVisitorProperties
     * @param {boolean=} attributes.typeCasting Defaults to `true`
     * @param {string=} attributes.environment
     * @param {Array<string>=} experienceKeys
     * @return {BucketedFeature | RuleError | Array<BucketedFeature | RuleError>}
     */
    runFeature(visitorId, featureKey, attributes, experienceKeys) {
        const declaredFeature = this._dataManager.getEntity(featureKey, 'features');
        if (declaredFeature) {
            const features = this.runFeatures(visitorId, attributes, {
                features: [featureKey],
                experiences: experienceKeys
            });
            if (arrayNotEmpty(features)) {
                if (features.length === 1) {
                    // Return the bucketed feature
                    return features[0];
                }
                else {
                    // Return an array of bucketed features. It means the feature is used in different experiences and visitor has been bucketed to those variations
                    return features;
                }
            }
            // Return disabled feature. Visitor was not bucketed
            return {
                id: declaredFeature.id,
                name: declaredFeature.name,
                key: featureKey,
                status: FeatureStatus.DISABLED
            };
        }
        else {
            // The feature is not declared at all
            return {
                key: featureKey,
                status: FeatureStatus.DISABLED
            };
        }
    }
    /**
     * Check is feature enabled.
     * @param {string} visitorId
     * @param {string} featureKey
     * @param {BucketingAttributes} attributes
     * @param {Record<any, any>} attributes.locationProperties
     * @param {Record<any, any>} attributes.visitorProperties
     * @param {string=} attributes.environment
     * @param {Array<string>=} experienceKeys
     * @return {boolean}
     */
    isFeatureEnabled(visitorId, featureKey, attributes, experienceKeys) {
        const declaredFeature = this._dataManager.getEntity(featureKey, 'features');
        if (declaredFeature) {
            const features = this.runFeatures(visitorId, attributes, {
                features: [featureKey],
                experiences: experienceKeys
            });
            return arrayNotEmpty(features);
        }
        return false;
    }
    /**
     * Get feature and its status
     * @param {string} visitorId
     * @param {string} featureId
     * @param {BucketingAttributes} attributes
     * @param {Record<any, any>} attributes.locationProperties
     * @param {Record<any, any>} attributes.visitorProperties
     * @param {boolean=} attributes.updateVisitorProperties
     * @param {boolean=} attributes.typeCasting Defaults to `true`
     * @param {string=} attributes.environment
     * @param {Array<string>=} experienceIds
     * @return {BucketedFeature | Array<BucketedFeature> }
     */
    runFeatureById(visitorId, featureId, attributes, experienceIds) {
        const declaredFeature = this._dataManager.getEntityById(featureId, 'features');
        if (declaredFeature) {
            const features = this.runFeatures(visitorId, attributes, {
                features: [declaredFeature.key],
                experiences: this._dataManager
                    .getEntitiesByIds(experienceIds, 'experiences')
                    .map((e) => e.key)
            });
            if (arrayNotEmpty(features)) {
                if (features.length === 1) {
                    // Return the bucketed feature
                    return features[0];
                }
                else {
                    // Return rule errors if present
                    const matchedErrors = features.filter((match) => Object.values(RuleError).includes(match));
                    if (matchedErrors.length)
                        return matchedErrors;
                    // Return an array of bucketed features. It means the feature is used in different experiences and visitor has been bucketed to those variations
                    return features;
                }
            }
            // Return disabled feature. Visitor was not bucketed
            return {
                id: featureId,
                name: declaredFeature.name,
                key: declaredFeature.key,
                status: FeatureStatus.DISABLED
            };
        }
        else {
            // The feature is not declared at all
            return {
                id: featureId,
                status: FeatureStatus.DISABLED
            };
        }
    }
    /**
     * Get features and their statuses
     * @param {string} visitorId
     * @param {BucketingAttributes} attributes
     * @param {Record<any, any>} attributes.locationProperties
     * @param {Record<any, any>} attributes.visitorProperties
     * @param {boolean=} attributes.updateVisitorProperties
     * @param {boolean=} attributes.typeCasting Defaults to `true`
     * @param {string=} attributes.environment
     * @param {Record<string, Array<string>>=} filter Filter records by experiences and/or features keys
     * @param {Array<string>} filter.experiences Array of experiences keys
     * @param {Array<string>} filter.features Array of features keys
     * @return {Array<BucketedFeature | RuleError>}
     */
    runFeatures(visitorId, attributes, filter) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        const { typeCasting = true } = attributes;
        // Get list of declared features grouped by id
        const declaredFeatures = this.getListAsObject('id');
        const bucketedFeatures = [];
        // Retrieve all or filtered experiences
        const experiences = (filter && arrayNotEmpty(filter === null || filter === void 0 ? void 0 : filter.experiences)
            ? this._dataManager.getEntities(filter.experiences, 'experiences')
            : this._dataManager.getEntitiesList('experiences'));
        // Retrieve bucketed variations across the experiences
        const bucketedVariations = experiences
            .map((experience) => {
            const variation = this._dataManager.getBucketing(visitorId, experience === null || experience === void 0 ? void 0 : experience.key, attributes);
            if (Object.values(RuleError).includes(variation))
                return variation;
            return variation;
        })
            .filter(Boolean);
        // Return rule errors if present
        const matchedErrors = bucketedVariations.filter((match) => Object.values(RuleError).includes(match));
        if (matchedErrors.length)
            return matchedErrors;
        // Collect features from bucketed variations
        for (const k in bucketedVariations) {
            const bucketedVariation = bucketedVariations[k];
            for (const v in (bucketedVariation === null || bucketedVariation === void 0 ? void 0 : bucketedVariation.changes) || []) {
                const changes = (_b = (_a = bucketedVariation === null || bucketedVariation === void 0 ? void 0 : bucketedVariation.changes) === null || _a === void 0 ? void 0 : _a[v]) === null || _b === void 0 ? void 0 : _b.data;
                if (((_d = (_c = bucketedVariation === null || bucketedVariation === void 0 ? void 0 : bucketedVariation.changes) === null || _c === void 0 ? void 0 : _c[v]) === null || _d === void 0 ? void 0 : _d.type) !==
                    VariationChangeType.FULLSTACK_FEATURE) {
                    (_f = (_e = this._loggerManager) === null || _e === void 0 ? void 0 : _e.warn) === null || _f === void 0 ? void 0 : _f.call(_e, 'FeatureManager.runFeatures()', MESSAGES.VARIATION_CHANGE_NOT_SUPPORTED);
                    continue;
                }
                const featureId = changes === null || changes === void 0 ? void 0 : changes.feature_id;
                // Take the features filter into account
                if (!featureId) {
                    (_h = (_g = this._loggerManager) === null || _g === void 0 ? void 0 : _g.warn) === null || _h === void 0 ? void 0 : _h.call(_g, 'FeatureManager.runFeatures()', MESSAGES.FEATURE_NOT_FOUND);
                    continue;
                }
                if ((filter &&
                    arrayNotEmpty(filter === null || filter === void 0 ? void 0 : filter.features) &&
                    ((_j = filter === null || filter === void 0 ? void 0 : filter.features) === null || _j === void 0 ? void 0 : _j.indexOf((_k = declaredFeatures[String(featureId)]) === null || _k === void 0 ? void 0 : _k.key)) !== -1) ||
                    !(filter === null || filter === void 0 ? void 0 : filter.features)) {
                    const variables = changes === null || changes === void 0 ? void 0 : changes.variables_data;
                    if (!variables) {
                        (_m = (_l = this._loggerManager) === null || _l === void 0 ? void 0 : _l.warn) === null || _m === void 0 ? void 0 : _m.call(_l, 'FeatureManager.runFeatures()', MESSAGES.FEATURE_VARIABLES_NOT_FOUND);
                    }
                    if (typeCasting && objectNotEmpty(variables)) {
                        // Convert variables values types
                        for (const variableName in variables) {
                            const variableDefinition = (_p = (_o = declaredFeatures[String(featureId)]) === null || _o === void 0 ? void 0 : _o.variables) === null || _p === void 0 ? void 0 : _p.find((obj) => {
                                return obj.key === variableName;
                            });
                            if (variableDefinition === null || variableDefinition === void 0 ? void 0 : variableDefinition.type) {
                                variables[variableName] = this.castType(variables[variableName], variableDefinition.type);
                            }
                            else {
                                (_r = (_q = this._loggerManager) === null || _q === void 0 ? void 0 : _q.warn) === null || _r === void 0 ? void 0 : _r.call(_q, 'FeatureManager.runFeatures()', MESSAGES.FEATURE_VARIABLES_TYPE_NOT_FOUND);
                            }
                        }
                    }
                    // Build the bucketed feature object
                    const bucketedFeature = Object.assign({
                        experienceId: bucketedVariation.experienceId,
                        experienceName: bucketedVariation.experienceName,
                        experienceKey: bucketedVariation.experienceKey
                    }, {
                        key: (_s = declaredFeatures[String(featureId)]) === null || _s === void 0 ? void 0 : _s.key,
                        name: (_t = declaredFeatures[String(featureId)]) === null || _t === void 0 ? void 0 : _t.name,
                        id: String(featureId),
                        status: FeatureStatus.ENABLED,
                        variables: variables
                    });
                    bucketedFeatures.push(bucketedFeature);
                }
            }
        }
        // Extend the list with not enabled features only if there is no features filter provided
        if (!(filter === null || filter === void 0 ? void 0 : filter.features)) {
            const bucketedFeaturesIds = bucketedFeatures.map((f) => f.id);
            // console.log(bucketedFeaturesIds)
            for (const k in declaredFeatures) {
                if (bucketedFeaturesIds.indexOf(declaredFeatures[k].id) === -1) {
                    bucketedFeatures.push({
                        id: declaredFeatures[k].id,
                        name: declaredFeatures[k].name,
                        key: declaredFeatures[k].key,
                        status: FeatureStatus.DISABLED
                    });
                }
            }
        }
        return bucketedFeatures;
    }
    /**
     * Convert value's type
     * @param value
     * @param type
     */
    castType(value, type) {
        return castType(value, type);
    }
}

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
const DEFAULT_KEYS_CASE_SENSITIVE = true;
const DEFAULT_NEGATION = '!';
/**
 * Provides rule processing calculations with corresponding comparisons methods
 * @category Modules
 * @constructor
 * @implements {RuleManagerInterface}
 */
class RuleManager {
    /**
     * @param {Config=} config
     * @param {Object=} dependencies
     * @param {LogManagerInterface=} dependencies.loggerManager
     */
    constructor(config, { loggerManager } = {}) {
        var _a, _b, _c, _d, _e;
        this._comparisonProcessor = Comparisons;
        this._negation = DEFAULT_NEGATION;
        this._keys_case_sensitive = DEFAULT_KEYS_CASE_SENSITIVE;
        this._loggerManager = loggerManager;
        this._comparisonProcessor =
            ((_a = config === null || config === void 0 ? void 0 : config.rules) === null || _a === void 0 ? void 0 : _a.comparisonProcessor) || Comparisons;
        this._negation = String(((_b = config === null || config === void 0 ? void 0 : config.rules) === null || _b === void 0 ? void 0 : _b.negation) || DEFAULT_NEGATION);
        this._keys_case_sensitive =
            ((_c = config === null || config === void 0 ? void 0 : config.rules) === null || _c === void 0 ? void 0 : _c.keys_case_sensitive) || DEFAULT_KEYS_CASE_SENSITIVE;
        this._mapper = (config === null || config === void 0 ? void 0 : config.mapper) || ((value) => value);
        (_e = (_d = this._loggerManager) === null || _d === void 0 ? void 0 : _d.trace) === null || _e === void 0 ? void 0 : _e.call(_d, 'RuleManager()', MESSAGES.RULE_CONSTRUCTOR, this);
    }
    /**
     * Setter for comparison processor
     * @param {Record<string, any>} comparisonProcessor
     */
    set comparisonProcessor(comparisonProcessor) {
        this._comparisonProcessor = comparisonProcessor;
    }
    /**
     * Getter for comparison processor
     */
    get comparisonProcessor() {
        return this._comparisonProcessor;
    }
    /**
     * Retrieve comparison methods from comparison processor
     * @return {Array<string>} List of methods of comparison processor
     */
    getComparisonProcessorMethods() {
        return Object.getOwnPropertyNames(this._comparisonProcessor).filter((name) => typeof this._comparisonProcessor[name] === 'function');
    }
    /**
     * Check input data matching to rule set
     * @param {Record<string, any>} data Single value or key-value data set to compare
     * @param {RuleObject} ruleSet
     * @return {boolean | RuleError}
     */
    isRuleMatched(data, ruleSet, logEntry) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'RuleManager.isRuleMatched()', this._mapper({
            data: data,
            ruleSet: ruleSet
        }));
        if (logEntry) {
            (_d = (_c = this._loggerManager) === null || _c === void 0 ? void 0 : _c.info) === null || _d === void 0 ? void 0 : _d.call(_c, 'RuleManager.isRuleMatched()', MESSAGES.PROCESSING_ENTITY.replace('#', logEntry));
        }
        // Top OR level
        let match;
        if (Object.prototype.hasOwnProperty.call(ruleSet, 'OR') &&
            arrayNotEmpty(ruleSet === null || ruleSet === void 0 ? void 0 : ruleSet.OR)) {
            for (let i = 0, l = ruleSet.OR.length; i < l; i++) {
                match = this._processAND(data, ruleSet.OR[i]);
                if (match === true) {
                    return match;
                }
                if (Object.values(RuleError).includes(match)) {
                    (_f = (_e = this._loggerManager) === null || _e === void 0 ? void 0 : _e.info) === null || _f === void 0 ? void 0 : _f.call(_e, 'RuleManager.isRuleMatched()', logEntry || '', ERROR_MESSAGES.RULE_ERROR);
                }
                else {
                    (_h = (_g = this._loggerManager) === null || _g === void 0 ? void 0 : _g.info) === null || _h === void 0 ? void 0 : _h.call(_g, 'RuleManager.isRuleMatched()', logEntry || '', match === false
                        ? MESSAGES.RULE_NOT_MATCH
                        : MESSAGES.RULE_MATCH.replace('#', String(i)));
                }
            }
            if (match !== false) {
                return match;
            }
        }
        else {
            (_k = (_j = this._loggerManager) === null || _j === void 0 ? void 0 : _j.warn) === null || _k === void 0 ? void 0 : _k.call(_j, 'RuleManager.isRuleMatched()', logEntry || '', ERROR_MESSAGES.RULE_NOT_VALID);
        }
        return false;
    }
    /**
     * Check is rule object valid
     * @param {RuleElement} rule
     * @return {boolean}
     */
    isValidRule(rule) {
        var _a, _b;
        (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.call(_a, 'RuleManager.isValidRule()', this._mapper({
            rule: rule
        }));
        return (Object.prototype.hasOwnProperty.call(rule, 'matching') &&
            typeof rule.matching === 'object' &&
            Object.prototype.hasOwnProperty.call(rule.matching, 'match_type') &&
            typeof rule.matching.match_type === 'string' &&
            Object.prototype.hasOwnProperty.call(rule.matching, 'negated') &&
            typeof rule.matching.negated === 'boolean' &&
            Object.prototype.hasOwnProperty.call(rule, 'value'));
    }
    /**
     * Process AND block of rule set. Return first false if found
     * @param {Record<string, any>} data Single value or key-value data set to compare
     * @param {RuleAnd} rulesSubset
     * @return {boolean | RuleError}
     * @private
     */
    _processAND(data, rulesSubset) {
        var _a, _b, _c, _d;
        // Second AND level
        let match;
        if (Object.prototype.hasOwnProperty.call(rulesSubset, 'AND') &&
            arrayNotEmpty(rulesSubset === null || rulesSubset === void 0 ? void 0 : rulesSubset.AND)) {
            for (let i = 0, l = rulesSubset.AND.length; i < l; i++) {
                match = this._processORWHEN(data, rulesSubset.AND[i]);
                if (match === false) {
                    return false;
                }
            }
            if (match !== false) {
                (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.info) === null || _b === void 0 ? void 0 : _b.call(_a, 'RuleManager._processAND()', MESSAGES.RULE_MATCH_AND);
            }
            return match;
        }
        else {
            (_d = (_c = this._loggerManager) === null || _c === void 0 ? void 0 : _c.warn) === null || _d === void 0 ? void 0 : _d.call(_c, 'RuleManager._processAND()', ERROR_MESSAGES.RULE_NOT_VALID);
        }
        return false;
    }
    /**
     * Process OR block of rule set. Return first true if found
     * @param {Record<string, any>} data Single value or key-value data set to compare
     * @param {RuleOrWhen} rulesSubset
     * @return {boolean | RuleError}
     * @private
     */
    _processORWHEN(data, rulesSubset) {
        var _a, _b;
        // Third OR level. Called OR_WHEN.
        let match;
        if (Object.prototype.hasOwnProperty.call(rulesSubset, 'OR_WHEN') &&
            arrayNotEmpty(rulesSubset === null || rulesSubset === void 0 ? void 0 : rulesSubset.OR_WHEN)) {
            for (let i = 0, l = rulesSubset.OR_WHEN.length; i < l; i++) {
                match = this._processRuleItem(data, rulesSubset.OR_WHEN[i]);
                if (match === true) {
                    return match;
                }
            }
            if (match !== false) {
                return match;
            }
        }
        else {
            (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.warn) === null || _b === void 0 ? void 0 : _b.call(_a, 'RuleManager._processORWHEN()', ERROR_MESSAGES.RULE_NOT_VALID);
        }
        return false;
    }
    /**
     * Process single rule item
     * @param {Record<string, any>} data Single value or key-value data set to compare
     * @param {RuleElement} rule A single rule to compare
     * @return {boolean | RuleError} Comparison result
     * @private
     */
    _processRuleItem(data, rule) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        if (this.isValidRule(rule)) {
            try {
                const negation = rule.matching.negated || false;
                const matching = rule.matching.match_type;
                if (this.getComparisonProcessorMethods().indexOf(matching) !== -1) {
                    if (data && typeof data === 'object') {
                        // Validate data key-value set.
                        if (this.isUsingCustomInterface(data)) {
                            // RuleElement object has to have `rule_type` field
                            if (rule === null || rule === void 0 ? void 0 : rule.rule_type) {
                                (_b = (_a = this._loggerManager) === null || _a === void 0 ? void 0 : _a.info) === null || _b === void 0 ? void 0 : _b.call(_a, 'RuleManager._processRuleItem()', MESSAGES.RULE_MATCH_START.replace('#', rule.rule_type));
                                for (const method of Object.getOwnPropertyNames(data.constructor.prototype)) {
                                    if (method === 'constructor')
                                        continue;
                                    const rule_method = camelCase(`get ${rule.rule_type.replace(/_/g, ' ')}`);
                                    if (method === rule_method ||
                                        ((_c = data === null || data === void 0 ? void 0 : data.mapper) === null || _c === void 0 ? void 0 : _c.call(data, method)) === rule_method) {
                                        const dataValue = data[method](rule);
                                        if (Object.values(RuleError).includes(dataValue))
                                            return dataValue;
                                        if (rule.rule_type === 'js_condition')
                                            return dataValue;
                                        return this._comparisonProcessor[matching](dataValue, rule.value, negation);
                                    }
                                }
                            }
                        }
                        else if (objectNotEmpty(data)) {
                            // only handle RuleElement with a `key` field
                            for (const key of Object.keys(data)) {
                                const k = this._keys_case_sensitive ? key : key.toLowerCase();
                                const rule_k = this._keys_case_sensitive
                                    ? rule['key']
                                    : String(rule['key']).toLowerCase();
                                if (k === rule_k) {
                                    return this._comparisonProcessor[matching](data[key], rule.value, negation);
                                }
                            }
                        }
                        else {
                            (_e = (_d = this._loggerManager) === null || _d === void 0 ? void 0 : _d.trace) === null || _e === void 0 ? void 0 : _e.call(_d, 'RuleManager._processRuleItem()', {
                                warn: ERROR_MESSAGES.RULE_DATA_NOT_VALID,
                                data
                            });
                        }
                    }
                    else {
                        (_g = (_f = this._loggerManager) === null || _f === void 0 ? void 0 : _f.trace) === null || _g === void 0 ? void 0 : _g.call(_f, 'RuleManager._processRuleItem()', {
                            warn: ERROR_MESSAGES.RULE_NOT_VALID,
                            data,
                            rule
                        });
                    }
                }
                else {
                    (_j = (_h = this._loggerManager) === null || _h === void 0 ? void 0 : _h.warn) === null || _j === void 0 ? void 0 : _j.call(_h, 'RuleManager._processRuleItem()', ERROR_MESSAGES.RULE_MATCH_TYPE_NOT_SUPPORTED.replace('#', matching));
                }
            }
            catch (error) {
                (_l = (_k = this._loggerManager) === null || _k === void 0 ? void 0 : _k.error) === null || _l === void 0 ? void 0 : _l.call(_k, 'RuleManager._processRuleItem()', {
                    error: error.message
                });
            }
        }
        else {
            (_o = (_m = this._loggerManager) === null || _m === void 0 ? void 0 : _m.warn) === null || _o === void 0 ? void 0 : _o.call(_m, 'RuleManager._processRuleItem()', ERROR_MESSAGES.RULE_NOT_VALID);
        }
        return false;
    }
    /**
     * Check is rule data object is a custom interface instead of a literal object
     * @param {Record<string, any>} data Single value or key-value data set to compare
     * @return {boolean}
     */
    isUsingCustomInterface(data) {
        return (objectNotEmpty(data) &&
            Object.prototype.hasOwnProperty.call(data, 'name') &&
            data.name === 'RuleData');
    }
}

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * Provides segments specific logic
 * @category Modules
 * @constructor
 * @implements {SegmentsManagerInterface}
 */
class SegmentsManager {
    /**
     * @param {Config} config
     * @param {Object} dependencies
     * @param {DataManagerInterface=} dependencies.dataManager
     * @param {RuleManagerInterface=} dependencies.ruleManager
     * @param {LogManagerInterface=} dependencies.loggerManager
     */
    constructor(config, { dataManager, ruleManager, loggerManager }) {
        this._dataManager = dataManager;
        this._ruleManager = ruleManager;
        this._loggerManager = loggerManager;
        this._data = objectDeepValue(config, 'data');
    }
    /**
     * Get segments in DataStore
     * @param {string} visitorId
     * @returns {VisitorSegments}
     */
    getSegments(visitorId) {
        const storeData = this._dataManager.getData(visitorId) || {};
        const { segments } = this._dataManager.filterReportSegments(storeData === null || storeData === void 0 ? void 0 : storeData.segments);
        return segments;
    }
    /**
     * Update segments in DataStore
     * @param {string} visitorId
     * @param {VisitorSegments} segments
     */
    putSegments(visitorId, segments) {
        const { segments: reportSegments } = this._dataManager.filterReportSegments(segments);
        if (reportSegments) {
            // Store the data
            this._dataManager.putData(visitorId, { segments: reportSegments });
        }
    }
    setCustomSegments(visitorId, segments, segmentRule) {
        var _a, _b, _c, _d, _e;
        const storeData = this._dataManager.getData(visitorId) || {};
        // Get custom segments ID from DataStore
        const { segments: { [SegmentsKeys.CUSTOM_SEGMENTS]: customSegments = [] } = {} } = storeData;
        const segmentIds = [];
        let segmentsMatched = false;
        for (const segment of segments) {
            if (segmentRule && !segmentsMatched) {
                segmentsMatched = this._ruleManager.isRuleMatched(segmentRule, segment === null || segment === void 0 ? void 0 : segment.rules, `ConfigSegment #${segment === null || segment === void 0 ? void 0 : segment.id}`);
                // Return rule errors if present
                if (Object.values(RuleError).includes(segmentsMatched))
                    return segmentsMatched;
            }
            if (!segmentRule || segmentsMatched) {
                const segmentId = (_a = segment === null || segment === void 0 ? void 0 : segment.id) === null || _a === void 0 ? void 0 : _a.toString();
                if (customSegments.includes(segmentId)) {
                    (_c = (_b = this._loggerManager) === null || _b === void 0 ? void 0 : _b.warn) === null || _c === void 0 ? void 0 : _c.call(_b, 'SegmentsManager.setCustomSegments()', MESSAGES.CUSTOM_SEGMENTS_KEY_FOUND);
                }
                else {
                    segmentIds.push(segmentId);
                }
            }
        }
        let segmentsData;
        if (segmentIds.length) {
            segmentsData = Object.assign(Object.assign({}, (storeData.segments || {})), { [SegmentsKeys.CUSTOM_SEGMENTS]: [...customSegments, ...segmentIds] });
            // Merge custom segments ID into DataStore
            this.putSegments(visitorId, segmentsData);
        }
        else {
            (_e = (_d = this._loggerManager) === null || _d === void 0 ? void 0 : _d.warn) === null || _e === void 0 ? void 0 : _e.call(_d, 'SegmentsManager.setCustomSegments()', MESSAGES.SEGMENTS_NOT_FOUND);
        }
        return segmentsData;
    }
    /**
     * Update custom segments for specific visitor
     * @param {string} visitorId
     * @param {Array<string>} segmentKeys A list of segment keys
     * @param {Record<string, any>=} segmentRule An object of key-value pairs that are used for segments matching
     * @param {string=} environment
     * @return {VisitorSegments | RuleError}
     */
    selectCustomSegments(visitorId, segmentKeys, segmentRule) {
        const segments = this._dataManager.getEntities(segmentKeys, 'segments');
        return this.setCustomSegments(visitorId, segments, segmentRule);
    }
    /**
     * Update custom segments for specific visitor
     * @param {string} visitorId
     * @param {Array<string>} segmentIds A list of segment ids
     * @param {Record<string, any>=} segmentRule An object of key-value pairs that are used for segments matching
     * @param {string=} environment
     * @return {VisitorSegments | RuleError}
     */
    selectCustomSegmentsByIds(visitorId, segmentIds, segmentRule) {
        const segments = this._dataManager.getEntitiesByIds(segmentIds, 'segments');
        return this.setCustomSegments(visitorId, segments, segmentRule);
    }
}

/*!
 * Convert JS SDK
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
const DEFAULT_LOG_LEVEL = LogLevel.TRACE;
/**
 * Provides logging logic
 * @category Modules
 * @constructor
 * @implements {LogManagerInterface}
 */
class LogManager {
    /**
     * @param {any} client
     * @param {LogLevel=} level
     * @param {LogMethodMapInterface=} mapper
     */
    constructor(client = console, level = DEFAULT_LOG_LEVEL, mapper) {
        this._defaultMapper = {
            [LogMethod.LOG]: LogMethod.LOG,
            [LogMethod.DEBUG]: LogMethod.DEBUG,
            [LogMethod.INFO]: LogMethod.INFO,
            [LogMethod.WARN]: LogMethod.WARN,
            [LogMethod.ERROR]: LogMethod.ERROR,
            [LogMethod.TRACE]: LogMethod.TRACE
        };
        this._clients = [];
        this.addClient(client, level, mapper);
    }
    _isValidLevel(level) {
        return Object.values(LogLevel).includes(level);
    }
    _isValidMethod(method) {
        return Object.values(LogMethod).includes(method);
    }
    _log(method, level, ...args) {
        this._clients.forEach((client) => {
            var _a, _b;
            if (level >= client.level && LogLevel.SILENT !== level) {
                const fn = client.sdk[client.mapper[method]];
                if (fn) {
                    fn.call(client.sdk, ...args);
                }
                else {
                    console.log(`Info: Unable to find method "${method}()" in client sdk:`, (_b = (_a = client.sdk) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name);
                    console[method](...args);
                }
            }
        });
    }
    /**
     * @param {LogLevel} level
     * @param {Array<any>} args
     */
    log(level, ...args) {
        if (!this._isValidLevel(level)) {
            // throw new Error('Invalid Log Level');
            console.error('Invalid Log Level');
            return;
        }
        this._log(LogMethod.LOG, level, ...args);
    }
    /**
     * @param {Array<any>} args
     */
    trace(...args) {
        this._log(LogMethod.TRACE, LogLevel.TRACE, ...args);
    }
    /**
     * @param {Array<any>} args
     */
    debug(...args) {
        this._log(LogMethod.DEBUG, LogLevel.DEBUG, ...args);
    }
    /**
     * @param {Array<any>} args
     */
    info(...args) {
        this._log(LogMethod.INFO, LogLevel.INFO, ...args);
    }
    /**
     * @param {Array<any>} args
     */
    warn(...args) {
        this._log(LogMethod.WARN, LogLevel.WARN, ...args);
    }
    /**
     * @param {Array<any>} args
     */
    error(...args) {
        this._log(LogMethod.ERROR, LogLevel.ERROR, ...args);
    }
    /**
     * @param {any=} client
     * @param {LogLevel=} level
     * @param {LogMethodMapInterface=} methodMap
     */
    addClient(client = console, level = DEFAULT_LOG_LEVEL, methodMap) {
        if (!client) {
            // throw new Error('Invalid Client SDK');
            console.error('Invalid Client SDK');
            return;
        }
        if (!this._isValidLevel(level)) {
            // throw new Error('Invalid Log Level');
            console.error('Invalid Log Level');
            return;
        }
        const mapper = Object.assign({}, this._defaultMapper);
        if (methodMap) {
            Object.keys(methodMap)
                .filter(this._isValidMethod)
                .forEach((method) => {
                mapper[method] = methodMap[method];
            });
        }
        this._clients.push({ sdk: client, level, mapper });
    }
    /**
     * @param {LogLevel=} level
     * @param {any=} client
     */
    setClientLevel(level, client) {
        if (!this._isValidLevel(level)) {
            console.error('Invalid Log Level');
            return;
        }
        if (client) {
            const clientIndex = this._clients.findIndex(({ sdk }) => sdk === client);
            if (clientIndex === -1) {
                console.error('Client SDK not found');
                return;
            }
            this._clients[clientIndex].level = level;
        }
        else {
            for (let i = 0, max = this._clients.length; i < max; i++)
                this._clients[i].level = level;
        }
    }
}

/*!
 * Convert JS SDK config
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
const defaultConfig = {
    api: {
        endpoint: {
            config: 'https://cdn-4.convertexperiments.com/api/v1/',
            track: 'https://[project_id].metrics.convertexperiments.com/v1/'
        }
    },
    environment: 'staging',
    bucketing: {
        max_traffic: 10000,
        hash_seed: 9999
    },
    data: {},
    dataStore: null, // Allows 3rd party data store to be passed
    dataRefreshInterval: 300000, // in milliseconds (5 minutes)
    events: {
        batch_size: 10,
        release_interval: 1000
    },
    logger: {
        logLevel: LogLevel.DEBUG,
        customLoggers: [] // Allows 3rd party loggers to be passed
    },
    rules: {
        keys_case_sensitive: true,
        comparisonProcessor: null // Allows 3rd party comparison processor to be passed
    },
    network: {
        tracking: true,
        cacheLevel: 'default' // can be set to 'low' for short-lived cache (for development purposes only)
    },
    sdkKey: '',
    sdkKeySecret: ''
};

const DEFAULT_LOGGER_SETTINGS = {
    logger: {
        logLevel: LogLevel.WARN,
        customLoggers: []
    }
};
const DEFAULT_ENVIRONMENT_SETTINGS = {
    environment: 'staging'
};
/**
 * @param {Record<any, any>=} config
 * @return {ConfigType}
 */
const Config = (config = {}) => {
    const configuration = objectDeepMerge(DEFAULT_LOGGER_SETTINGS, DEFAULT_ENVIRONMENT_SETTINGS, defaultConfig, config);
    return configuration;
};

/*!
 * Convert JS SDK test
 * Version 1.0.0
 * Copyright(c) 2020 Convert Insights, Inc
 * License Apache-2.0
 */
/**
 * Module dependencies
 */
//todo: add config attributes definition
/**
 * Create new Convert SDK instance
 * @category Main
 * @constructor
 */
class ConvertSDK extends Core {
    /**
     * @param {ConfigType} config
     */
    constructor(config = {}) {
        var _a, _b, _c;
        // Validate config before assigning defaults
        const isValidSDKKey = Boolean(Object.prototype.hasOwnProperty.call(config, 'sdkKey') &&
            ((_a = config.sdkKey) === null || _a === void 0 ? void 0 : _a.length));
        const isValidData = Boolean(Object.prototype.hasOwnProperty.call(config, 'data'));
        if (!isValidSDKKey && !isValidData) {
            console.error(ERROR_MESSAGES.SDK_OR_DATA_OBJECT_REQUIRED);
        }
        const configuration = Config(config);
        if (!(configuration === null || configuration === void 0 ? void 0 : configuration.network))
            configuration.network = {};
        if (!((_b = configuration.network) === null || _b === void 0 ? void 0 : _b.source))
            configuration.network.source =
                'js4.3.2'
                    ;
        const loggerManager = new LogManager(console, configuration.logger.logLevel);
        for (const k in configuration.logger.customLoggers) {
            if (Object.prototype.hasOwnProperty.call(configuration.logger.customLoggers[k], 'logger') &&
                Object.prototype.hasOwnProperty.call(configuration.logger.customLoggers[k], 'logLevel')) {
                loggerManager.addClient(configuration.logger.customLoggers[k].logger, configuration.logger.customLoggers[k].logLevel, (_c = configuration.logger.customLoggers[k]) === null || _c === void 0 ? void 0 : _c.methodsMap);
            }
            else {
                loggerManager.addClient(configuration.logger.customLoggers[k], configuration.logger.logLevel);
            }
        }
        const eventManager = new EventManager(configuration, {
            loggerManager
        });
        const apiManager = new ApiManager(configuration, {
            eventManager,
            loggerManager
        });
        const bucketingManager = new BucketingManager(configuration, {
            loggerManager
        });
        const ruleManager = new RuleManager(configuration, { loggerManager });
        const dataManager = new DataManager(configuration, {
            bucketingManager,
            ruleManager,
            eventManager,
            apiManager,
            loggerManager
        });
        const experienceManager = new ExperienceManager(configuration, {
            dataManager
        });
        const featureManager = new FeatureManager(configuration, {
            dataManager,
            loggerManager
        });
        const segmentsManager = new SegmentsManager(configuration, {
            dataManager,
            ruleManager,
            loggerManager
        });
        super(configuration, {
            dataManager,
            eventManager,
            experienceManager,
            featureManager,
            segmentsManager,
            apiManager,
            loggerManager
        });
    }
    /**
     * Promisified ready event
     * @return {Promise<void>}
     */
    onReady() {
        return super.onReady();
    }
}

export { BucketingError, DataStore, EntityType, FileLogger, GoalDataKey, LogLevel, RuleError, SystemEvents, VariationChangeType, ConvertSDK as default };
//# sourceMappingURL=index.mjs.map
